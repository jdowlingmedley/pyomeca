{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pyomeca is a python library allowing you to carry out a complete biomechanical analysis; in a simple, logical and concise way. Pyomeca documentation \u00b6 See Pyomeca's documentation site . Example \u00b6 Here is an example of a complete EMG pipeline in just one command: from motion import Analogs Features \u00b6 Object-oriented architecture where each class is associated with common and specialized functionalities: Markers3d : 3d markers positions Analogs3d : analogs (emg, force or any analog meca) GeneralizedCoordinate : generalized coordinate (joint angle) RotoTrans : roto-translation matrix Specialized functionalities including processing routine commonly used in biomechanics: filters, normalization, onset detection, outliers detection, derivative, etc. Each functionality can be chained. In addition to making it easier to write and read code, it allows you to add and remove analysis steps easily (such as Lego blocks). Each class inherits from a numpy array, so you can create your own analysis step easily. Easy reading and writing interface to common files in biomechanics ( .c3d , .csv , .xlsx , .mat , .sto , .trc , .mot ): Common linear algebra routine implemented: get Euler angles to/from roto-translation matrix, create a system of axes, set a rotation or translation, transpose or inverse, etc. Installation \u00b6 Using Conda \u00b6 First, install miniconda or anaconda . Then type: conda install pyomeca -c conda-forge Using pip \u00b6 First, you need to install python, swig and numpy. Then, follow the instructions to compile ezc3d . Finally, install pyomeca with: pip install git+https://github.com/pyomeca/pyomeca/ ` Integration with other modules \u00b6 Pyomeca is designed to work well with other libraries that we have developed: pyosim : interface between OpenSim and pyomeca to perform batch musculoskeletal analyses ezc3d : Easy to use C3D reader/writer in C++, Python and Matlab biorbd : C++ interface and add-ons to the Rigid Body Dynamics Library, with Python and Matlab binders. Bug Reports & Questions \u00b6 Pyomeca is Apache-licensed and the source code is available on GitHub . If any questions or issues come up as you use pyomeca, please get in touch via GitHub issues . We welcome any input, feedback, bug reports, and contributions.","title":"Home"},{"location":"#pyomeca-documentation","text":"See Pyomeca's documentation site .","title":"Pyomeca documentation"},{"location":"#example","text":"Here is an example of a complete EMG pipeline in just one command: from motion import Analogs","title":"Example"},{"location":"#features","text":"Object-oriented architecture where each class is associated with common and specialized functionalities: Markers3d : 3d markers positions Analogs3d : analogs (emg, force or any analog meca) GeneralizedCoordinate : generalized coordinate (joint angle) RotoTrans : roto-translation matrix Specialized functionalities including processing routine commonly used in biomechanics: filters, normalization, onset detection, outliers detection, derivative, etc. Each functionality can be chained. In addition to making it easier to write and read code, it allows you to add and remove analysis steps easily (such as Lego blocks). Each class inherits from a numpy array, so you can create your own analysis step easily. Easy reading and writing interface to common files in biomechanics ( .c3d , .csv , .xlsx , .mat , .sto , .trc , .mot ): Common linear algebra routine implemented: get Euler angles to/from roto-translation matrix, create a system of axes, set a rotation or translation, transpose or inverse, etc.","title":"Features"},{"location":"#installation","text":"","title":"Installation"},{"location":"#using-conda","text":"First, install miniconda or anaconda . Then type: conda install pyomeca -c conda-forge","title":"Using Conda"},{"location":"#using-pip","text":"First, you need to install python, swig and numpy. Then, follow the instructions to compile ezc3d . Finally, install pyomeca with: pip install git+https://github.com/pyomeca/pyomeca/ `","title":"Using pip"},{"location":"#integration-with-other-modules","text":"Pyomeca is designed to work well with other libraries that we have developed: pyosim : interface between OpenSim and pyomeca to perform batch musculoskeletal analyses ezc3d : Easy to use C3D reader/writer in C++, Python and Matlab biorbd : C++ interface and add-ons to the Rigid Body Dynamics Library, with Python and Matlab binders.","title":"Integration with other modules"},{"location":"#bug-reports-questions","text":"Pyomeca is Apache-licensed and the source code is available on GitHub . If any questions or issues come up as you use pyomeca, please get in touch via GitHub issues . We welcome any input, feedback, bug reports, and contributions.","title":"Bug Reports &amp; Questions"},{"location":"about/","text":"TODO \u00b6 Rototrans: \u00b6 get_rotation get_translation? set_rotation set_translation transpose inverse mean Markers \u00b6 rotate norm Spatio ima labitur falsa falle \u00b6 Lorem markdownum nocte ab suis, uritur monimenta inminet en sermone, Tereo. Est altius quoque frustra cum, vim turba sero tendens eodem si nulla, passuque alarum ut . Virtus praetulit incursu pariterque modo dubitabile rupit. test \u00b6 Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 \"\"\" Bubble sort \"\"\" def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] \"\"\" Bubble sort \"\"\" def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Bug Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Tip Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Theme extension prerequisites As the custom_dir variable is used for the theme extension process, the Material theme needs to be installed via pip and referenced with the name parameter in your mkdocs.yml . Arcus quam cunctatus ture est ille ingemuit \u00b6 Flentemque corpus animosos insigne Crenaee: et magnae plantis venturaque dixit pone. Titania nati per, hoc citi videre, montis quoque occidat ferunt, ait Aeneae genitore . Moraque in furtum referunt: degravat demum. Iri fuit est cecinisse vidit transit dextris sed miles. Non facto per sacraria veniam, sub mole fidissima posito multorum infecit, adhuc temporis. Tempore his certam caelique per et polis Heu est Hebe esse numina ipse ad Adorat distinguunt dixit parte Humani ille fingi serpens visum Cadmi et tellus Et illam Certe mare protinus in aethere cavis causa \u00b6 Ulixes quamvis: erat, Amythaone mordebat manifesta tellure ultor haec cui sagitta mortis, oscula placabilis . Et volat. Suo obstat, putat Athamanta. Cavernis numerare, obstem in per ait conceperat Aeolidae ignotissima ad. Fecissent nostri genetrix tempora montibus, quibus, vidi os! Tua tam silvis petunt, de arces fingebam velocia, nato. Alii per equi et breve. Iura his \u00b6 Nyseides si moram piscator pondus scitusque vestra fumabant negaretur finem exstimulata capillos vetetve ait. Versum inclusum , in de Aeacidae arcus, praedam fraude enim sitis, alis Insula mediis loqueretur dedere morte? Et porreximus forte et quae cognataque ora Dianae, oculis dextrasque ? Herculis in eunti pependit aureus paelex: gradu nota si Erebi sic , sicco numen templa Echion comitesque. Unda laevaque solvi pulcherrime repetit telo, multorum expellitur dotem; coronam. Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"About"},{"location":"about/#todo","text":"","title":"TODO"},{"location":"about/#rototrans","text":"get_rotation get_translation? set_rotation set_translation transpose inverse mean","title":"Rototrans:"},{"location":"about/#markers","text":"rotate norm","title":"Markers"},{"location":"about/#spatio-ima-labitur-falsa-falle","text":"Lorem markdownum nocte ab suis, uritur monimenta inminet en sermone, Tereo. Est altius quoque frustra cum, vim turba sero tendens eodem si nulla, passuque alarum ut . Virtus praetulit incursu pariterque modo dubitabile rupit.","title":"Spatio ima labitur falsa falle"},{"location":"about/#test","text":"Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 \"\"\" Bubble sort \"\"\" def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] \"\"\" Bubble sort \"\"\" def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Bug Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Tip Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Theme extension prerequisites As the custom_dir variable is used for the theme extension process, the Material theme needs to be installed via pip and referenced with the name parameter in your mkdocs.yml .","title":"test"},{"location":"about/#arcus-quam-cunctatus-ture-est-ille-ingemuit","text":"Flentemque corpus animosos insigne Crenaee: et magnae plantis venturaque dixit pone. Titania nati per, hoc citi videre, montis quoque occidat ferunt, ait Aeneae genitore . Moraque in furtum referunt: degravat demum. Iri fuit est cecinisse vidit transit dextris sed miles. Non facto per sacraria veniam, sub mole fidissima posito multorum infecit, adhuc temporis. Tempore his certam caelique per et polis Heu est Hebe esse numina ipse ad Adorat distinguunt dixit parte Humani ille fingi serpens visum Cadmi et tellus Et illam","title":"Arcus quam cunctatus ture est ille ingemuit"},{"location":"about/#certe-mare-protinus-in-aethere-cavis-causa","text":"Ulixes quamvis: erat, Amythaone mordebat manifesta tellure ultor haec cui sagitta mortis, oscula placabilis . Et volat. Suo obstat, putat Athamanta. Cavernis numerare, obstem in per ait conceperat Aeolidae ignotissima ad. Fecissent nostri genetrix tempora montibus, quibus, vidi os! Tua tam silvis petunt, de arces fingebam velocia, nato. Alii per equi et breve.","title":"Certe mare protinus in aethere cavis causa"},{"location":"about/#iura-his","text":"Nyseides si moram piscator pondus scitusque vestra fumabant negaretur finem exstimulata capillos vetetve ait. Versum inclusum , in de Aeacidae arcus, praedam fraude enim sitis, alis Insula mediis loqueretur dedere morte? Et porreximus forte et quae cognataque ora Dianae, oculis dextrasque ? Herculis in eunti pependit aureus paelex: gradu nota si Erebi sic , sicco numen templa Echion comitesque. Unda laevaque solvi pulcherrime repetit telo, multorum expellitur dotem; coronam. Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"Iura his"},{"location":"case-studies/","text":"","title":"Case Studies"},{"location":"getting-started/","text":"Getting Started \u00b6 Installation \u00b6 motion itself is a pure Python package, but its dependencies are not. The easiest way to get everything installed is to use conda . To install motion with its recommended dependencies using the conda command line tool: conda install -c conda-forge motion Now that motion is installed, you should be able to import it: import motion Core data structures \u00b6 Motion have several data structures, which build upon and extend the core strengths of xarray . Analogs Markers Angles Rototrans","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installation","text":"motion itself is a pure Python package, but its dependencies are not. The easiest way to get everything installed is to use conda . To install motion with its recommended dependencies using the conda command line tool: conda install -c conda-forge motion Now that motion is installed, you should be able to import it: import motion","title":"Installation"},{"location":"getting-started/#core-data-structures","text":"Motion have several data structures, which build upon and extend the core strengths of xarray . Analogs Markers Angles Rototrans","title":"Core data structures"},{"location":"user-guide/","text":"","title":"User Guide"},{"location":"api/analogs/","text":"analogs.py \u00b6 Analogs \u00b6 __new__ ( cls , data = None , channels = None , time_frames = None , * args , ** kwargs ) (staticmethod) \u00b6 Show source code in motion/analogs.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , channels : Optional [ list ] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Analogs DataArray with `axis`, `channel` and `time_frame` dimensions To instantiate an `Analogs` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from motion import Analogs n_channels = 4 n_frames = 100 data = np.random.random(size=(n_channels, n_frames)) analogs = Analogs(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] analogs = Analogs(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) analogs = Analogs(data, channels=names, time_frames=time_frames) ``` Calling `Analogs()` generate an empty array. Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 )) if channels is not None : coords [ \"channel\" ] = channels if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"channel\" , \"time_frame\" ), coords = coords , name = \"analogs\" , * args , ** kwargs , ) Analogs DataArray with axis , channel and time_frame dimensions To instantiate an Analogs with 4 channels and 100 frames filled with some random data: import numpy as np from motion import Analogs n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_channels , n_frames )) analogs = Analogs ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] analogs = Analogs ( data , channels = names ) And an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) analogs = Analogs ( data , channels = names , time_frames = time_frames ) Calling Analogs() generate an empty array. Parameters Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None *args Positional argument(s) to be passed to xarray.DataArray () **kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates from_c3d ( filename , usecols = None , prefix_delimiter = None , suffix_delimiter = None , attrs = None ) (classmethod) \u00b6 Show source code in motion/analogs.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a c3d file To read [this c3d file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers_analogs.c3d), type: ```python from motion import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Voltage.1\", \"Voltage.2\", \"Voltage.3\"] analogs = Analogs.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Voltage.1\"` and you specify `suffix_delimiter=\".\"`, you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": ```python channels = [\"1\", \"2\", \"3\"] analogs = Analogs.from_c3d(data_path, usecols=channels, prefix_delimiter=\".\") ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs ) Analogs DataArray from a c3d file To read this c3d file , type: from motion import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Voltage.1\" , \"Voltage.2\" , \"Voltage.3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Voltage.1\" and you specify suffix_delimiter=\".\" , you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": channels = [ \"1\" , \"2\" , \"3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels , prefix_delimiter = \".\" ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates from_csv ( filename , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , last_column_to_remove = None , prefix_delimiter = None , suffix_delimiter = None , skiprows = None , pandas_kwargs = None , attrs = None ) (classmethod) \u00b6 Show source code in motion/analogs.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a csv file To read [this csv file](https://github.com/romainmartinez/motion/blob/master/tests/data/analogs.csv), type: ```python from motion import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs.from_csv(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"IM EMG1\", \"IM EMG2\", \"IM EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"IM EMG1\"` and you specify `suffix_delimiter=\" \"`, you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": ```python channels = [\"EMG1\", \"EMG2\", \"EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels, suffix_delimiter=\" \", ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=1, time_column=0 ) ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , ) Analogs DataArray from a csv file To read this csv file , type: from motion import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"IM EMG1\" , \"IM EMG2\" , \"IM EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"IM EMG1\" and you specify suffix_delimiter=\" \" , you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": channels = [ \"EMG1\" , \"EMG2\" , \"EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels , suffix_delimiter = \" \" , ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates from_excel ( filename , sheet_name = 0 , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , last_column_to_remove = None , prefix_delimiter = None , suffix_delimiter = None , skiprows = None , pandas_kwargs = None , attrs = None ) (classmethod) \u00b6 Show source code in motion/analogs.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a excel file To read [this excel file](https://github.com/romainmartinez/motion/blob/master/tests/data/analogs.xlsx), type: ```python from motion import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs.from_excel(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"A\"] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=1, time_column=0 ) ``` Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , sheet_name , ) Analogs DataArray from a excel file To read this excel file , type: from motion import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"A\" ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates from_mot ( filename , end_header = None , ** kwargs ) (classmethod) \u00b6 Show source code in motion/analogs.py 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 @classmethod def from_mot ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a mot file To read [this mot file](https://github.com/romainmartinez/motion/blob/master/tests/data/inverse_kin.mot), type: ```python from motion import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs.from_mot(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"elbow_flexion\", \"pro_sup\"] analogs = Analogs.from_mot(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_mot(data_path, usecols=channels) ``` Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined. kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_sto_or_mot ( cls , filename , end_header , ** kwargs ) Analogs DataArray from a mot file To read this mot file , type: from motion import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs . from_mot ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"elbow_flexion\" , \"pro_sup\" ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined. None **kwargs Keyword arguments to be passed to from_csv {} Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates from_random_data ( distribution = 'normal' , size = ( 10 , 100 ), * args , ** kwargs ) (classmethod) \u00b6 Show source code in motion/analogs.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate an `Analogs` with some random data sampled from a normal distribution: ```python from motion import Analogs n_channels = 10 n_frames = 100 size = n_channels, n_frames analogs = Analogs.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python analogs = Analogs.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random Analogs `xarray.DataArray` sampled from a given distribution \"\"\" return Analogs ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate an Analogs with some random data sampled from a normal distribution: from motion import Analogs n_channels = 10 n_frames = 100 size = n_channels , n_frames analogs = Analogs . from_random_data ( size = size ) You can choose any distribution available in numpy.random : analogs = Analogs . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (10, 100) *args Positional argument(s) to be passed to numpy.random. distribution () **kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random Analogs xarray.DataArray sampled from a given distribution from_sto ( filename , end_header = None , ** kwargs ) (classmethod) \u00b6 Show source code in motion/analogs.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 @classmethod def from_sto ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a sto file To read [this sto file](https://github.com/romainmartinez/motion/blob/master/tests/data/inverse_dyn.sto), type: ```python from motion import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs.from_sto(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"shoulder_plane_moment\", \"shoulder_ele_moment\"] analogs = Analogs.from_sto(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_sto(data_path, usecols=channels) ``` Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_sto_or_mot ( cls , filename , end_header , ** kwargs ) Analogs DataArray from a sto file To read this sto file , type: from motion import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs . from_sto ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"shoulder_plane_moment\" , \"shoulder_ele_moment\" ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined None **kwargs Keyword arguments to be passed to from_csv {} Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates","title":"Analogs"},{"location":"api/analogs/#analogspy","text":"","title":"analogs.py"},{"location":"api/analogs/#motion.analogs.Analogs","text":"","title":"Analogs"},{"location":"api/analogs/#motion.analogs.Analogs.from_c3d","text":"Show source code in motion/analogs.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a c3d file To read [this c3d file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers_analogs.c3d), type: ```python from motion import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Voltage.1\", \"Voltage.2\", \"Voltage.3\"] analogs = Analogs.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Voltage.1\"` and you specify `suffix_delimiter=\".\"`, you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": ```python channels = [\"1\", \"2\", \"3\"] analogs = Analogs.from_c3d(data_path, usecols=channels, prefix_delimiter=\".\") ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs ) Analogs DataArray from a c3d file To read this c3d file , type: from motion import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Voltage.1\" , \"Voltage.2\" , \"Voltage.3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Voltage.1\" and you specify suffix_delimiter=\".\" , you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": channels = [ \"1\" , \"2\" , \"3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels , prefix_delimiter = \".\" ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates","title":"from_c3d()"},{"location":"api/analogs/#motion.analogs.Analogs.from_csv","text":"Show source code in motion/analogs.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a csv file To read [this csv file](https://github.com/romainmartinez/motion/blob/master/tests/data/analogs.csv), type: ```python from motion import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs.from_csv(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"IM EMG1\", \"IM EMG2\", \"IM EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"IM EMG1\"` and you specify `suffix_delimiter=\" \"`, you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": ```python channels = [\"EMG1\", \"EMG2\", \"EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels, suffix_delimiter=\" \", ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=1, time_column=0 ) ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , ) Analogs DataArray from a csv file To read this csv file , type: from motion import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"IM EMG1\" , \"IM EMG2\" , \"IM EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"IM EMG1\" and you specify suffix_delimiter=\" \" , you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": channels = [ \"EMG1\" , \"EMG2\" , \"EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels , suffix_delimiter = \" \" , ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates","title":"from_csv()"},{"location":"api/analogs/#motion.analogs.Analogs.from_excel","text":"Show source code in motion/analogs.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a excel file To read [this excel file](https://github.com/romainmartinez/motion/blob/master/tests/data/analogs.xlsx), type: ```python from motion import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs.from_excel(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"A\"] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=1, time_column=0 ) ``` Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , sheet_name , ) Analogs DataArray from a excel file To read this excel file , type: from motion import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"A\" ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates","title":"from_excel()"},{"location":"api/analogs/#motion.analogs.Analogs.from_mot","text":"Show source code in motion/analogs.py 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 @classmethod def from_mot ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a mot file To read [this mot file](https://github.com/romainmartinez/motion/blob/master/tests/data/inverse_kin.mot), type: ```python from motion import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs.from_mot(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"elbow_flexion\", \"pro_sup\"] analogs = Analogs.from_mot(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_mot(data_path, usecols=channels) ``` Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined. kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_sto_or_mot ( cls , filename , end_header , ** kwargs ) Analogs DataArray from a mot file To read this mot file , type: from motion import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs . from_mot ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"elbow_flexion\" , \"pro_sup\" ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined. None **kwargs Keyword arguments to be passed to from_csv {} Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates","title":"from_mot()"},{"location":"api/analogs/#motion.analogs.Analogs.from_random_data","text":"Show source code in motion/analogs.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate an `Analogs` with some random data sampled from a normal distribution: ```python from motion import Analogs n_channels = 10 n_frames = 100 size = n_channels, n_frames analogs = Analogs.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python analogs = Analogs.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random Analogs `xarray.DataArray` sampled from a given distribution \"\"\" return Analogs ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate an Analogs with some random data sampled from a normal distribution: from motion import Analogs n_channels = 10 n_frames = 100 size = n_channels , n_frames analogs = Analogs . from_random_data ( size = size ) You can choose any distribution available in numpy.random : analogs = Analogs . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (10, 100) *args Positional argument(s) to be passed to numpy.random. distribution () **kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random Analogs xarray.DataArray sampled from a given distribution","title":"from_random_data()"},{"location":"api/analogs/#motion.analogs.Analogs.from_sto","text":"Show source code in motion/analogs.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 @classmethod def from_sto ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a sto file To read [this sto file](https://github.com/romainmartinez/motion/blob/master/tests/data/inverse_dyn.sto), type: ```python from motion import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs.from_sto(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"shoulder_plane_moment\", \"shoulder_ele_moment\"] analogs = Analogs.from_sto(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_sto(data_path, usecols=channels) ``` Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_sto_or_mot ( cls , filename , end_header , ** kwargs ) Analogs DataArray from a sto file To read this sto file , type: from motion import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs . from_sto ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"shoulder_plane_moment\" , \"shoulder_ele_moment\" ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined None **kwargs Keyword arguments to be passed to from_csv {} Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates","title":"from_sto()"},{"location":"api/angles/","text":"angles.py \u00b6 Angles \u00b6 __new__ ( cls , data = None , time_frames = None , * args , ** kwargs ) (staticmethod) \u00b6 Show source code in motion/angles.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Angles DataArray with `row`, `col` and `time_frame` dimensions To instantiate an `Angles` 4 by 4 and 100 frames filled with some random data: ```python import numpy as np from motion import Angles n_row = 4 n_col = 4 n_frames = 100 data = np.random.random(size=(n_row, n_col, n_frames)) angles = Angles(data) ``` You can an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) angles = Angles(data, time_frames=time_frames) ``` Calling `Angles()` generate an empty array. Arguments: data: Array to be passed to xarray.DataArray time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Angles `xarray.DataArray` with the specified data and coordinates \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"row\" , \"col\" , \"time_frame\" ), coords = coords , name = \"angles\" , * args , ** kwargs , ) Angles DataArray with row , col and time_frame dimensions To instantiate an Angles 4 by 4 and 100 frames filled with some random data: import numpy as np from motion import Angles n_row = 4 n_col = 4 n_frames = 100 data = np . random . random ( size = ( n_row , n_col , n_frames )) angles = Angles ( data ) You can an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) angles = Angles ( data , time_frames = time_frames ) Calling Angles() generate an empty array. Parameters Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None *args Positional argument(s) to be passed to xarray.DataArray () **kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns Type Description DataArray Angles xarray.DataArray with the specified data and coordinates from_random_data ( distribution = 'normal' , size = ( 10 , 10 , 100 ), * args , ** kwargs ) (classmethod) \u00b6 Show source code in motion/angles.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 10 , 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate an `Angles` with some random data sampled from a normal distribution: ```python from motion import Angles n_frames = 100 size = 10, 10, n_frames angles = Angles.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python angles = Angles.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random angles `xarray.DataArray` sampled from a given distribution \"\"\" return Angles ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate an Angles with some random data sampled from a normal distribution: from motion import Angles n_frames = 100 size = 10 , 10 , n_frames angles = Angles . from_random_data ( size = size ) You can choose any distribution available in numpy.random : angles = Angles . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (10, 10, 100) *args Positional argument(s) to be passed to numpy.random. distribution () **kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random angles xarray.DataArray sampled from a given distribution from_rototrans ( rototrans , angle_sequence ) (classmethod) \u00b6 Show source code in motion/angles.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 @classmethod def from_rototrans ( cls , rototrans : xr . DataArray , angle_sequence : str ) -> xr . DataArray : \"\"\" Angles DataArray from a rototranslation matrix and specified angle sequence To get the euler angles from a random rototranslation matrix with a given angle sequence type: ```python from motion import Angles, Rototrans size = (4, 4, 100) rt = Rototrans.from_random_data(size=size) angles_sequence = \"xyz\" angles = Angles.from_rototrans(rototrans=rt, angle_sequence=angles_sequence) ``` Arguments: rototrans: Rototranslation matrix created with motion.Rototrans() angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" Returns: Angles `xarray.DataArray` from the specified rototrans and angles sequence \"\"\" return angles_from_rototrans ( cls , rototrans , angle_sequence ) Angles DataArray from a rototranslation matrix and specified angle sequence To get the euler angles from a random rototranslation matrix with a given angle sequence type: from motion import Angles , Rototrans size = ( 4 , 4 , 100 ) rt = Rototrans . from_random_data ( size = size ) angles_sequence = \"xyz\" angles = Angles . from_rototrans ( rototrans = rt , angle_sequence = angles_sequence ) Parameters Name Type Description Default rototrans DataArray Rototranslation matrix created with motion.Rototrans() required angle_sequence str Euler sequence of angles. Valid values are all permutations of \"xyz\" required Returns Type Description DataArray Angles xarray.DataArray from the specified rototrans and angles sequence","title":"Angles"},{"location":"api/angles/#anglespy","text":"","title":"angles.py"},{"location":"api/angles/#motion.angles.Angles","text":"","title":"Angles"},{"location":"api/angles/#motion.angles.Angles.from_random_data","text":"Show source code in motion/angles.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 10 , 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate an `Angles` with some random data sampled from a normal distribution: ```python from motion import Angles n_frames = 100 size = 10, 10, n_frames angles = Angles.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python angles = Angles.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random angles `xarray.DataArray` sampled from a given distribution \"\"\" return Angles ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate an Angles with some random data sampled from a normal distribution: from motion import Angles n_frames = 100 size = 10 , 10 , n_frames angles = Angles . from_random_data ( size = size ) You can choose any distribution available in numpy.random : angles = Angles . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (10, 10, 100) *args Positional argument(s) to be passed to numpy.random. distribution () **kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random angles xarray.DataArray sampled from a given distribution","title":"from_random_data()"},{"location":"api/angles/#motion.angles.Angles.from_rototrans","text":"Show source code in motion/angles.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 @classmethod def from_rototrans ( cls , rototrans : xr . DataArray , angle_sequence : str ) -> xr . DataArray : \"\"\" Angles DataArray from a rototranslation matrix and specified angle sequence To get the euler angles from a random rototranslation matrix with a given angle sequence type: ```python from motion import Angles, Rototrans size = (4, 4, 100) rt = Rototrans.from_random_data(size=size) angles_sequence = \"xyz\" angles = Angles.from_rototrans(rototrans=rt, angle_sequence=angles_sequence) ``` Arguments: rototrans: Rototranslation matrix created with motion.Rototrans() angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" Returns: Angles `xarray.DataArray` from the specified rototrans and angles sequence \"\"\" return angles_from_rototrans ( cls , rototrans , angle_sequence ) Angles DataArray from a rototranslation matrix and specified angle sequence To get the euler angles from a random rototranslation matrix with a given angle sequence type: from motion import Angles , Rototrans size = ( 4 , 4 , 100 ) rt = Rototrans . from_random_data ( size = size ) angles_sequence = \"xyz\" angles = Angles . from_rototrans ( rototrans = rt , angle_sequence = angles_sequence ) Parameters Name Type Description Default rototrans DataArray Rototranslation matrix created with motion.Rototrans() required angle_sequence str Euler sequence of angles. Valid values are all permutations of \"xyz\" required Returns Type Description DataArray Angles xarray.DataArray from the specified rototrans and angles sequence","title":"from_rototrans()"},{"location":"api/dataarray_accessor/","text":"dataarray_accessor.py \u00b6 MecaDataArrayAccessor \u00b6 abs ( self ) \u00b6 Show source code in motion/dataarray_accessor.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def abs ( self ) -> xr . DataArray : \"\"\" Calculate the absolute value element-wise To compute the absolute value of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.abs() ``` Returns: A `xarray.DataArray` containing the absolute of each element \"\"\" return algebra . abs_ ( self . _obj ) Calculate the absolute value element-wise To compute the absolute value of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . abs () Returns Type Description DataArray A xarray.DataArray containing the absolute of each element band_pass ( self , freq , order , cutoff ) \u00b6 Show source code in motion/dataarray_accessor.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def band_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ list , tuple , np . array ] ) -> xr . DataArray : \"\"\" Band-pass Butterworth filter To band-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 10-200Hz: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz band_pass = analogs.meca.band_pass(freq=freq, order=2, cutoff=[10, 200]) analogs.plot(label=\"raw\") band_pass.plot(label=\"band-pass @ 10-200Hz\") plt.legend() plt.show() ``` ![band_pass](../../images/api/band_pass.svg) Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) Returns: A band-pass filtered `xarray.DataArray` \"\"\" return filter . band_pass ( self . _obj , freq , order , cutoff ) Band-pass Butterworth filter To band-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 10-200Hz: import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz band_pass = analogs . meca . band_pass ( freq = freq , order = 2 , cutoff = [ 10 , 200 ]) analogs . plot ( label = \"raw\" ) band_pass . plot ( label = \"band-pass @ 10-200Hz\" ) plt . legend () plt . show () Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required Returns Type Description DataArray A band-pass filtered xarray.DataArray band_stop ( self , freq , order , cutoff ) \u00b6 Show source code in motion/dataarray_accessor.py 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 def band_stop ( self , freq : Union [ int , float ], order : int , cutoff : Union [ list , tuple , np . array ] ) -> xr . DataArray : \"\"\" Band-stop Butterworth filter To band-stop any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 40-60Hz: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz band_stop = analogs.meca.band_stop(freq=freq, order=2, cutoff=[40, 60]) analogs.plot(label=\"raw\") band_stop.plot(label=\"band-stop @ 40-60Hz\") plt.legend() plt.show() ``` ![band_stop](../../images/api/band_stop.svg) Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) Returns: A band-stop filtered `xarray.DataArray` \"\"\" return filter . band_stop ( self . _obj , freq , order , cutoff ) Band-stop Butterworth filter To band-stop any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 40-60Hz: import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz band_stop = analogs . meca . band_stop ( freq = freq , order = 2 , cutoff = [ 40 , 60 ]) analogs . plot ( label = \"raw\" ) band_stop . plot ( label = \"band-stop @ 40-60Hz\" ) plt . legend () plt . show () Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required Returns Type Description DataArray A band-stop filtered xarray.DataArray center ( self , mu = None ) \u00b6 Show source code in motion/dataarray_accessor.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def center ( self , mu : Union [ xr . DataArray , np . array , float , int ] = None ) -> xr . DataArray : \"\"\" Center an array (i.e., subtract the mean). To center any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import numpy as np from motion import Analogs random_data = np.random.uniform(low=2, high=4, size=(1, 100)) analogs = Analogs(random_data) centered = analogs.meca.center() ``` This will substract the mean of the signal by default. The previous random signal was sampled from a uniform distribution from 2 and 4 (mean around 3). When centered, the signal is now center around 0 (mean around 0). ```python import matplotlib.pyplot as plt analogs.plot(label=\"raw\") centered.plot(label=\"centered\") plt.legend() plt.show() ``` ![center](../../images/api/center.svg) Arguments: mu: mean of the signal to subtract. If not provided, takes the mean along the time_frame axis Returns: a `xarray.DataArray` containing the root-mean-square of the matrix \"\"\" return algebra . center ( self . _obj , mu ) Center an array (i.e., subtract the mean). To center any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import numpy as np from motion import Analogs random_data = np . random . uniform ( low = 2 , high = 4 , size = ( 1 , 100 )) analogs = Analogs ( random_data ) centered = analogs . meca . center () This will substract the mean of the signal by default. The previous random signal was sampled from a uniform distribution from 2 and 4 (mean around 3). When centered, the signal is now center around 0 (mean around 0). import matplotlib.pyplot as plt analogs . plot ( label = \"raw\" ) centered . plot ( label = \"centered\" ) plt . legend () plt . show () Parameters Name Type Description Default mu Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] mean of the signal to subtract. If not provided, takes the mean along the time_frame axis None Returns Type Description DataArray a xarray.DataArray containing the root-mean-square of the matrix detect_onset ( self , threshold , n_above = 1 , n_below = 0 , threshold2 = None , n_above2 = 1 ) \u00b6 Show source code in motion/dataarray_accessor.py 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 def detect_onset ( self , threshold : Union [ float , int ], n_above : int = 1 , n_below : int = 0 , threshold2 : int = None , n_above2 : int = 1 , ) -> np . array : \"\"\" Detects onset based on amplitude threshold To detect the onsets of any __one-dimensional__ `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt import numpy as np import scipy.signal as sig from motion import Analogs # simulate fake ecg data rr = 2.5 # rr time in seconds freq = 100 # sampling rate pqrst = sig.resample(sig.wavelets.daub(10), int(rr * freq)) ecg = np.concatenate([pqrst, pqrst, pqrst]).reshape(1, -1) analogs = Analogs(ecg) analogs.plot() onsets = analogs.sel(channel=0).meca.detect_onset( threshold=analogs.mean(), # mean of the signal n_above=freq / 2, # we want at least 1/2 second above the threshold n_below=freq / 2, # we accept point below threshold for 1/2 second ) for (start, end) in onsets: plt.axvline(x=start, color=\"g\") plt.axvline(x=end, color=\"r\") plt.show() ``` ![detect_onset](../../images/api/detect_onset.svg) !!! warning `detect_onset` works only for 1-dimensional data. For example, you can select a dimension using `analogs.sel(channel='EMG1') or `analogs.isel(channel=0)`` Arguments: threshold: minimum amplitude to detect n_above: minimum number of continuous samples >= `threshold` to detect n_below: minimum number of continuous samples below `threshold` that will be ignored in the detection of `x` >= `threshold` threshold2: minimum amplitude of `n_above2` values in `x` to detect n_above2: minimum number of samples >= `threshold2` to detect Note: You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns: inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events \"\"\" return misc . detect_onset ( self . _obj , threshold , n_above , n_below , threshold2 , n_above2 ) Detects onset based on amplitude threshold To detect the onsets of any one-dimensional xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt import numpy as np import scipy.signal as sig from motion import Analogs # simulate fake ecg data rr = 2.5 # rr time in seconds freq = 100 # sampling rate pqrst = sig . resample ( sig . wavelets . daub ( 10 ), int ( rr * freq )) ecg = np . concatenate ([ pqrst , pqrst , pqrst ]) . reshape ( 1 , - 1 ) analogs = Analogs ( ecg ) analogs . plot () onsets = analogs . sel ( channel = 0 ) . meca . detect_onset ( threshold = analogs . mean (), # mean of the signal n_above = freq / 2 , # we want at least 1/2 second above the threshold n_below = freq / 2 , # we accept point below threshold for 1/2 second ) for ( start , end ) in onsets : plt . axvline ( x = start , color = \"g\" ) plt . axvline ( x = end , color = \"r\" ) plt . show () Warning detect_onset works only for 1-dimensional data. For example, you can select a dimension using analogs.sel(channel='EMG1') or analogs.isel(channel=0)`` Parameters Name Type Description Default threshold Union[float, int] minimum amplitude to detect required n_above int minimum number of continuous samples >= threshold to detect 1 n_below int minimum number of continuous samples below threshold that will be ignored in the detection of x >= threshold 0 threshold2 int minimum amplitude of n_above2 values in x to detect None n_above2 int minimum number of samples >= threshold2 to detect 1 Note You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns Type Description <built-in function array> inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events detect_outliers ( self , threshold = 3 ) \u00b6 Show source code in motion/dataarray_accessor.py 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 def detect_outliers ( self , threshold : int = 3 ) -> xr . DataArray : \"\"\" Detects data points that are `threshold` times the standard deviation from the mean. To get a boolean `xr.DataArray` containing the data that are 3 times the mean +/- standard deviation: ```python from motion import Analogs analogs = Analogs.from_random_data() outliers = analogs.meca.detect_outliers(threshold=1) ``` Let's plot the data that are 1 time the mean +/- standard deviation on an analog vector: ```python import matplotlib.pyplot as plt analogs = Analogs.from_random_data(size=(1, 100)) threshold = 1 outliers = analogs.meca.detect_outliers(threshold=threshold) analogs.plot.line(x=\"time_frame\", color=\"black\", add_legend=False) analogs.where(outliers).plot.line( x=\"time_frame\", color=\"red\", add_legend=False, marker=\"o\", label=\"outliers\" ) mu = analogs.mean() sigma = analogs.std() plt.axhline(mu, color=\"grey\") plt.axhspan( mu - threshold * sigma, mu + threshold * sigma, color=\"grey\", alpha=0.3, label=f\"mean +/- {threshold} std\", ) plt.legend() plt.show() ``` ![detect_outliers](../../images/api/detect_outliers.svg) Note: `detect_outliers` is not limited on one-dimensional data and can detect outliers for any number of dimensions. Arguments: threshold: Multiple of standard deviation from which data is considered outlier Returns: A boolean `xarray.DataArray` containing the outliers \"\"\" return misc . detect_outliers ( self . _obj , threshold ) Detects data points that are threshold times the standard deviation from the mean. To get a boolean xr.DataArray containing the data that are 3 times the mean +/- standard deviation: from motion import Analogs analogs = Analogs . from_random_data () outliers = analogs . meca . detect_outliers ( threshold = 1 ) Let's plot the data that are 1 time the mean +/- standard deviation on an analog vector: import matplotlib.pyplot as plt analogs = Analogs . from_random_data ( size = ( 1 , 100 )) threshold = 1 outliers = analogs . meca . detect_outliers ( threshold = threshold ) analogs . plot . line ( x = \"time_frame\" , color = \"black\" , add_legend = False ) analogs . where ( outliers ) . plot . line ( x = \"time_frame\" , color = \"red\" , add_legend = False , marker = \"o\" , label = \"outliers\" ) mu = analogs . mean () sigma = analogs . std () plt . axhline ( mu , color = \"grey\" ) plt . axhspan ( mu - threshold * sigma , mu + threshold * sigma , color = \"grey\" , alpha = 0.3 , label = f \"mean +/- { threshold } std\" , ) plt . legend () plt . show () Note detect_outliers is not limited on one-dimensional data and can detect outliers for any number of dimensions. Parameters Name Type Description Default threshold int Multiple of standard deviation from which data is considered outlier 3 Returns Type Description DataArray A boolean xarray.DataArray containing the outliers fft ( self , freq , only_positive = True ) \u00b6 Show source code in motion/dataarray_accessor.py 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 def fft ( self , freq : Union [ int , float ], only_positive : bool = True ) -> xr . DataArray : \"\"\" Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. Let's compare the resulting fft on a raw and low-passed signal: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs # generate fake data freq = 100 time = np.arange(0, 1, 0.01) w = 2 * np.pi y = np.sin(w * time) + 0.1 * np.sin(10 * w * time) analogs = Analogs(y.reshape(1, -1)) analogs_low_passed = analogs.meca.low_pass(freq=freq, order=2, cutoff=5) # compute fft on raw and low-passed signal fft_raw = analogs.meca.fft(freq=freq) fft_low_passed = analogs_low_passed.meca.fft(freq=freq) fig, ax = plt.subplots(ncols=2, figsize=(10, 4)) # plot signal vs. time analogs.plot.line(x=\"time_frame\", ax=ax[0], color=\"black\", add_legend=False) analogs_low_passed.plot.line(x=\"time_frame\", ax=ax[0], color=\"red\", add_legend=False) ax[0].set_title(\"Signal vs. Time\") # plot amplitudes vs. frequencies fft_raw.plot.line(x=\"freq\", ax=ax[1], color=\"black\", label=\"raw\") fft_low_passed.plot.line(x=\"freq\", ax=ax[1], color=\"red\", label=\"low-pass @ 5Hz\") ax[1].set_title(\"Amplitudes vs. Freq\") plt.legend() plt.show() ``` ![band_pass](../../images/api/fft.svg) Arguments: freq: Sampling frequency (usually in array.attrs['rate']) only_positive: Returns only the positives frequencies if true Returns: A `xarray.DataArray` with the corresponding amplitudes and frequencies \"\"\" return misc . fft ( self . _obj , freq , only_positive ) Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. Let's compare the resulting fft on a raw and low-passed signal: import matplotlib.pyplot as plt import numpy as np from motion import Analogs # generate fake data freq = 100 time = np . arange ( 0 , 1 , 0.01 ) w = 2 * np . pi y = np . sin ( w * time ) + 0.1 * np . sin ( 10 * w * time ) analogs = Analogs ( y . reshape ( 1 , - 1 )) analogs_low_passed = analogs . meca . low_pass ( freq = freq , order = 2 , cutoff = 5 ) # compute fft on raw and low-passed signal fft_raw = analogs . meca . fft ( freq = freq ) fft_low_passed = analogs_low_passed . meca . fft ( freq = freq ) fig , ax = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) # plot signal vs. time analogs . plot . line ( x = \"time_frame\" , ax = ax [ 0 ], color = \"black\" , add_legend = False ) analogs_low_passed . plot . line ( x = \"time_frame\" , ax = ax [ 0 ], color = \"red\" , add_legend = False ) ax [ 0 ] . set_title ( \"Signal vs. Time\" ) # plot amplitudes vs. frequencies fft_raw . plot . line ( x = \"freq\" , ax = ax [ 1 ], color = \"black\" , label = \"raw\" ) fft_low_passed . plot . line ( x = \"freq\" , ax = ax [ 1 ], color = \"red\" , label = \"low-pass @ 5Hz\" ) ax [ 1 ] . set_title ( \"Amplitudes vs. Freq\" ) plt . legend () plt . show () Parameters Name Type Description Default freq Union[int, float] Sampling frequency (usually in array.attrs['rate']) required only_positive bool Returns only the positives frequencies if true True Returns Type Description DataArray A xarray.DataArray with the corresponding amplitudes and frequencies high_pass ( self , freq , order , cutoff ) \u00b6 Show source code in motion/dataarray_accessor.py 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 def high_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ int , float , np . array ] ) -> xr . DataArray : \"\"\" High-pass Butterworth filter To high-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 100Hz: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz high_pass = analogs.meca.high_pass(freq=freq, order=2, cutoff=100) analogs.plot(label=\"raw\") high_pass.plot(label=\"high-pass @ 100Hz\") plt.legend() plt.show() ``` ![high_pass](../../images/api/high_pass.svg) Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency Returns: A high-pass filtered `xarray.DataArray` \"\"\" return filter . high_pass ( self . _obj , freq , order , cutoff ) High-pass Butterworth filter To high-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 100Hz: import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz high_pass = analogs . meca . high_pass ( freq = freq , order = 2 , cutoff = 100 ) analogs . plot ( label = \"raw\" ) high_pass . plot ( label = \"high-pass @ 100Hz\" ) plt . legend () plt . show () Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required Returns Type Description DataArray A high-pass filtered xarray.DataArray low_pass ( self , freq , order , cutoff ) \u00b6 Show source code in motion/dataarray_accessor.py 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 def low_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ int , float , np . array ] ) -> xr . DataArray : \"\"\" Low-pass Butterworth filter To low-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 5Hz: ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.low_pass(freq=100, order=2, cutoff=5) ``` Let's see how the low-pass smooth a fake sinusoidal signal: ```python import matplotlib.pyplot as plt import numpy as np # generate fake data freq = 100 # Hz time_vector = np.linspace(start=0, stop=100, num=100) w = 2 * np.pi * 1 y = np.sin(w * time_vector) + 0.1 * np.sin(10 * w * time_vector) analogs = Analogs(y.reshape(1, -1)) low_pass = analogs.meca.low_pass(freq=freq, order=2, cutoff=5) analogs.plot(label=\"raw\") low_pass.plot(label=\"low-pass @ 5Hz\") plt.legend() plt.show() ``` ![low_pass](../../images/api/low_pass.svg) Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency Returns: A low-pass filtered `xarray.DataArray` \"\"\" return filter . low_pass ( self . _obj , freq , order , cutoff ) Low-pass Butterworth filter To low-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 5Hz: from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . low_pass ( freq = 100 , order = 2 , cutoff = 5 ) Let's see how the low-pass smooth a fake sinusoidal signal: import matplotlib.pyplot as plt import numpy as np # generate fake data freq = 100 # Hz time_vector = np . linspace ( start = 0 , stop = 100 , num = 100 ) w = 2 * np . pi * 1 y = np . sin ( w * time_vector ) + 0.1 * np . sin ( 10 * w * time_vector ) analogs = Analogs ( y . reshape ( 1 , - 1 )) low_pass = analogs . meca . low_pass ( freq = freq , order = 2 , cutoff = 5 ) analogs . plot ( label = \"raw\" ) low_pass . plot ( label = \"low-pass @ 5Hz\" ) plt . legend () plt . show () Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required Returns Type Description DataArray A low-pass filtered xarray.DataArray matmul ( self , other ) \u00b6 Show source code in motion/dataarray_accessor.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def matmul ( self , other : xr . DataArray ) -> xr . DataArray : \"\"\" Matrix product of two arrays To compute the matrix product of two `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs first_analogs = Analogs.from_random_data() second_analogs = Analogs.from_random_data() first_analogs.meca.matmul(second_analogs) ``` You can also use the shorthand `@`: ```python first_analogs @ second_analogs ``` Arguments: other: second array to multiply Returns: A `xarray.DataArray` containing the matrix product of the two arrays \"\"\" return algebra . matmul ( self . _obj , other ) Matrix product of two arrays To compute the matrix product of two xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs first_analogs = Analogs . from_random_data () second_analogs = Analogs . from_random_data () first_analogs . meca . matmul ( second_analogs ) You can also use the shorthand @ : first_analogs @ second_analogs Parameters Name Type Description Default other DataArray second array to multiply required Returns Type Description DataArray A xarray.DataArray containing the matrix product of the two arrays norm ( self , dim , ord = None ) \u00b6 Show source code in motion/dataarray_accessor.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def norm ( self , dim : Union [ str , list ], ord : int = None ) -> xr . DataArray : \"\"\" Return the norm of an array. To compute the norm of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) along a given dimension: ```python from motion import Markers markers = Markers.from_random_data() markers.meca.norm(dim=\"axis\") ``` Arguments: dim: Name(s) of the data dimension(s) ord: Order of the norm Returns: A `xarray.DataArray` containing the norm of the matrix. \"\"\" return algebra . norm ( self . _obj , dim , ord ) Return the norm of an array. To compute the norm of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) along a given dimension: from motion import Markers markers = Markers . from_random_data () markers . meca . norm ( dim = \"axis\" ) Parameters Name Type Description Default dim Union[str, list] Name(s) of the data dimension(s) required ord int Order of the norm None Returns Type Description DataArray A xarray.DataArray containing the norm of the matrix. normalize ( self , ref = None , scale = 100 ) \u00b6 Show source code in motion/dataarray_accessor.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def normalize ( self , ref : Union [ xr . DataArray , np . array , float , int ] = None , scale : Union [ int , float ] = 100 , ) -> xr . DataArray : \"\"\" Normalize a signal against `ref` on a scale of `scale`. To normalize any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs.from_random_data(size=(1, 100)).meca.abs() normalized = analogs.meca.normalize() normalized.plot() plt.show() ``` ![normalize](../../images/api/normalize.svg) By default, this function normalize against the signal's max. To specify any other value, use the `ref` parameter: ```python normalized = analogs.meca.normalize(ref=1) ``` Arguments: ref: Reference value. Could have multiple dimensions. If not provided, takes the mean along the time_frame axis scale: Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) Returns: A `xarray.DataArray` containing the normalized signal \"\"\" return algebra . normalize ( self . _obj , ref , scale ) Normalize a signal against ref on a scale of scale . To normalize any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs . from_random_data ( size = ( 1 , 100 )) . meca . abs () normalized = analogs . meca . normalize () normalized . plot () plt . show () By default, this function normalize against the signal's max. To specify any other value, use the ref parameter: normalized = analogs . meca . normalize ( ref = 1 ) Parameters Name Type Description Default ref Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] Reference value. Could have multiple dimensions. If not provided, takes the mean along the time_frame axis None scale Union[int, float] Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) 100 Returns Type Description DataArray A xarray.DataArray containing the normalized signal rms ( self ) \u00b6 Show source code in motion/dataarray_accessor.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def rms ( self ) -> xr . DataArray : \"\"\" Return the root-mean-square of an array. To compute the root-mean-square of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.rms() ``` Returns: A `xarray.DataArray` containing the root-mean-square of the matrix. \"\"\" return algebra . rms ( self . _obj ) Return the root-mean-square of an array. To compute the root-mean-square of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . rms () Returns Type Description DataArray A xarray.DataArray containing the root-mean-square of the matrix. sqrt ( self , * args , ** kwargs ) \u00b6 Show source code in motion/dataarray_accessor.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def sqrt ( self , * args , ** kwargs ) -> xr . DataArray : \"\"\" Return the non-negative square-root of an array, element-wise. To compute the non-negative square-root of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.sqrt() ``` Arguments: args: For other positional arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) Returns: A `xarray.DataArray` containing the square root of the matrix. \"\"\" return algebra . sqrt ( self . _obj , * args , ** kwargs ) Return the non-negative square-root of an array, element-wise. To compute the non-negative square-root of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . sqrt () Parameters Name Type Description Default *args For other positional arguments, see the numpy docs () **kwargs For other keyword-only arguments, see the numpy docs {} Returns Type Description DataArray A xarray.DataArray containing the square root of the matrix. square ( self , * args , ** kwargs ) \u00b6 Show source code in motion/dataarray_accessor.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def square ( self , * args , ** kwargs ) -> xr . DataArray : \"\"\" Return the element-wise square of the input To compute the element-wise square of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.square() ``` Arguments: args: For other positional arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) Returns: A `xarray.DataArray` containing the matrix squared. \"\"\" return algebra . square ( self . _obj , * args , ** kwargs ) Return the element-wise square of the input To compute the element-wise square of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . square () Parameters Name Type Description Default *args For other positional arguments, see the numpy docs () **kwargs For other keyword-only arguments, see the numpy docs {} Returns Type Description DataArray A xarray.DataArray containing the matrix squared. time_normalize ( self , time_vector = None , n_frames = 100 , norm_time_frame = False ) \u00b6 Show source code in motion/dataarray_accessor.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def time_normalize ( self , time_vector : Union [ xr . DataArray , np . array ] = None , n_frames : int = 100 , norm_time_frame : bool = False , ) -> xr . DataArray : \"\"\" Time normalization used for temporal alignment of data To time-normalize any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs.from_random_data(size=(1, 847)) time_normalized = analogs.meca.time_normalize() print(time_normalized.time_frame.size) # 100 ``` To normalize the corresponding time_frame dimension from 0 to 100%, specify `norm_time_frame=True`: ```python time_normalized = analogs.meca.time_normalize(norm_time_frame=True) time_normalized.plot() plt.show() ``` ![time_normalize](../../images/api/time_normalize.svg) By default, `time_normalize` use a time vector with 100 frames from 0 to 100. However, you can specify the desired number of frames: ```python time_normalized = analogs.meca.time_normalize(n_frames=500) print(time_normalized.time_frame.size) # 500 ``` You can also specify the desired time_vector directly in the `time_vector` parameter: ```python import numpy as np time_normalized = analogs.meca.time_normalize(time_vector=np.linspace(0, 200, 300)) ``` Arguments: time_vector: desired time vector (first to last time_frame with n_frames points by default) n_frames: if time_vector is not specified, the length of the desired time vector norm_time_frame: Normalize the time_frame dimension from 0 to 100 if True Returns: A time-normalized `xarray.DataArray` \"\"\" return interp . time_normalize ( self . _obj , time_vector , n_frames , norm_time_frame = norm_time_frame ) Time normalization used for temporal alignment of data To time-normalize any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs . from_random_data ( size = ( 1 , 847 )) time_normalized = analogs . meca . time_normalize () print ( time_normalized . time_frame . size ) # 100 To normalize the corresponding time_frame dimension from 0 to 100%, specify norm_time_frame=True : time_normalized = analogs . meca . time_normalize ( norm_time_frame = True ) time_normalized . plot () plt . show () By default, time_normalize use a time vector with 100 frames from 0 to 100. However, you can specify the desired number of frames: time_normalized = analogs . meca . time_normalize ( n_frames = 500 ) print ( time_normalized . time_frame . size ) # 500 You can also specify the desired time_vector directly in the time_vector parameter: import numpy as np time_normalized = analogs . meca . time_normalize ( time_vector = np . linspace ( 0 , 200 , 300 )) Parameters Name Type Description Default time_vector Union[xarray.core.dataarray.DataArray, <built-in function array>] desired time vector (first to last time_frame with n_frames points by default) None n_frames int if time_vector is not specified, the length of the desired time vector 100 norm_time_frame bool Normalize the time_frame dimension from 0 to 100 if True False Returns Type Description DataArray A time-normalized xarray.DataArray to_csv ( self , filename , wide = True ) \u00b6 Show source code in motion/dataarray_accessor.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def to_csv ( self , filename : Union [ str , Path ], wide : Optional [ bool ] = True ): \"\"\" Write a csv file from a xarray.DataArray To write a csv file from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.to_csv(filename=\"temp.csv\") ``` By default, `to_csv` will export the data in a \"wide\" format (1 column by channel). You can also export the data in a \"tidy\" format with `wide=False`: ```python analogs.meca.to_csv(filename=\"temp.csv\", wide=False) ``` Arguments: filename: File path wide: True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. \"\"\" write_csv ( self . _obj , filename , wide ) Write a csv file from a xarray.DataArray To write a csv file from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . to_csv ( filename = \"temp.csv\" ) By default, to_csv will export the data in a \"wide\" format (1 column by channel). You can also export the data in a \"tidy\" format with wide=False : analogs . meca . to_csv ( filename = \"temp.csv\" , wide = False ) Parameters Name Type Description Default filename Union[str, pathlib.Path] File path required wide Optional[bool] True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. True to_matlab ( self , filename ) \u00b6 Show source code in motion/dataarray_accessor.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def to_matlab ( self , filename : Union [ str , Path ]): \"\"\" Write a matlab file from a xarray.DataArray To write a matlab file from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.to_matlab(filename=\"temp.mat\") ``` Arguments: filename: File path \"\"\" write_matlab ( self . _obj , filename ) Write a matlab file from a xarray.DataArray To write a matlab file from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . to_matlab ( filename = \"temp.mat\" ) Parameters Name Type Description Default filename Union[str, pathlib.Path] File path required to_wide_dataframe ( self ) \u00b6 Show source code in motion/dataarray_accessor.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def to_wide_dataframe ( self ) -> pd . DataFrame : \"\"\" Return a wide pandas.DataFrame (one column by channel) To return a dataframe from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.to_wide_dataframe() ``` Returns: A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: `array.to_series()`, or `array.to_dataframe()`. \"\"\" return to_wide_dataframe ( self . _obj ) Return a wide pandas.DataFrame (one column by channel) To return a dataframe from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . to_wide_dataframe () Returns Type Description DataFrame A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: array.to_series() , or array.to_dataframe() .","title":"Dataarray_accessor"},{"location":"api/dataarray_accessor/#dataarray_accessorpy","text":"","title":"dataarray_accessor.py"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor","text":"","title":"MecaDataArrayAccessor"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.abs","text":"Show source code in motion/dataarray_accessor.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def abs ( self ) -> xr . DataArray : \"\"\" Calculate the absolute value element-wise To compute the absolute value of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.abs() ``` Returns: A `xarray.DataArray` containing the absolute of each element \"\"\" return algebra . abs_ ( self . _obj ) Calculate the absolute value element-wise To compute the absolute value of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . abs () Returns Type Description DataArray A xarray.DataArray containing the absolute of each element","title":"abs()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.band_pass","text":"Show source code in motion/dataarray_accessor.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def band_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ list , tuple , np . array ] ) -> xr . DataArray : \"\"\" Band-pass Butterworth filter To band-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 10-200Hz: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz band_pass = analogs.meca.band_pass(freq=freq, order=2, cutoff=[10, 200]) analogs.plot(label=\"raw\") band_pass.plot(label=\"band-pass @ 10-200Hz\") plt.legend() plt.show() ``` ![band_pass](../../images/api/band_pass.svg) Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) Returns: A band-pass filtered `xarray.DataArray` \"\"\" return filter . band_pass ( self . _obj , freq , order , cutoff ) Band-pass Butterworth filter To band-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 10-200Hz: import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz band_pass = analogs . meca . band_pass ( freq = freq , order = 2 , cutoff = [ 10 , 200 ]) analogs . plot ( label = \"raw\" ) band_pass . plot ( label = \"band-pass @ 10-200Hz\" ) plt . legend () plt . show () Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required Returns Type Description DataArray A band-pass filtered xarray.DataArray","title":"band_pass()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.band_stop","text":"Show source code in motion/dataarray_accessor.py 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 def band_stop ( self , freq : Union [ int , float ], order : int , cutoff : Union [ list , tuple , np . array ] ) -> xr . DataArray : \"\"\" Band-stop Butterworth filter To band-stop any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 40-60Hz: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz band_stop = analogs.meca.band_stop(freq=freq, order=2, cutoff=[40, 60]) analogs.plot(label=\"raw\") band_stop.plot(label=\"band-stop @ 40-60Hz\") plt.legend() plt.show() ``` ![band_stop](../../images/api/band_stop.svg) Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) Returns: A band-stop filtered `xarray.DataArray` \"\"\" return filter . band_stop ( self . _obj , freq , order , cutoff ) Band-stop Butterworth filter To band-stop any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 40-60Hz: import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz band_stop = analogs . meca . band_stop ( freq = freq , order = 2 , cutoff = [ 40 , 60 ]) analogs . plot ( label = \"raw\" ) band_stop . plot ( label = \"band-stop @ 40-60Hz\" ) plt . legend () plt . show () Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required Returns Type Description DataArray A band-stop filtered xarray.DataArray","title":"band_stop()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.center","text":"Show source code in motion/dataarray_accessor.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def center ( self , mu : Union [ xr . DataArray , np . array , float , int ] = None ) -> xr . DataArray : \"\"\" Center an array (i.e., subtract the mean). To center any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import numpy as np from motion import Analogs random_data = np.random.uniform(low=2, high=4, size=(1, 100)) analogs = Analogs(random_data) centered = analogs.meca.center() ``` This will substract the mean of the signal by default. The previous random signal was sampled from a uniform distribution from 2 and 4 (mean around 3). When centered, the signal is now center around 0 (mean around 0). ```python import matplotlib.pyplot as plt analogs.plot(label=\"raw\") centered.plot(label=\"centered\") plt.legend() plt.show() ``` ![center](../../images/api/center.svg) Arguments: mu: mean of the signal to subtract. If not provided, takes the mean along the time_frame axis Returns: a `xarray.DataArray` containing the root-mean-square of the matrix \"\"\" return algebra . center ( self . _obj , mu ) Center an array (i.e., subtract the mean). To center any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import numpy as np from motion import Analogs random_data = np . random . uniform ( low = 2 , high = 4 , size = ( 1 , 100 )) analogs = Analogs ( random_data ) centered = analogs . meca . center () This will substract the mean of the signal by default. The previous random signal was sampled from a uniform distribution from 2 and 4 (mean around 3). When centered, the signal is now center around 0 (mean around 0). import matplotlib.pyplot as plt analogs . plot ( label = \"raw\" ) centered . plot ( label = \"centered\" ) plt . legend () plt . show () Parameters Name Type Description Default mu Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] mean of the signal to subtract. If not provided, takes the mean along the time_frame axis None Returns Type Description DataArray a xarray.DataArray containing the root-mean-square of the matrix","title":"center()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.detect_onset","text":"Show source code in motion/dataarray_accessor.py 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 def detect_onset ( self , threshold : Union [ float , int ], n_above : int = 1 , n_below : int = 0 , threshold2 : int = None , n_above2 : int = 1 , ) -> np . array : \"\"\" Detects onset based on amplitude threshold To detect the onsets of any __one-dimensional__ `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt import numpy as np import scipy.signal as sig from motion import Analogs # simulate fake ecg data rr = 2.5 # rr time in seconds freq = 100 # sampling rate pqrst = sig.resample(sig.wavelets.daub(10), int(rr * freq)) ecg = np.concatenate([pqrst, pqrst, pqrst]).reshape(1, -1) analogs = Analogs(ecg) analogs.plot() onsets = analogs.sel(channel=0).meca.detect_onset( threshold=analogs.mean(), # mean of the signal n_above=freq / 2, # we want at least 1/2 second above the threshold n_below=freq / 2, # we accept point below threshold for 1/2 second ) for (start, end) in onsets: plt.axvline(x=start, color=\"g\") plt.axvline(x=end, color=\"r\") plt.show() ``` ![detect_onset](../../images/api/detect_onset.svg) !!! warning `detect_onset` works only for 1-dimensional data. For example, you can select a dimension using `analogs.sel(channel='EMG1') or `analogs.isel(channel=0)`` Arguments: threshold: minimum amplitude to detect n_above: minimum number of continuous samples >= `threshold` to detect n_below: minimum number of continuous samples below `threshold` that will be ignored in the detection of `x` >= `threshold` threshold2: minimum amplitude of `n_above2` values in `x` to detect n_above2: minimum number of samples >= `threshold2` to detect Note: You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns: inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events \"\"\" return misc . detect_onset ( self . _obj , threshold , n_above , n_below , threshold2 , n_above2 ) Detects onset based on amplitude threshold To detect the onsets of any one-dimensional xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt import numpy as np import scipy.signal as sig from motion import Analogs # simulate fake ecg data rr = 2.5 # rr time in seconds freq = 100 # sampling rate pqrst = sig . resample ( sig . wavelets . daub ( 10 ), int ( rr * freq )) ecg = np . concatenate ([ pqrst , pqrst , pqrst ]) . reshape ( 1 , - 1 ) analogs = Analogs ( ecg ) analogs . plot () onsets = analogs . sel ( channel = 0 ) . meca . detect_onset ( threshold = analogs . mean (), # mean of the signal n_above = freq / 2 , # we want at least 1/2 second above the threshold n_below = freq / 2 , # we accept point below threshold for 1/2 second ) for ( start , end ) in onsets : plt . axvline ( x = start , color = \"g\" ) plt . axvline ( x = end , color = \"r\" ) plt . show () Warning detect_onset works only for 1-dimensional data. For example, you can select a dimension using analogs.sel(channel='EMG1') or analogs.isel(channel=0)`` Parameters Name Type Description Default threshold Union[float, int] minimum amplitude to detect required n_above int minimum number of continuous samples >= threshold to detect 1 n_below int minimum number of continuous samples below threshold that will be ignored in the detection of x >= threshold 0 threshold2 int minimum amplitude of n_above2 values in x to detect None n_above2 int minimum number of samples >= threshold2 to detect 1 Note You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns Type Description <built-in function array> inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events","title":"detect_onset()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.detect_outliers","text":"Show source code in motion/dataarray_accessor.py 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 def detect_outliers ( self , threshold : int = 3 ) -> xr . DataArray : \"\"\" Detects data points that are `threshold` times the standard deviation from the mean. To get a boolean `xr.DataArray` containing the data that are 3 times the mean +/- standard deviation: ```python from motion import Analogs analogs = Analogs.from_random_data() outliers = analogs.meca.detect_outliers(threshold=1) ``` Let's plot the data that are 1 time the mean +/- standard deviation on an analog vector: ```python import matplotlib.pyplot as plt analogs = Analogs.from_random_data(size=(1, 100)) threshold = 1 outliers = analogs.meca.detect_outliers(threshold=threshold) analogs.plot.line(x=\"time_frame\", color=\"black\", add_legend=False) analogs.where(outliers).plot.line( x=\"time_frame\", color=\"red\", add_legend=False, marker=\"o\", label=\"outliers\" ) mu = analogs.mean() sigma = analogs.std() plt.axhline(mu, color=\"grey\") plt.axhspan( mu - threshold * sigma, mu + threshold * sigma, color=\"grey\", alpha=0.3, label=f\"mean +/- {threshold} std\", ) plt.legend() plt.show() ``` ![detect_outliers](../../images/api/detect_outliers.svg) Note: `detect_outliers` is not limited on one-dimensional data and can detect outliers for any number of dimensions. Arguments: threshold: Multiple of standard deviation from which data is considered outlier Returns: A boolean `xarray.DataArray` containing the outliers \"\"\" return misc . detect_outliers ( self . _obj , threshold ) Detects data points that are threshold times the standard deviation from the mean. To get a boolean xr.DataArray containing the data that are 3 times the mean +/- standard deviation: from motion import Analogs analogs = Analogs . from_random_data () outliers = analogs . meca . detect_outliers ( threshold = 1 ) Let's plot the data that are 1 time the mean +/- standard deviation on an analog vector: import matplotlib.pyplot as plt analogs = Analogs . from_random_data ( size = ( 1 , 100 )) threshold = 1 outliers = analogs . meca . detect_outliers ( threshold = threshold ) analogs . plot . line ( x = \"time_frame\" , color = \"black\" , add_legend = False ) analogs . where ( outliers ) . plot . line ( x = \"time_frame\" , color = \"red\" , add_legend = False , marker = \"o\" , label = \"outliers\" ) mu = analogs . mean () sigma = analogs . std () plt . axhline ( mu , color = \"grey\" ) plt . axhspan ( mu - threshold * sigma , mu + threshold * sigma , color = \"grey\" , alpha = 0.3 , label = f \"mean +/- { threshold } std\" , ) plt . legend () plt . show () Note detect_outliers is not limited on one-dimensional data and can detect outliers for any number of dimensions. Parameters Name Type Description Default threshold int Multiple of standard deviation from which data is considered outlier 3 Returns Type Description DataArray A boolean xarray.DataArray containing the outliers","title":"detect_outliers()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.fft","text":"Show source code in motion/dataarray_accessor.py 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 def fft ( self , freq : Union [ int , float ], only_positive : bool = True ) -> xr . DataArray : \"\"\" Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. Let's compare the resulting fft on a raw and low-passed signal: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs # generate fake data freq = 100 time = np.arange(0, 1, 0.01) w = 2 * np.pi y = np.sin(w * time) + 0.1 * np.sin(10 * w * time) analogs = Analogs(y.reshape(1, -1)) analogs_low_passed = analogs.meca.low_pass(freq=freq, order=2, cutoff=5) # compute fft on raw and low-passed signal fft_raw = analogs.meca.fft(freq=freq) fft_low_passed = analogs_low_passed.meca.fft(freq=freq) fig, ax = plt.subplots(ncols=2, figsize=(10, 4)) # plot signal vs. time analogs.plot.line(x=\"time_frame\", ax=ax[0], color=\"black\", add_legend=False) analogs_low_passed.plot.line(x=\"time_frame\", ax=ax[0], color=\"red\", add_legend=False) ax[0].set_title(\"Signal vs. Time\") # plot amplitudes vs. frequencies fft_raw.plot.line(x=\"freq\", ax=ax[1], color=\"black\", label=\"raw\") fft_low_passed.plot.line(x=\"freq\", ax=ax[1], color=\"red\", label=\"low-pass @ 5Hz\") ax[1].set_title(\"Amplitudes vs. Freq\") plt.legend() plt.show() ``` ![band_pass](../../images/api/fft.svg) Arguments: freq: Sampling frequency (usually in array.attrs['rate']) only_positive: Returns only the positives frequencies if true Returns: A `xarray.DataArray` with the corresponding amplitudes and frequencies \"\"\" return misc . fft ( self . _obj , freq , only_positive ) Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. Let's compare the resulting fft on a raw and low-passed signal: import matplotlib.pyplot as plt import numpy as np from motion import Analogs # generate fake data freq = 100 time = np . arange ( 0 , 1 , 0.01 ) w = 2 * np . pi y = np . sin ( w * time ) + 0.1 * np . sin ( 10 * w * time ) analogs = Analogs ( y . reshape ( 1 , - 1 )) analogs_low_passed = analogs . meca . low_pass ( freq = freq , order = 2 , cutoff = 5 ) # compute fft on raw and low-passed signal fft_raw = analogs . meca . fft ( freq = freq ) fft_low_passed = analogs_low_passed . meca . fft ( freq = freq ) fig , ax = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) # plot signal vs. time analogs . plot . line ( x = \"time_frame\" , ax = ax [ 0 ], color = \"black\" , add_legend = False ) analogs_low_passed . plot . line ( x = \"time_frame\" , ax = ax [ 0 ], color = \"red\" , add_legend = False ) ax [ 0 ] . set_title ( \"Signal vs. Time\" ) # plot amplitudes vs. frequencies fft_raw . plot . line ( x = \"freq\" , ax = ax [ 1 ], color = \"black\" , label = \"raw\" ) fft_low_passed . plot . line ( x = \"freq\" , ax = ax [ 1 ], color = \"red\" , label = \"low-pass @ 5Hz\" ) ax [ 1 ] . set_title ( \"Amplitudes vs. Freq\" ) plt . legend () plt . show () Parameters Name Type Description Default freq Union[int, float] Sampling frequency (usually in array.attrs['rate']) required only_positive bool Returns only the positives frequencies if true True Returns Type Description DataArray A xarray.DataArray with the corresponding amplitudes and frequencies","title":"fft()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.high_pass","text":"Show source code in motion/dataarray_accessor.py 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 def high_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ int , float , np . array ] ) -> xr . DataArray : \"\"\" High-pass Butterworth filter To high-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 100Hz: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz high_pass = analogs.meca.high_pass(freq=freq, order=2, cutoff=100) analogs.plot(label=\"raw\") high_pass.plot(label=\"high-pass @ 100Hz\") plt.legend() plt.show() ``` ![high_pass](../../images/api/high_pass.svg) Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency Returns: A high-pass filtered `xarray.DataArray` \"\"\" return filter . high_pass ( self . _obj , freq , order , cutoff ) High-pass Butterworth filter To high-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 100Hz: import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz high_pass = analogs . meca . high_pass ( freq = freq , order = 2 , cutoff = 100 ) analogs . plot ( label = \"raw\" ) high_pass . plot ( label = \"high-pass @ 100Hz\" ) plt . legend () plt . show () Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required Returns Type Description DataArray A high-pass filtered xarray.DataArray","title":"high_pass()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.low_pass","text":"Show source code in motion/dataarray_accessor.py 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 def low_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ int , float , np . array ] ) -> xr . DataArray : \"\"\" Low-pass Butterworth filter To low-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 5Hz: ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.low_pass(freq=100, order=2, cutoff=5) ``` Let's see how the low-pass smooth a fake sinusoidal signal: ```python import matplotlib.pyplot as plt import numpy as np # generate fake data freq = 100 # Hz time_vector = np.linspace(start=0, stop=100, num=100) w = 2 * np.pi * 1 y = np.sin(w * time_vector) + 0.1 * np.sin(10 * w * time_vector) analogs = Analogs(y.reshape(1, -1)) low_pass = analogs.meca.low_pass(freq=freq, order=2, cutoff=5) analogs.plot(label=\"raw\") low_pass.plot(label=\"low-pass @ 5Hz\") plt.legend() plt.show() ``` ![low_pass](../../images/api/low_pass.svg) Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency Returns: A low-pass filtered `xarray.DataArray` \"\"\" return filter . low_pass ( self . _obj , freq , order , cutoff ) Low-pass Butterworth filter To low-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 5Hz: from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . low_pass ( freq = 100 , order = 2 , cutoff = 5 ) Let's see how the low-pass smooth a fake sinusoidal signal: import matplotlib.pyplot as plt import numpy as np # generate fake data freq = 100 # Hz time_vector = np . linspace ( start = 0 , stop = 100 , num = 100 ) w = 2 * np . pi * 1 y = np . sin ( w * time_vector ) + 0.1 * np . sin ( 10 * w * time_vector ) analogs = Analogs ( y . reshape ( 1 , - 1 )) low_pass = analogs . meca . low_pass ( freq = freq , order = 2 , cutoff = 5 ) analogs . plot ( label = \"raw\" ) low_pass . plot ( label = \"low-pass @ 5Hz\" ) plt . legend () plt . show () Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required Returns Type Description DataArray A low-pass filtered xarray.DataArray","title":"low_pass()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.matmul","text":"Show source code in motion/dataarray_accessor.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def matmul ( self , other : xr . DataArray ) -> xr . DataArray : \"\"\" Matrix product of two arrays To compute the matrix product of two `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs first_analogs = Analogs.from_random_data() second_analogs = Analogs.from_random_data() first_analogs.meca.matmul(second_analogs) ``` You can also use the shorthand `@`: ```python first_analogs @ second_analogs ``` Arguments: other: second array to multiply Returns: A `xarray.DataArray` containing the matrix product of the two arrays \"\"\" return algebra . matmul ( self . _obj , other ) Matrix product of two arrays To compute the matrix product of two xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs first_analogs = Analogs . from_random_data () second_analogs = Analogs . from_random_data () first_analogs . meca . matmul ( second_analogs ) You can also use the shorthand @ : first_analogs @ second_analogs Parameters Name Type Description Default other DataArray second array to multiply required Returns Type Description DataArray A xarray.DataArray containing the matrix product of the two arrays","title":"matmul()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.norm","text":"Show source code in motion/dataarray_accessor.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def norm ( self , dim : Union [ str , list ], ord : int = None ) -> xr . DataArray : \"\"\" Return the norm of an array. To compute the norm of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) along a given dimension: ```python from motion import Markers markers = Markers.from_random_data() markers.meca.norm(dim=\"axis\") ``` Arguments: dim: Name(s) of the data dimension(s) ord: Order of the norm Returns: A `xarray.DataArray` containing the norm of the matrix. \"\"\" return algebra . norm ( self . _obj , dim , ord ) Return the norm of an array. To compute the norm of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) along a given dimension: from motion import Markers markers = Markers . from_random_data () markers . meca . norm ( dim = \"axis\" ) Parameters Name Type Description Default dim Union[str, list] Name(s) of the data dimension(s) required ord int Order of the norm None Returns Type Description DataArray A xarray.DataArray containing the norm of the matrix.","title":"norm()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.normalize","text":"Show source code in motion/dataarray_accessor.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def normalize ( self , ref : Union [ xr . DataArray , np . array , float , int ] = None , scale : Union [ int , float ] = 100 , ) -> xr . DataArray : \"\"\" Normalize a signal against `ref` on a scale of `scale`. To normalize any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs.from_random_data(size=(1, 100)).meca.abs() normalized = analogs.meca.normalize() normalized.plot() plt.show() ``` ![normalize](../../images/api/normalize.svg) By default, this function normalize against the signal's max. To specify any other value, use the `ref` parameter: ```python normalized = analogs.meca.normalize(ref=1) ``` Arguments: ref: Reference value. Could have multiple dimensions. If not provided, takes the mean along the time_frame axis scale: Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) Returns: A `xarray.DataArray` containing the normalized signal \"\"\" return algebra . normalize ( self . _obj , ref , scale ) Normalize a signal against ref on a scale of scale . To normalize any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs . from_random_data ( size = ( 1 , 100 )) . meca . abs () normalized = analogs . meca . normalize () normalized . plot () plt . show () By default, this function normalize against the signal's max. To specify any other value, use the ref parameter: normalized = analogs . meca . normalize ( ref = 1 ) Parameters Name Type Description Default ref Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] Reference value. Could have multiple dimensions. If not provided, takes the mean along the time_frame axis None scale Union[int, float] Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) 100 Returns Type Description DataArray A xarray.DataArray containing the normalized signal","title":"normalize()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.rms","text":"Show source code in motion/dataarray_accessor.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def rms ( self ) -> xr . DataArray : \"\"\" Return the root-mean-square of an array. To compute the root-mean-square of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.rms() ``` Returns: A `xarray.DataArray` containing the root-mean-square of the matrix. \"\"\" return algebra . rms ( self . _obj ) Return the root-mean-square of an array. To compute the root-mean-square of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . rms () Returns Type Description DataArray A xarray.DataArray containing the root-mean-square of the matrix.","title":"rms()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.sqrt","text":"Show source code in motion/dataarray_accessor.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def sqrt ( self , * args , ** kwargs ) -> xr . DataArray : \"\"\" Return the non-negative square-root of an array, element-wise. To compute the non-negative square-root of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.sqrt() ``` Arguments: args: For other positional arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) Returns: A `xarray.DataArray` containing the square root of the matrix. \"\"\" return algebra . sqrt ( self . _obj , * args , ** kwargs ) Return the non-negative square-root of an array, element-wise. To compute the non-negative square-root of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . sqrt () Parameters Name Type Description Default *args For other positional arguments, see the numpy docs () **kwargs For other keyword-only arguments, see the numpy docs {} Returns Type Description DataArray A xarray.DataArray containing the square root of the matrix.","title":"sqrt()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.square","text":"Show source code in motion/dataarray_accessor.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def square ( self , * args , ** kwargs ) -> xr . DataArray : \"\"\" Return the element-wise square of the input To compute the element-wise square of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.square() ``` Arguments: args: For other positional arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) Returns: A `xarray.DataArray` containing the matrix squared. \"\"\" return algebra . square ( self . _obj , * args , ** kwargs ) Return the element-wise square of the input To compute the element-wise square of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . square () Parameters Name Type Description Default *args For other positional arguments, see the numpy docs () **kwargs For other keyword-only arguments, see the numpy docs {} Returns Type Description DataArray A xarray.DataArray containing the matrix squared.","title":"square()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.time_normalize","text":"Show source code in motion/dataarray_accessor.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def time_normalize ( self , time_vector : Union [ xr . DataArray , np . array ] = None , n_frames : int = 100 , norm_time_frame : bool = False , ) -> xr . DataArray : \"\"\" Time normalization used for temporal alignment of data To time-normalize any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs.from_random_data(size=(1, 847)) time_normalized = analogs.meca.time_normalize() print(time_normalized.time_frame.size) # 100 ``` To normalize the corresponding time_frame dimension from 0 to 100%, specify `norm_time_frame=True`: ```python time_normalized = analogs.meca.time_normalize(norm_time_frame=True) time_normalized.plot() plt.show() ``` ![time_normalize](../../images/api/time_normalize.svg) By default, `time_normalize` use a time vector with 100 frames from 0 to 100. However, you can specify the desired number of frames: ```python time_normalized = analogs.meca.time_normalize(n_frames=500) print(time_normalized.time_frame.size) # 500 ``` You can also specify the desired time_vector directly in the `time_vector` parameter: ```python import numpy as np time_normalized = analogs.meca.time_normalize(time_vector=np.linspace(0, 200, 300)) ``` Arguments: time_vector: desired time vector (first to last time_frame with n_frames points by default) n_frames: if time_vector is not specified, the length of the desired time vector norm_time_frame: Normalize the time_frame dimension from 0 to 100 if True Returns: A time-normalized `xarray.DataArray` \"\"\" return interp . time_normalize ( self . _obj , time_vector , n_frames , norm_time_frame = norm_time_frame ) Time normalization used for temporal alignment of data To time-normalize any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs . from_random_data ( size = ( 1 , 847 )) time_normalized = analogs . meca . time_normalize () print ( time_normalized . time_frame . size ) # 100 To normalize the corresponding time_frame dimension from 0 to 100%, specify norm_time_frame=True : time_normalized = analogs . meca . time_normalize ( norm_time_frame = True ) time_normalized . plot () plt . show () By default, time_normalize use a time vector with 100 frames from 0 to 100. However, you can specify the desired number of frames: time_normalized = analogs . meca . time_normalize ( n_frames = 500 ) print ( time_normalized . time_frame . size ) # 500 You can also specify the desired time_vector directly in the time_vector parameter: import numpy as np time_normalized = analogs . meca . time_normalize ( time_vector = np . linspace ( 0 , 200 , 300 )) Parameters Name Type Description Default time_vector Union[xarray.core.dataarray.DataArray, <built-in function array>] desired time vector (first to last time_frame with n_frames points by default) None n_frames int if time_vector is not specified, the length of the desired time vector 100 norm_time_frame bool Normalize the time_frame dimension from 0 to 100 if True False Returns Type Description DataArray A time-normalized xarray.DataArray","title":"time_normalize()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.to_csv","text":"Show source code in motion/dataarray_accessor.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def to_csv ( self , filename : Union [ str , Path ], wide : Optional [ bool ] = True ): \"\"\" Write a csv file from a xarray.DataArray To write a csv file from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.to_csv(filename=\"temp.csv\") ``` By default, `to_csv` will export the data in a \"wide\" format (1 column by channel). You can also export the data in a \"tidy\" format with `wide=False`: ```python analogs.meca.to_csv(filename=\"temp.csv\", wide=False) ``` Arguments: filename: File path wide: True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. \"\"\" write_csv ( self . _obj , filename , wide ) Write a csv file from a xarray.DataArray To write a csv file from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . to_csv ( filename = \"temp.csv\" ) By default, to_csv will export the data in a \"wide\" format (1 column by channel). You can also export the data in a \"tidy\" format with wide=False : analogs . meca . to_csv ( filename = \"temp.csv\" , wide = False ) Parameters Name Type Description Default filename Union[str, pathlib.Path] File path required wide Optional[bool] True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. True","title":"to_csv()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.to_matlab","text":"Show source code in motion/dataarray_accessor.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def to_matlab ( self , filename : Union [ str , Path ]): \"\"\" Write a matlab file from a xarray.DataArray To write a matlab file from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.to_matlab(filename=\"temp.mat\") ``` Arguments: filename: File path \"\"\" write_matlab ( self . _obj , filename ) Write a matlab file from a xarray.DataArray To write a matlab file from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . to_matlab ( filename = \"temp.mat\" ) Parameters Name Type Description Default filename Union[str, pathlib.Path] File path required","title":"to_matlab()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.to_wide_dataframe","text":"Show source code in motion/dataarray_accessor.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def to_wide_dataframe ( self ) -> pd . DataFrame : \"\"\" Return a wide pandas.DataFrame (one column by channel) To return a dataframe from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.to_wide_dataframe() ``` Returns: A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: `array.to_series()`, or `array.to_dataframe()`. \"\"\" return to_wide_dataframe ( self . _obj ) Return a wide pandas.DataFrame (one column by channel) To return a dataframe from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . to_wide_dataframe () Returns Type Description DataFrame A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: array.to_series() , or array.to_dataframe() .","title":"to_wide_dataframe()"},{"location":"api/markers/","text":"markers.py \u00b6 Markers \u00b6 __new__ ( cls , data = None , channels = None , time_frames = None , * args , ** kwargs ) (staticmethod) \u00b6 Show source code in motion/markers.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , channels : Optional [ list ] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Markers DataArray with `axis`, `channel` and `time_frame` dimensions To instantiate a `Markers` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from motion import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np.random.random(size=(n_axis, n_channels, n_frames)) markers = Markers(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] markers = Markers(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) markers = Markers(data, channels=names, time_frames=time_frames) ``` Calling `Markers()` generate an empty array. Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) else : coords [ \"axis\" ] = [ \"x\" , \"y\" , \"z\" , \"ones\" ] if data . shape [ 0 ] == 3 : data = np . insert ( data , obj = 3 , values = 1 , axis = 0 ) if channels : coords [ \"channel\" ] = channels if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"axis\" , \"channel\" , \"time_frame\" ), coords = coords , name = \"markers\" , * args , ** kwargs , ) Markers DataArray with axis , channel and time_frame dimensions To instantiate a Markers with 4 channels and 100 frames filled with some random data: import numpy as np from motion import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_axis , n_channels , n_frames )) markers = Markers ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] markers = Markers ( data , channels = names ) And an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) markers = Markers ( data , channels = names , time_frames = time_frames ) Calling Markers() generate an empty array. Parameters Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None *args Positional argument(s) to be passed to xarray.DataArray () **kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates from_c3d ( filename , usecols = None , prefix_delimiter = None , suffix_delimiter = None , attrs = None ) (classmethod) \u00b6 Show source code in motion/markers.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a c3d file To read [this c3d file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers_analogs.c3d), type: ```python from motion import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Daphnee:ASISl\", \"Daphnee:PSISr\", \"Daphnee:PSISl\"] markers = Markers.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"\"Daphnee:ASISl\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISl\", \"PSISr\", \"PSISl\"] markers = Markers.from_c3d(data_path, prefix_delimiter=\":\") ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs ) Markers DataArray from a c3d file To read this c3d file , type: from motion import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Daphnee:ASISl\" , \"Daphnee:PSISr\" , \"Daphnee:PSISl\" ] markers = Markers . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"\"Daphnee:ASISl\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISl\" , \"PSISr\" , \"PSISl\" ] markers = Markers . from_c3d ( data_path , prefix_delimiter = \":\" ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates from_csv ( filename , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , last_column_to_remove = None , prefix_delimiter = None , suffix_delimiter = None , skiprows = None , pandas_kwargs = None , attrs = None ) (classmethod) \u00b6 Show source code in motion/markers.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a csv file To read [this csv file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.csv), type: ```python from motion import Markers data_path = \"./tests/data/markers.csv\" markers = Markers.from_csv(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"Daphnee:ASISr\", \"Daphnee:ASISl\", \"Daphnee:PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Daphnee:ASISr\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISr\", \"ASISl\", \"PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , ) Markers DataArray from a csv file To read this csv file , type: from motion import Markers data_path = \"./tests/data/markers.csv\" markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"Daphnee:ASISr\" , \"Daphnee:ASISl\" , \"Daphnee:PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Daphnee:ASISr\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISr\" , \"ASISl\" , \"PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates from_excel ( filename , sheet_name = 0 , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , last_column_to_remove = None , prefix_delimiter = None , suffix_delimiter = None , skiprows = None , pandas_kwargs = None , attrs = None ) (classmethod) \u00b6 Show source code in motion/markers.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a excel file To read [this excel file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.xlsx), type: ```python from motion import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers.from_excel(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"boite:gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"boite:gauche_ext\"` and you specify `suffix_delimiter=\":\"`, you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , sheet_name , ) Markers DataArray from a excel file To read this excel file , type: from motion import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"boite:gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"boite:gauche_ext\" and you specify suffix_delimiter=\":\" , you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates from_random_data ( distribution = 'normal' , size = ( 3 , 10 , 100 ), * args , ** kwargs ) (classmethod) \u00b6 Show source code in motion/markers.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate a `Markers` with some random data sampled from a normal distribution: ```python from motion import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis, n_channels, n_frames markers = Markers.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python markers = Markers.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random markers `xarray.DataArray` sampled from a given distribution \"\"\" return Markers ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate a Markers with some random data sampled from a normal distribution: from motion import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis , n_channels , n_frames markers = Markers . from_random_data ( size = size ) You can choose any distribution available in numpy.random : markers = Markers . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 10, 100) *args Positional argument(s) to be passed to numpy.random. distribution () **kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random markers xarray.DataArray sampled from a given distribution from_trc ( filename , ** kwargs ) (classmethod) \u00b6 Show source code in motion/markers.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 @classmethod def from_trc ( cls , filename : Union [ str , Path ], ** kwargs ) -> xr . DataArray : \"\"\" Markers DataArray from a trc file To read [this trc file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.trc), type: ```python from motion import Markers data_path = \"./tests/data/markers.trc\" markers = Markers.from_trc(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"STER\", \"STERl\"] markers = Markers.from_trc(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] markers = Markers.from_trc(data_path, usecols=channels) ``` Arguments: filename: Any valid string path kwargs: Keyword arguments to be passed to `from_csv` Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_trc ( cls , filename , ** kwargs ) Markers DataArray from a trc file To read this trc file , type: from motion import Markers data_path = \"./tests/data/markers.trc\" markers = Markers . from_trc ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"STER\" , \"STERl\" ] markers = Markers . from_trc ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] markers = Markers . from_trc ( data_path , usecols = channels ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required **kwargs Keyword arguments to be passed to from_csv {} Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates","title":"Markers"},{"location":"api/markers/#markerspy","text":"","title":"markers.py"},{"location":"api/markers/#motion.markers.Markers","text":"","title":"Markers"},{"location":"api/markers/#motion.markers.Markers.from_c3d","text":"Show source code in motion/markers.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a c3d file To read [this c3d file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers_analogs.c3d), type: ```python from motion import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Daphnee:ASISl\", \"Daphnee:PSISr\", \"Daphnee:PSISl\"] markers = Markers.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"\"Daphnee:ASISl\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISl\", \"PSISr\", \"PSISl\"] markers = Markers.from_c3d(data_path, prefix_delimiter=\":\") ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs ) Markers DataArray from a c3d file To read this c3d file , type: from motion import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Daphnee:ASISl\" , \"Daphnee:PSISr\" , \"Daphnee:PSISl\" ] markers = Markers . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"\"Daphnee:ASISl\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISl\" , \"PSISr\" , \"PSISl\" ] markers = Markers . from_c3d ( data_path , prefix_delimiter = \":\" ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates","title":"from_c3d()"},{"location":"api/markers/#motion.markers.Markers.from_csv","text":"Show source code in motion/markers.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a csv file To read [this csv file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.csv), type: ```python from motion import Markers data_path = \"./tests/data/markers.csv\" markers = Markers.from_csv(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"Daphnee:ASISr\", \"Daphnee:ASISl\", \"Daphnee:PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Daphnee:ASISr\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISr\", \"ASISl\", \"PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , ) Markers DataArray from a csv file To read this csv file , type: from motion import Markers data_path = \"./tests/data/markers.csv\" markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"Daphnee:ASISr\" , \"Daphnee:ASISl\" , \"Daphnee:PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Daphnee:ASISr\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISr\" , \"ASISl\" , \"PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates","title":"from_csv()"},{"location":"api/markers/#motion.markers.Markers.from_excel","text":"Show source code in motion/markers.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a excel file To read [this excel file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.xlsx), type: ```python from motion import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers.from_excel(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"boite:gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"boite:gauche_ext\"` and you specify `suffix_delimiter=\":\"`, you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , sheet_name , ) Markers DataArray from a excel file To read this excel file , type: from motion import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"boite:gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"boite:gauche_ext\" and you specify suffix_delimiter=\":\" , you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates","title":"from_excel()"},{"location":"api/markers/#motion.markers.Markers.from_random_data","text":"Show source code in motion/markers.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate a `Markers` with some random data sampled from a normal distribution: ```python from motion import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis, n_channels, n_frames markers = Markers.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python markers = Markers.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random markers `xarray.DataArray` sampled from a given distribution \"\"\" return Markers ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate a Markers with some random data sampled from a normal distribution: from motion import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis , n_channels , n_frames markers = Markers . from_random_data ( size = size ) You can choose any distribution available in numpy.random : markers = Markers . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 10, 100) *args Positional argument(s) to be passed to numpy.random. distribution () **kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random markers xarray.DataArray sampled from a given distribution","title":"from_random_data()"},{"location":"api/markers/#motion.markers.Markers.from_trc","text":"Show source code in motion/markers.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 @classmethod def from_trc ( cls , filename : Union [ str , Path ], ** kwargs ) -> xr . DataArray : \"\"\" Markers DataArray from a trc file To read [this trc file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.trc), type: ```python from motion import Markers data_path = \"./tests/data/markers.trc\" markers = Markers.from_trc(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"STER\", \"STERl\"] markers = Markers.from_trc(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] markers = Markers.from_trc(data_path, usecols=channels) ``` Arguments: filename: Any valid string path kwargs: Keyword arguments to be passed to `from_csv` Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_trc ( cls , filename , ** kwargs ) Markers DataArray from a trc file To read this trc file , type: from motion import Markers data_path = \"./tests/data/markers.trc\" markers = Markers . from_trc ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"STER\" , \"STERl\" ] markers = Markers . from_trc ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] markers = Markers . from_trc ( data_path , usecols = channels ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required **kwargs Keyword arguments to be passed to from_csv {} Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates","title":"from_trc()"},{"location":"api/rototrans/","text":"rototrans.py \u00b6 Rototrans \u00b6 __new__ ( cls , data = None , time_frames = None , * args , ** kwargs ) (staticmethod) \u00b6 Show source code in motion/rototrans.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Rototrans DataArray with `axis`, `channel` and `time_frame` dimensions To instantiate a `Rototrans` 4 by 4 and 100 frames filled with some random data: ```python import numpy as np from motion import Rototrans n_row = 4 n_col = 4 n_frames = 100 data = np.random.random(size=(n_row, n_col, n_frames)) rt = Rototrans(data) ``` You can an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) rt = Rototrans(data, time_frames=time_frames) ``` Calling `Rototrans()` generate an empty array. Arguments: data: Array to be passed to xarray.DataArray time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Rototrans `xarray.DataArray` with the specified data and coordinates \"\"\" coords = {} if data is None : data = np . eye ( 4 ) if data . shape [ 0 ] != 4 or data . shape [ 1 ] != 4 : raise IndexError ( f \"data must have first and second dimensions of length 4, you have: { data . shape } \" ) if data . ndim == 2 : data = data [ ... , np . newaxis ] if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"row\" , \"col\" , \"time_frame\" ), coords = coords , name = \"rototrans\" , * args , ** kwargs , ) Rototrans DataArray with axis , channel and time_frame dimensions To instantiate a Rototrans 4 by 4 and 100 frames filled with some random data: import numpy as np from motion import Rototrans n_row = 4 n_col = 4 n_frames = 100 data = np . random . random ( size = ( n_row , n_col , n_frames )) rt = Rototrans ( data ) You can an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) rt = Rototrans ( data , time_frames = time_frames ) Calling Rototrans() generate an empty array. Parameters Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None *args Positional argument(s) to be passed to xarray.DataArray () **kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns Type Description DataArray Rototrans xarray.DataArray with the specified data and coordinates from_euler_angles ( angles = None , angle_sequence = None , translations = None ) (classmethod) \u00b6 Show source code in motion/rototrans.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @classmethod def from_euler_angles ( cls , angles : Optional [ xr . DataArray ] = None , angle_sequence : Optional [ str ] = None , translations : Optional [ xr . DataArray ] = None , ) -> xr . DataArray : \"\"\" Rototrans DataArray from euler angles and specified angle sequence To get the rototranslation matrix from random euler angles with a given angle sequence type: ```python from motion import Angles, Rototrans size = (3, 1, 100) angles = Angles.from_random_data(size=size) angles_sequence = \"xyz\" rt = Rototrans.from_euler_angles(angles=angles, angle_sequence=angles_sequence) ``` A translation vector can also be specified: ```python translation = Angles.from_random_data(size=size) rt = Rototrans.from_euler_angles( angles=angles, angle_sequence=angles_sequence, translations=translation ) ``` Arguments: angles: Euler angles of the rototranslation matrix angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" translations: Translation part of the Rototrans matrix Returns: Rototrans `xarray.DataArray` from the specified angles and angles sequence \"\"\" return rototrans_from_euler_angles ( cls , angles , angle_sequence , translations ) Rototrans DataArray from euler angles and specified angle sequence To get the rototranslation matrix from random euler angles with a given angle sequence type: from motion import Angles , Rototrans size = ( 3 , 1 , 100 ) angles = Angles . from_random_data ( size = size ) angles_sequence = \"xyz\" rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence ) A translation vector can also be specified: translation = Angles . from_random_data ( size = size ) rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence , translations = translation ) Parameters Name Type Description Default angles Optional[xarray.core.dataarray.DataArray] Euler angles of the rototranslation matrix None angle_sequence Optional[str] Euler sequence of angles. Valid values are all permutations of \"xyz\" None translations Optional[xarray.core.dataarray.DataArray] Translation part of the Rototrans matrix None Returns Type Description DataArray Rototrans xarray.DataArray from the specified angles and angles sequence from_random_data ( distribution = 'normal' , size = ( 4 , 4 , 100 ), * args , ** kwargs ) (classmethod) \u00b6 Show source code in motion/rototrans.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 4 , 4 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate a `Rototrans` with some random data sampled from a normal distribution: ```python from motion import Rototrans n_frames = 100 size = 4, 4, n_frames rt = Rototrans.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python rt = Rototrans.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random rototrans `xarray.DataArray` sampled from a given distribution \"\"\" return Rototrans ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate a Rototrans with some random data sampled from a normal distribution: from motion import Rototrans n_frames = 100 size = 4 , 4 , n_frames rt = Rototrans . from_random_data ( size = size ) You can choose any distribution available in numpy.random : rt = Rototrans . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (4, 4, 100) *args Positional argument(s) to be passed to numpy.random. distribution () **kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random rototrans xarray.DataArray sampled from a given distribution","title":"Rototrans"},{"location":"api/rototrans/#rototranspy","text":"","title":"rototrans.py"},{"location":"api/rototrans/#motion.rototrans.Rototrans","text":"","title":"Rototrans"},{"location":"api/rototrans/#motion.rototrans.Rototrans.from_euler_angles","text":"Show source code in motion/rototrans.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @classmethod def from_euler_angles ( cls , angles : Optional [ xr . DataArray ] = None , angle_sequence : Optional [ str ] = None , translations : Optional [ xr . DataArray ] = None , ) -> xr . DataArray : \"\"\" Rototrans DataArray from euler angles and specified angle sequence To get the rototranslation matrix from random euler angles with a given angle sequence type: ```python from motion import Angles, Rototrans size = (3, 1, 100) angles = Angles.from_random_data(size=size) angles_sequence = \"xyz\" rt = Rototrans.from_euler_angles(angles=angles, angle_sequence=angles_sequence) ``` A translation vector can also be specified: ```python translation = Angles.from_random_data(size=size) rt = Rototrans.from_euler_angles( angles=angles, angle_sequence=angles_sequence, translations=translation ) ``` Arguments: angles: Euler angles of the rototranslation matrix angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" translations: Translation part of the Rototrans matrix Returns: Rototrans `xarray.DataArray` from the specified angles and angles sequence \"\"\" return rototrans_from_euler_angles ( cls , angles , angle_sequence , translations ) Rototrans DataArray from euler angles and specified angle sequence To get the rototranslation matrix from random euler angles with a given angle sequence type: from motion import Angles , Rototrans size = ( 3 , 1 , 100 ) angles = Angles . from_random_data ( size = size ) angles_sequence = \"xyz\" rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence ) A translation vector can also be specified: translation = Angles . from_random_data ( size = size ) rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence , translations = translation ) Parameters Name Type Description Default angles Optional[xarray.core.dataarray.DataArray] Euler angles of the rototranslation matrix None angle_sequence Optional[str] Euler sequence of angles. Valid values are all permutations of \"xyz\" None translations Optional[xarray.core.dataarray.DataArray] Translation part of the Rototrans matrix None Returns Type Description DataArray Rototrans xarray.DataArray from the specified angles and angles sequence","title":"from_euler_angles()"},{"location":"api/rototrans/#motion.rototrans.Rototrans.from_random_data","text":"Show source code in motion/rototrans.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 4 , 4 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate a `Rototrans` with some random data sampled from a normal distribution: ```python from motion import Rototrans n_frames = 100 size = 4, 4, n_frames rt = Rototrans.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python rt = Rototrans.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random rototrans `xarray.DataArray` sampled from a given distribution \"\"\" return Rototrans ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate a Rototrans with some random data sampled from a normal distribution: from motion import Rototrans n_frames = 100 size = 4 , 4 , n_frames rt = Rototrans . from_random_data ( size = size ) You can choose any distribution available in numpy.random : rt = Rototrans . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (4, 4, 100) *args Positional argument(s) to be passed to numpy.random. distribution () **kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random rototrans xarray.DataArray sampled from a given distribution","title":"from_random_data()"}]}