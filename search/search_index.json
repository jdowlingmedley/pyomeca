{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"about/","text":"TODO \u00b6 Rototrans: \u00b6 get_rotation get_translation? set_rotation set_translation transpose inverse mean Markers \u00b6 rotate norm Spatio ima labitur falsa falle \u00b6 Lorem markdownum nocte ab suis, uritur monimenta inminet en sermone, Tereo. Est altius quoque frustra cum, vim turba sero tendens eodem si nulla, passuque alarum ut . Virtus praetulit incursu pariterque modo dubitabile rupit. test \u00b6 Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 \"\"\" Bubble sort \"\"\" def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] \"\"\" Bubble sort \"\"\" def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Bug Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Tip Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Theme extension prerequisites As the custom_dir variable is used for the theme extension process, the Material theme needs to be installed via pip and referenced with the name parameter in your mkdocs.yml . Arcus quam cunctatus ture est ille ingemuit \u00b6 Flentemque corpus animosos insigne Crenaee: et magnae plantis venturaque dixit pone. Titania nati per, hoc citi videre, montis quoque occidat ferunt, ait Aeneae genitore . Moraque in furtum referunt: degravat demum. Iri fuit est cecinisse vidit transit dextris sed miles. Non facto per sacraria veniam, sub mole fidissima posito multorum infecit, adhuc temporis. Tempore his certam caelique per et polis Heu est Hebe esse numina ipse ad Adorat distinguunt dixit parte Humani ille fingi serpens visum Cadmi et tellus Et illam Certe mare protinus in aethere cavis causa \u00b6 Ulixes quamvis: erat, Amythaone mordebat manifesta tellure ultor haec cui sagitta mortis, oscula placabilis . Et volat. Suo obstat, putat Athamanta. Cavernis numerare, obstem in per ait conceperat Aeolidae ignotissima ad. Fecissent nostri genetrix tempora montibus, quibus, vidi os! Tua tam silvis petunt, de arces fingebam velocia, nato. Alii per equi et breve. Iura his \u00b6 Nyseides si moram piscator pondus scitusque vestra fumabant negaretur finem exstimulata capillos vetetve ait. Versum inclusum , in de Aeacidae arcus, praedam fraude enim sitis, alis Insula mediis loqueretur dedere morte? Et porreximus forte et quae cognataque ora Dianae, oculis dextrasque ? Herculis in eunti pependit aureus paelex: gradu nota si Erebi sic , sicco numen templa Echion comitesque. Unda laevaque solvi pulcherrime repetit telo, multorum expellitur dotem; coronam. Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"About"},{"location":"about/#todo","text":"","title":"TODO"},{"location":"about/#rototrans","text":"get_rotation get_translation? set_rotation set_translation transpose inverse mean","title":"Rototrans:"},{"location":"about/#markers","text":"rotate norm","title":"Markers"},{"location":"about/#spatio-ima-labitur-falsa-falle","text":"Lorem markdownum nocte ab suis, uritur monimenta inminet en sermone, Tereo. Est altius quoque frustra cum, vim turba sero tendens eodem si nulla, passuque alarum ut . Virtus praetulit incursu pariterque modo dubitabile rupit.","title":"Spatio ima labitur falsa falle"},{"location":"about/#test","text":"Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 \"\"\" Bubble sort \"\"\" def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] \"\"\" Bubble sort \"\"\" def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Bug Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Tip Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Theme extension prerequisites As the custom_dir variable is used for the theme extension process, the Material theme needs to be installed via pip and referenced with the name parameter in your mkdocs.yml .","title":"test"},{"location":"about/#arcus-quam-cunctatus-ture-est-ille-ingemuit","text":"Flentemque corpus animosos insigne Crenaee: et magnae plantis venturaque dixit pone. Titania nati per, hoc citi videre, montis quoque occidat ferunt, ait Aeneae genitore . Moraque in furtum referunt: degravat demum. Iri fuit est cecinisse vidit transit dextris sed miles. Non facto per sacraria veniam, sub mole fidissima posito multorum infecit, adhuc temporis. Tempore his certam caelique per et polis Heu est Hebe esse numina ipse ad Adorat distinguunt dixit parte Humani ille fingi serpens visum Cadmi et tellus Et illam","title":"Arcus quam cunctatus ture est ille ingemuit"},{"location":"about/#certe-mare-protinus-in-aethere-cavis-causa","text":"Ulixes quamvis: erat, Amythaone mordebat manifesta tellure ultor haec cui sagitta mortis, oscula placabilis . Et volat. Suo obstat, putat Athamanta. Cavernis numerare, obstem in per ait conceperat Aeolidae ignotissima ad. Fecissent nostri genetrix tempora montibus, quibus, vidi os! Tua tam silvis petunt, de arces fingebam velocia, nato. Alii per equi et breve.","title":"Certe mare protinus in aethere cavis causa"},{"location":"about/#iura-his","text":"Nyseides si moram piscator pondus scitusque vestra fumabant negaretur finem exstimulata capillos vetetve ait. Versum inclusum , in de Aeacidae arcus, praedam fraude enim sitis, alis Insula mediis loqueretur dedere morte? Et porreximus forte et quae cognataque ora Dianae, oculis dextrasque ? Herculis in eunti pependit aureus paelex: gradu nota si Erebi sic , sicco numen templa Echion comitesque. Unda laevaque solvi pulcherrime repetit telo, multorum expellitur dotem; coronam. Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"Iura his"},{"location":"case-studies/","text":"","title":"Case Studies"},{"location":"getting-started/","text":"Getting Started \u00b6 Installation \u00b6 motion itself is a pure Python package, but its dependencies are not. The easiest way to get everything installed is to use conda . To install motion with its recommended dependencies using the conda command line tool: conda install -c conda-forge motion Now that motion is installed, you should be able to import it: import motion Core data structures \u00b6 Motion have several data structures, which build upon and extend the core strengths of xarray . Analogs Markers Angles Rototrans","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installation","text":"motion itself is a pure Python package, but its dependencies are not. The easiest way to get everything installed is to use conda . To install motion with its recommended dependencies using the conda command line tool: conda install -c conda-forge motion Now that motion is installed, you should be able to import it: import motion","title":"Installation"},{"location":"getting-started/#core-data-structures","text":"Motion have several data structures, which build upon and extend the core strengths of xarray . Analogs Markers Angles Rototrans","title":"Core data structures"},{"location":"user-guide/","text":"","title":"User Guide"},{"location":"api/analogs/","text":"analogs.py \u00b6 Analogs \u00b6 __new__ ( cls , data = None , channels = None , time_frames = None , * args , ** kwargs ) (staticmethod) \u00b6 Show source code in motion/analogs.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , channels : Optional [ list ] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Analogs DataArray with `axis`, `channel` and `time_frame` dimensions To instantiate an `Analogs` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from motion import Analogs n_channels = 4 n_frames = 100 data = np.random.random(size=(n_channels, n_frames)) analogs = Analogs(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] analogs = Analogs(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) analogs = Analogs(data, channels=names, time_frames=time_frames) ``` Calling `Analogs()` generate an empty array. Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 )) if channels is not None : coords [ \"channel\" ] = channels if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"channel\" , \"time_frame\" ), coords = coords , name = \"analogs\" , * args , ** kwargs , ) Analogs DataArray with axis , channel and time_frame dimensions To instantiate an Analogs with 4 channels and 100 frames filled with some random data: import numpy as np from motion import Analogs n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_channels , n_frames )) analogs = Analogs ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] analogs = Analogs ( data , channels = names ) And an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) analogs = Analogs ( data , channels = names , time_frames = time_frames ) Calling Analogs() generate an empty array. Parameters Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None *args _empty Positional argument(s) to be passed to xarray.DataArray () **kwargs _empty Keyword argument(s) to be passed to xarray.DataArray {} Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates from_c3d ( filename , usecols = None , prefix_delimiter = None , suffix_delimiter = None , attrs = None ) (classmethod) \u00b6 Show source code in motion/analogs.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a c3d file To read [this c3d file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers_analogs.c3d), type: ```python from motion import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Voltage.1\", \"Voltage.2\", \"Voltage.3\"] analogs = Analogs.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Voltage.1\"` and you specify `suffix_delimiter=\".\"`, you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": ```python channels = [\"1\", \"2\", \"3\"] analogs = Analogs.from_c3d(data_path, usecols=channels, prefix_delimiter=\".\") ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs ) Analogs DataArray from a c3d file To read this c3d file , type: from motion import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Voltage.1\" , \"Voltage.2\" , \"Voltage.3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Voltage.1\" and you specify suffix_delimiter=\".\" , you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": channels = [ \"1\" , \"2\" , \"3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels , prefix_delimiter = \".\" ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates from_csv ( filename , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , last_column_to_remove = None , prefix_delimiter = None , suffix_delimiter = None , skiprows = None , pandas_kwargs = None , attrs = None ) (classmethod) \u00b6 Show source code in motion/analogs.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a csv file To read [this csv file](https://github.com/romainmartinez/motion/blob/master/tests/data/analogs.csv), type: ```python from motion import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs.from_csv(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"IM EMG1\", \"IM EMG2\", \"IM EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"IM EMG1\"` and you specify `suffix_delimiter=\" \"`, you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": ```python channels = [\"EMG1\", \"EMG2\", \"EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels, suffix_delimiter=\" \", ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_csv(data_path, header=3, first_row=5, first_column=1, time_column=0) ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , ) Analogs DataArray from a csv file To read this csv file , type: from motion import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"IM EMG1\" , \"IM EMG2\" , \"IM EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"IM EMG1\" and you specify suffix_delimiter=\" \" , you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": channels = [ \"EMG1\" , \"EMG2\" , \"EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels , suffix_delimiter = \" \" , ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates from_excel ( filename , sheet_name = 0 , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , last_column_to_remove = None , prefix_delimiter = None , suffix_delimiter = None , skiprows = None , pandas_kwargs = None , attrs = None ) (classmethod) \u00b6 Show source code in motion/analogs.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a excel file To read [this excel file](https://github.com/romainmartinez/motion/blob/master/tests/data/analogs.xlsx), type: ```python from motion import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs.from_excel(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"A\"] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_excel(data_path, header=3, first_row=5, first_column=1, time_column=0) ``` Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , sheet_name , ) Analogs DataArray from a excel file To read this excel file , type: from motion import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"A\" ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates from_mot ( filename , end_header = None , ** kwargs ) (classmethod) \u00b6 Show source code in motion/analogs.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 @classmethod def from_mot ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a mot file To read [this mot file](https://github.com/romainmartinez/motion/blob/master/tests/data/inverse_kin.mot), type: ```python from motion import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs.from_mot(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"elbow_flexion\", \"pro_sup\"] analogs = Analogs.from_mot(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_mot(data_path, usecols=channels) ``` Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined. kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_sto_or_mot ( cls , filename , end_header , ** kwargs ) Analogs DataArray from a mot file To read this mot file , type: from motion import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs . from_mot ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"elbow_flexion\" , \"pro_sup\" ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined. None **kwargs _empty Keyword arguments to be passed to from_csv {} Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates from_random_data ( distribution = 'normal' , size = ( 10 , 100 ), * args , ** kwargs ) (classmethod) \u00b6 Show source code in motion/analogs.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate an `Analogs` with some random data sampled from a normal distribution: ```python from motion import Analogs n_channels = 10 n_frames = 100 size = n_channels, n_frames analogs = Analogs.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python analogs = Analogs.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random Analogs `xarray.DataArray` sampled from a given distribution \"\"\" return Analogs ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate an Analogs with some random data sampled from a normal distribution: from motion import Analogs n_channels = 10 n_frames = 100 size = n_channels , n_frames analogs = Analogs . from_random_data ( size = size ) You can choose any distribution available in numpy.random : analogs = Analogs . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (10, 100) *args _empty Positional argument(s) to be passed to numpy.random. distribution () **kwargs _empty Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random Analogs xarray.DataArray sampled from a given distribution from_sto ( filename , end_header = None , ** kwargs ) (classmethod) \u00b6 Show source code in motion/analogs.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 @classmethod def from_sto ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a sto file To read [this sto file](https://github.com/romainmartinez/motion/blob/master/tests/data/inverse_dyn.sto), type: ```python from motion import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs.from_sto(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"shoulder_plane_moment\", \"shoulder_ele_moment\"] analogs = Analogs.from_sto(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_sto(data_path, usecols=channels) ``` Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_sto_or_mot ( cls , filename , end_header , ** kwargs ) Analogs DataArray from a sto file To read this sto file , type: from motion import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs . from_sto ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"shoulder_plane_moment\" , \"shoulder_ele_moment\" ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined None **kwargs _empty Keyword arguments to be passed to from_csv {} Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates","title":"analogs"},{"location":"api/analogs/#analogspy","text":"","title":"analogs.py"},{"location":"api/analogs/#motion.analogs.Analogs","text":"","title":"Analogs"},{"location":"api/analogs/#motion.analogs.Analogs.__new__","text":"Show source code in motion/analogs.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , channels : Optional [ list ] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Analogs DataArray with `axis`, `channel` and `time_frame` dimensions To instantiate an `Analogs` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from motion import Analogs n_channels = 4 n_frames = 100 data = np.random.random(size=(n_channels, n_frames)) analogs = Analogs(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] analogs = Analogs(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) analogs = Analogs(data, channels=names, time_frames=time_frames) ``` Calling `Analogs()` generate an empty array. Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 )) if channels is not None : coords [ \"channel\" ] = channels if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"channel\" , \"time_frame\" ), coords = coords , name = \"analogs\" , * args , ** kwargs , ) Analogs DataArray with axis , channel and time_frame dimensions To instantiate an Analogs with 4 channels and 100 frames filled with some random data: import numpy as np from motion import Analogs n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_channels , n_frames )) analogs = Analogs ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] analogs = Analogs ( data , channels = names ) And an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) analogs = Analogs ( data , channels = names , time_frames = time_frames ) Calling Analogs() generate an empty array. Parameters Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None *args _empty Positional argument(s) to be passed to xarray.DataArray () **kwargs _empty Keyword argument(s) to be passed to xarray.DataArray {} Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates","title":"__new__()"},{"location":"api/analogs/#motion.analogs.Analogs.from_c3d","text":"Show source code in motion/analogs.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a c3d file To read [this c3d file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers_analogs.c3d), type: ```python from motion import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Voltage.1\", \"Voltage.2\", \"Voltage.3\"] analogs = Analogs.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Voltage.1\"` and you specify `suffix_delimiter=\".\"`, you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": ```python channels = [\"1\", \"2\", \"3\"] analogs = Analogs.from_c3d(data_path, usecols=channels, prefix_delimiter=\".\") ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs ) Analogs DataArray from a c3d file To read this c3d file , type: from motion import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Voltage.1\" , \"Voltage.2\" , \"Voltage.3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Voltage.1\" and you specify suffix_delimiter=\".\" , you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": channels = [ \"1\" , \"2\" , \"3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels , prefix_delimiter = \".\" ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates","title":"from_c3d()"},{"location":"api/analogs/#motion.analogs.Analogs.from_csv","text":"Show source code in motion/analogs.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a csv file To read [this csv file](https://github.com/romainmartinez/motion/blob/master/tests/data/analogs.csv), type: ```python from motion import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs.from_csv(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"IM EMG1\", \"IM EMG2\", \"IM EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"IM EMG1\"` and you specify `suffix_delimiter=\" \"`, you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": ```python channels = [\"EMG1\", \"EMG2\", \"EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels, suffix_delimiter=\" \", ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_csv(data_path, header=3, first_row=5, first_column=1, time_column=0) ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , ) Analogs DataArray from a csv file To read this csv file , type: from motion import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"IM EMG1\" , \"IM EMG2\" , \"IM EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"IM EMG1\" and you specify suffix_delimiter=\" \" , you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": channels = [ \"EMG1\" , \"EMG2\" , \"EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels , suffix_delimiter = \" \" , ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates","title":"from_csv()"},{"location":"api/analogs/#motion.analogs.Analogs.from_excel","text":"Show source code in motion/analogs.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a excel file To read [this excel file](https://github.com/romainmartinez/motion/blob/master/tests/data/analogs.xlsx), type: ```python from motion import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs.from_excel(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"A\"] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_excel(data_path, header=3, first_row=5, first_column=1, time_column=0) ``` Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , sheet_name , ) Analogs DataArray from a excel file To read this excel file , type: from motion import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"A\" ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates","title":"from_excel()"},{"location":"api/analogs/#motion.analogs.Analogs.from_mot","text":"Show source code in motion/analogs.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 @classmethod def from_mot ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a mot file To read [this mot file](https://github.com/romainmartinez/motion/blob/master/tests/data/inverse_kin.mot), type: ```python from motion import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs.from_mot(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"elbow_flexion\", \"pro_sup\"] analogs = Analogs.from_mot(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_mot(data_path, usecols=channels) ``` Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined. kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_sto_or_mot ( cls , filename , end_header , ** kwargs ) Analogs DataArray from a mot file To read this mot file , type: from motion import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs . from_mot ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"elbow_flexion\" , \"pro_sup\" ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined. None **kwargs _empty Keyword arguments to be passed to from_csv {} Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates","title":"from_mot()"},{"location":"api/analogs/#motion.analogs.Analogs.from_random_data","text":"Show source code in motion/analogs.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate an `Analogs` with some random data sampled from a normal distribution: ```python from motion import Analogs n_channels = 10 n_frames = 100 size = n_channels, n_frames analogs = Analogs.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python analogs = Analogs.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random Analogs `xarray.DataArray` sampled from a given distribution \"\"\" return Analogs ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate an Analogs with some random data sampled from a normal distribution: from motion import Analogs n_channels = 10 n_frames = 100 size = n_channels , n_frames analogs = Analogs . from_random_data ( size = size ) You can choose any distribution available in numpy.random : analogs = Analogs . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (10, 100) *args _empty Positional argument(s) to be passed to numpy.random. distribution () **kwargs _empty Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random Analogs xarray.DataArray sampled from a given distribution","title":"from_random_data()"},{"location":"api/analogs/#motion.analogs.Analogs.from_sto","text":"Show source code in motion/analogs.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 @classmethod def from_sto ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a sto file To read [this sto file](https://github.com/romainmartinez/motion/blob/master/tests/data/inverse_dyn.sto), type: ```python from motion import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs.from_sto(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"shoulder_plane_moment\", \"shoulder_ele_moment\"] analogs = Analogs.from_sto(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_sto(data_path, usecols=channels) ``` Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates \"\"\" return read_sto_or_mot ( cls , filename , end_header , ** kwargs ) Analogs DataArray from a sto file To read this sto file , type: from motion import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs . from_sto ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"shoulder_plane_moment\" , \"shoulder_ele_moment\" ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined None **kwargs _empty Keyword arguments to be passed to from_csv {} Returns Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates","title":"from_sto()"},{"location":"api/angles/","text":"angles.py \u00b6 Angles \u00b6 __new__ ( cls , data = None , time_frames = None , * args , ** kwargs ) (staticmethod) \u00b6 Show source code in motion/angles.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Angles DataArray with `row`, `col` and `time_frame` dimensions To instantiate an `Angles` 4 by 4 and 100 frames filled with some random data: ```python import numpy as np from motion import Angles n_row = 4 n_col = 4 n_frames = 100 data = np.random.random(size=(n_row, n_col, n_frames)) angles = Angles(data) ``` You can an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) angles = Angles(data, time_frames=time_frames) ``` Calling `Angles()` generate an empty array. Arguments: data: Array to be passed to xarray.DataArray time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Angles `xarray.DataArray` with the specified data and coordinates \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"row\" , \"col\" , \"time_frame\" ), coords = coords , name = \"angles\" , * args , ** kwargs , ) Angles DataArray with row , col and time_frame dimensions To instantiate an Angles 4 by 4 and 100 frames filled with some random data: import numpy as np from motion import Angles n_row = 4 n_col = 4 n_frames = 100 data = np . random . random ( size = ( n_row , n_col , n_frames )) angles = Angles ( data ) You can an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) angles = Angles ( data , time_frames = time_frames ) Calling Angles() generate an empty array. Parameters Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None *args _empty Positional argument(s) to be passed to xarray.DataArray () **kwargs _empty Keyword argument(s) to be passed to xarray.DataArray {} Returns Type Description DataArray Angles xarray.DataArray with the specified data and coordinates from_random_data ( distribution = 'normal' , size = ( 10 , 10 , 100 ), * args , ** kwargs ) (classmethod) \u00b6 Show source code in motion/angles.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 10 , 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate an `Angles` with some random data sampled from a normal distribution: ```python from motion import Angles n_frames = 100 size = 10, 10, n_frames angles = Angles.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python angles = Angles.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random angles `xarray.DataArray` sampled from a given distribution \"\"\" return Angles ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate an Angles with some random data sampled from a normal distribution: from motion import Angles n_frames = 100 size = 10 , 10 , n_frames angles = Angles . from_random_data ( size = size ) You can choose any distribution available in numpy.random : angles = Angles . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (10, 10, 100) *args _empty Positional argument(s) to be passed to numpy.random. distribution () **kwargs _empty Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random angles xarray.DataArray sampled from a given distribution from_rototrans ( rototrans , angle_sequence ) (classmethod) \u00b6 Show source code in motion/angles.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 @classmethod def from_rototrans ( cls , rototrans : xr . DataArray , angle_sequence : str ) -> xr . DataArray : \"\"\" Angles DataArray from a rototranslation matrix and specified angle sequence To get the euler angles from a random rototranslation matrix with a given angle sequence type: ```python from motion import Angles, Rototrans size = (4, 4, 100) rt = Rototrans.from_random_data(size=size) angles_sequence = \"xyz\" angles = Angles.from_rototrans(rototrans=rt, angle_sequence=angles_sequence) ``` Arguments: rototrans: Rototranslation matrix created with motion.Rototrans() angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" Returns: Angles `xarray.DataArray` from the specified rototrans and angles sequence \"\"\" return angles_from_rototrans ( cls , rototrans , angle_sequence ) Angles DataArray from a rototranslation matrix and specified angle sequence To get the euler angles from a random rototranslation matrix with a given angle sequence type: from motion import Angles , Rototrans size = ( 4 , 4 , 100 ) rt = Rototrans . from_random_data ( size = size ) angles_sequence = \"xyz\" angles = Angles . from_rototrans ( rototrans = rt , angle_sequence = angles_sequence ) Parameters Name Type Description Default rototrans DataArray Rototranslation matrix created with motion.Rototrans() required angle_sequence str Euler sequence of angles. Valid values are all permutations of \"xyz\" required Returns Type Description DataArray Angles xarray.DataArray from the specified rototrans and angles sequence","title":"angles"},{"location":"api/angles/#anglespy","text":"","title":"angles.py"},{"location":"api/angles/#motion.angles.Angles","text":"","title":"Angles"},{"location":"api/angles/#motion.angles.Angles.__new__","text":"Show source code in motion/angles.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Angles DataArray with `row`, `col` and `time_frame` dimensions To instantiate an `Angles` 4 by 4 and 100 frames filled with some random data: ```python import numpy as np from motion import Angles n_row = 4 n_col = 4 n_frames = 100 data = np.random.random(size=(n_row, n_col, n_frames)) angles = Angles(data) ``` You can an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) angles = Angles(data, time_frames=time_frames) ``` Calling `Angles()` generate an empty array. Arguments: data: Array to be passed to xarray.DataArray time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Angles `xarray.DataArray` with the specified data and coordinates \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"row\" , \"col\" , \"time_frame\" ), coords = coords , name = \"angles\" , * args , ** kwargs , ) Angles DataArray with row , col and time_frame dimensions To instantiate an Angles 4 by 4 and 100 frames filled with some random data: import numpy as np from motion import Angles n_row = 4 n_col = 4 n_frames = 100 data = np . random . random ( size = ( n_row , n_col , n_frames )) angles = Angles ( data ) You can an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) angles = Angles ( data , time_frames = time_frames ) Calling Angles() generate an empty array. Parameters Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None *args _empty Positional argument(s) to be passed to xarray.DataArray () **kwargs _empty Keyword argument(s) to be passed to xarray.DataArray {} Returns Type Description DataArray Angles xarray.DataArray with the specified data and coordinates","title":"__new__()"},{"location":"api/angles/#motion.angles.Angles.from_random_data","text":"Show source code in motion/angles.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 10 , 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate an `Angles` with some random data sampled from a normal distribution: ```python from motion import Angles n_frames = 100 size = 10, 10, n_frames angles = Angles.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python angles = Angles.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random angles `xarray.DataArray` sampled from a given distribution \"\"\" return Angles ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate an Angles with some random data sampled from a normal distribution: from motion import Angles n_frames = 100 size = 10 , 10 , n_frames angles = Angles . from_random_data ( size = size ) You can choose any distribution available in numpy.random : angles = Angles . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (10, 10, 100) *args _empty Positional argument(s) to be passed to numpy.random. distribution () **kwargs _empty Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random angles xarray.DataArray sampled from a given distribution","title":"from_random_data()"},{"location":"api/angles/#motion.angles.Angles.from_rototrans","text":"Show source code in motion/angles.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 @classmethod def from_rototrans ( cls , rototrans : xr . DataArray , angle_sequence : str ) -> xr . DataArray : \"\"\" Angles DataArray from a rototranslation matrix and specified angle sequence To get the euler angles from a random rototranslation matrix with a given angle sequence type: ```python from motion import Angles, Rototrans size = (4, 4, 100) rt = Rototrans.from_random_data(size=size) angles_sequence = \"xyz\" angles = Angles.from_rototrans(rototrans=rt, angle_sequence=angles_sequence) ``` Arguments: rototrans: Rototranslation matrix created with motion.Rototrans() angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" Returns: Angles `xarray.DataArray` from the specified rototrans and angles sequence \"\"\" return angles_from_rototrans ( cls , rototrans , angle_sequence ) Angles DataArray from a rototranslation matrix and specified angle sequence To get the euler angles from a random rototranslation matrix with a given angle sequence type: from motion import Angles , Rototrans size = ( 4 , 4 , 100 ) rt = Rototrans . from_random_data ( size = size ) angles_sequence = \"xyz\" angles = Angles . from_rototrans ( rototrans = rt , angle_sequence = angles_sequence ) Parameters Name Type Description Default rototrans DataArray Rototranslation matrix created with motion.Rototrans() required angle_sequence str Euler sequence of angles. Valid values are all permutations of \"xyz\" required Returns Type Description DataArray Angles xarray.DataArray from the specified rototrans and angles sequence","title":"from_rototrans()"},{"location":"api/dataarray_accessor/","text":"dataarray_accessor.py \u00b6 MecaDataArrayAccessor \u00b6 abs ( self ) \u00b6 Show source code in motion/dataarray_accessor.py 56 57 58 59 60 61 62 63 64 65 def abs ( self ) -> xr . DataArray : \"\"\" Calculate the absolute value element-wise TODO: example with code Returns: A `xarray.DataArray` containing the absolute of each element \"\"\" return algebra . abs_ ( self . _obj ) Calculate the absolute value element-wise TODO: example with code Returns Type Description DataArray A xarray.DataArray containing the absolute of each element band_pass ( self , freq , order , cutoff ) \u00b6 Show source code in motion/dataarray_accessor.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def band_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ list , tuple , np . array ] ) -> xr . DataArray : \"\"\" Band-pass Butterworth filter. todo: example Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) Returns: A band-pass filtered `xarray.DataArray` \"\"\" return filter . band_pass ( self . _obj , freq , order , cutoff ) Band-pass Butterworth filter. todo: example Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required Returns Type Description DataArray A band-pass filtered xarray.DataArray band_stop ( self , freq , order , cutoff ) \u00b6 Show source code in motion/dataarray_accessor.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 def band_stop ( self , freq : Union [ int , float ], order : int , cutoff : Union [ list , tuple , np . array ] ) -> xr . DataArray : \"\"\" Band-stop Butterworth filter. todo: example Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) Returns: A band-stop filtered `xarray.DataArray` \"\"\" return filter . band_stop ( self . _obj , freq , order , cutoff ) Band-stop Butterworth filter. todo: example Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required Returns Type Description DataArray A band-stop filtered xarray.DataArray center ( self , mu = None ) \u00b6 Show source code in motion/dataarray_accessor.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def center ( self , mu : Union [ xr . DataArray , np . array , float , int ] = None ) -> xr . DataArray : \"\"\" Center an array (i.e., subtract the mean). TODO: example with code Arguments: mu: mean of the signal to subtract. If not provided, takes the mean along the time_frame axis Returns: a `xarray.DataArray` containing the root-mean-square of the matrix \"\"\" return algebra . center ( self . _obj , mu ) Center an array (i.e., subtract the mean). TODO: example with code Parameters Name Type Description Default mu Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] mean of the signal to subtract. If not provided, takes the mean along the time_frame axis None Returns Type Description DataArray a xarray.DataArray containing the root-mean-square of the matrix detect_onset ( self , threshold , n_above = 1 , n_below = 0 , threshold2 = None , n_above2 = 1 ) \u00b6 Show source code in motion/dataarray_accessor.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def detect_onset ( self , threshold : Union [ float , int ], n_above : int = 1 , n_below : int = 0 , threshold2 : int = None , n_above2 : int = 1 , ) -> np . array : \"\"\" Detects onset based on amplitude threshold todo: example Arguments: threshold: minimum amplitude to detect n_above: minimum number of continuous samples >= `threshold` to detect n_below: minimum number of continuous samples below `threshold` that will be ignored in the detection of `x` >= `threshold` threshold2: minimum amplitude of `n_above2` values in `x` to detect n_above2: minimum number of samples >= `threshold2` to detect Note: You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns: inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events \"\"\" return misc . detect_onset ( self . _obj , threshold , n_above , n_below , threshold2 , n_above2 ) Detects onset based on amplitude threshold todo: example Parameters Name Type Description Default threshold Union[float, int] minimum amplitude to detect required n_above int minimum number of continuous samples >= threshold to detect 1 n_below int minimum number of continuous samples below threshold that will be ignored in the detection of x >= threshold 0 threshold2 int minimum amplitude of n_above2 values in x to detect None n_above2 int minimum number of samples >= threshold2 to detect 1 Note You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns Type Description <built-in function array> inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events detect_outliers ( self , threshold = 3 ) \u00b6 Show source code in motion/dataarray_accessor.py 320 321 322 323 324 325 326 327 328 329 330 331 332 def detect_outliers ( self , threshold : int = 3 ) -> xr . DataArray : \"\"\" Detects data points that are `threshold` times the standard deviation from the mean. todo: example Arguments: threshold: Multiple of standard deviation from which data is considered outlier Returns: A boolean `xarray.DataArray` containing the outliers \"\"\" return misc . detect_outliers ( self . _obj , threshold ) Detects data points that are threshold times the standard deviation from the mean. todo: example Parameters Name Type Description Default threshold int Multiple of standard deviation from which data is considered outlier 3 Returns Type Description DataArray A boolean xarray.DataArray containing the outliers fft ( self , freq , only_positive = True ) \u00b6 Show source code in motion/dataarray_accessor.py 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def fft ( self , freq : Union [ int , float ], only_positive : bool = True ) -> xr . DataArray : \"\"\" Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. todo: example Arguments: freq: Sampling frequency (usually in array.attrs['rate']) only_positive: Returns only the positives frequencies if true Returns: A `xarray.DataArray` with the corresponding amplitudes and frequencies \"\"\" return misc . fft ( self . _obj , freq , only_positive ) Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. todo: example Parameters Name Type Description Default freq Union[int, float] Sampling frequency (usually in array.attrs['rate']) required only_positive bool Returns only the positives frequencies if true True Returns: A xarray.DataArray with the corresponding amplitudes and frequencies high_pass ( self , freq , order , cutoff ) \u00b6 Show source code in motion/dataarray_accessor.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def high_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ int , float , np . array ] ) -> xr . DataArray : \"\"\" High-pass Butterworth filter. todo: example Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency Returns: A high-pass filtered `xarray.DataArray` \"\"\" return filter . high_pass ( self . _obj , freq , order , cutoff ) High-pass Butterworth filter. todo: example Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required Returns Type Description DataArray A high-pass filtered xarray.DataArray low_pass ( self , freq , order , cutoff ) \u00b6 Show source code in motion/dataarray_accessor.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def low_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ int , float , np . array ] ) -> xr . DataArray : \"\"\" Low-pass Butterworth filter. todo: example Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency Returns: A low-pass filtered `xarray.DataArray` \"\"\" return filter . low_pass ( self . _obj , freq , order , cutoff ) Low-pass Butterworth filter. todo: example Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required Returns Type Description DataArray A low-pass filtered xarray.DataArray matmul ( self , other ) \u00b6 Show source code in motion/dataarray_accessor.py 67 68 69 70 71 72 73 74 75 76 77 78 79 def matmul ( self , other : xr . DataArray ) -> xr . DataArray : \"\"\" Matrix product of two arrays TODO: example with code Arguments: other: second array to multiply Returns: A `xarray.DataArray` containing the matrix product of the two arrays \"\"\" return algebra . matmul ( self . _obj , other ) Matrix product of two arrays TODO: example with code Parameters Name Type Description Default other DataArray second array to multiply required Returns Type Description DataArray A xarray.DataArray containing the matrix product of the two arrays norm ( self , dim , ord = None ) \u00b6 Show source code in motion/dataarray_accessor.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def norm ( self , dim : Union [ str , list ], ord : int = None ) -> xr . DataArray : \"\"\" Return the norm of an array. TODO: example with code Arguments: dim: Name(s) of the data dimension(s) ord: Order of the norm Returns: A `xarray.DataArray` containing the norm of the matrix. \"\"\" return algebra . norm ( self . _obj , dim , ord ) Return the norm of an array. TODO: example with code Parameters Name Type Description Default dim Union[str, list] Name(s) of the data dimension(s) required ord int Order of the norm None Returns Type Description DataArray A xarray.DataArray containing the norm of the matrix. normalize ( self , ref = None , scale = 100 ) \u00b6 Show source code in motion/dataarray_accessor.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def normalize ( self , ref : Union [ xr . DataArray , np . array , float , int ] = None , scale : Union [ int , float ] = 100 , ) -> xr . DataArray : \"\"\" Normalize a signal against `ref` on a scale of `scale`. TODO: example with code Arguments: ref: Reference value. Could have multiple dimensions. If not provided, takes the mean along the time_frame axis scale: Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) Returns: A `xarray.DataArray` containing the normalized signal \"\"\" return algebra . normalize ( self . _obj , ref , scale ) Normalize a signal against ref on a scale of scale . TODO: example with code Parameters Name Type Description Default ref Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] Reference value. Could have multiple dimensions. If not provided, takes the mean along the time_frame axis None scale Union[int, float] Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) 100 Returns Type Description DataArray A xarray.DataArray containing the normalized signal rms ( self ) \u00b6 Show source code in motion/dataarray_accessor.py 130 131 132 133 134 135 136 137 138 139 def rms ( self ) -> xr . DataArray : \"\"\" Return the root-mean-square of an array. TODO: example with code Returns: A `xarray.DataArray` containing the root-mean-square of the matrix. \"\"\" return algebra . rms ( self . _obj ) Return the root-mean-square of an array. TODO: example with code Returns Type Description DataArray A xarray.DataArray containing the root-mean-square of the matrix. sqrt ( self , * args , ** kwargs ) \u00b6 Show source code in motion/dataarray_accessor.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def sqrt ( self , * args , ** kwargs ) -> xr . DataArray : \"\"\" Return the non-negative square-root of an array, element-wise. TODO: example with code Arguments: args: For other positional arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) Returns: A `xarray.DataArray` containing the square root of the matrix. \"\"\" return algebra . sqrt ( self . _obj , * args , ** kwargs ) Return the non-negative square-root of an array, element-wise. TODO: example with code Parameters Name Type Description Default *args _empty For other positional arguments, see the numpy docs () **kwargs _empty For other keyword-only arguments, see the numpy docs {} Returns Type Description DataArray A xarray.DataArray containing the square root of the matrix. square ( self , * args , ** kwargs ) \u00b6 Show source code in motion/dataarray_accessor.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def square ( self , * args , ** kwargs ) -> xr . DataArray : \"\"\" Return the element-wise square of the input TODO: example with code Arguments: args: For other positional arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) Returns: A `xarray.DataArray` containing the matrix squared. \"\"\" return algebra . square ( self . _obj , * args , ** kwargs ) Return the element-wise square of the input TODO: example with code Parameters Name Type Description Default *args _empty For other positional arguments, see the numpy docs () **kwargs _empty For other keyword-only arguments, see the numpy docs {} Returns Type Description DataArray A xarray.DataArray containing the matrix squared. time_normalize ( self , time_vector = None , n_frames = 100 , norm_time_frame = False ) \u00b6 Show source code in motion/dataarray_accessor.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def time_normalize ( self , time_vector : Union [ xr . DataArray , np . array ] = None , n_frames : int = 100 , norm_time_frame : bool = False , ) -> xr . DataArray : \"\"\" Time normalization used for temporal alignment of data TODO: example with code Arguments: time_vector: desired time vector (first to last time_frame with n_frames points by default) n_frames: if time_vector is not specified, the length of the desired time vector norm_time_frame: Normalize the time_frame dimension from 0 to 100 if True Returns: A time-normalized `xarray.DataArray` \"\"\" return interp . time_normalize ( self . _obj , time_vector , n_frames , norm_time_frame = norm_time_frame ) Time normalization used for temporal alignment of data TODO: example with code Parameters Name Type Description Default time_vector Union[xarray.core.dataarray.DataArray, <built-in function array>] desired time vector (first to last time_frame with n_frames points by default) None n_frames int if time_vector is not specified, the length of the desired time vector 100 norm_time_frame bool Normalize the time_frame dimension from 0 to 100 if True False Returns Type Description DataArray A time-normalized xarray.DataArray to_csv ( self , filename , wide = True ) \u00b6 Show source code in motion/dataarray_accessor.py 29 30 31 32 33 34 35 36 37 38 39 def to_csv ( self , filename : Union [ str , Path ], wide : Optional [ bool ] = True ): \"\"\" Write a csv file from a xarray.DataArray TODO: example with code Arguments: filename: File path wide: True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. \"\"\" write_csv ( self . _obj , filename , wide ) Write a csv file from a xarray.DataArray TODO: example with code Parameters Name Type Description Default filename Union[str, pathlib.Path] File path required wide Optional[bool] True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. True to_matlab ( self , filename ) \u00b6 Show source code in motion/dataarray_accessor.py 18 19 20 21 22 23 24 25 26 27 def to_matlab ( self , filename : Union [ str , Path ]): \"\"\" Write a matlab file from a xarray.DataArray TODO: example with code Arguments: filename: File path \"\"\" write_matlab ( self . _obj , filename ) Write a matlab file from a xarray.DataArray TODO: example with code Parameters Name Type Description Default filename Union[str, pathlib.Path] File path required to_wide_dataframe ( self ) \u00b6 Show source code in motion/dataarray_accessor.py 41 42 43 44 45 46 47 48 49 50 51 52 def to_wide_dataframe ( self ) -> pd . DataFrame : \"\"\" Return a wide xarray.DataArray (one column by channel) TODO: example with code Returns: A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: `array.to_series()`, or `array.to_dataframe()`. \"\"\" return to_wide_dataframe ( self . _obj ) Return a wide xarray.DataArray (one column by channel) TODO: example with code Returns Type Description DataFrame A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: array.to_series() , or array.to_dataframe() .","title":"dataarray_accessor"},{"location":"api/dataarray_accessor/#dataarray_accessorpy","text":"","title":"dataarray_accessor.py"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor","text":"","title":"MecaDataArrayAccessor"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.abs","text":"Show source code in motion/dataarray_accessor.py 56 57 58 59 60 61 62 63 64 65 def abs ( self ) -> xr . DataArray : \"\"\" Calculate the absolute value element-wise TODO: example with code Returns: A `xarray.DataArray` containing the absolute of each element \"\"\" return algebra . abs_ ( self . _obj ) Calculate the absolute value element-wise TODO: example with code Returns Type Description DataArray A xarray.DataArray containing the absolute of each element","title":"abs()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.band_pass","text":"Show source code in motion/dataarray_accessor.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def band_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ list , tuple , np . array ] ) -> xr . DataArray : \"\"\" Band-pass Butterworth filter. todo: example Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) Returns: A band-pass filtered `xarray.DataArray` \"\"\" return filter . band_pass ( self . _obj , freq , order , cutoff ) Band-pass Butterworth filter. todo: example Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required Returns Type Description DataArray A band-pass filtered xarray.DataArray","title":"band_pass()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.band_stop","text":"Show source code in motion/dataarray_accessor.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 def band_stop ( self , freq : Union [ int , float ], order : int , cutoff : Union [ list , tuple , np . array ] ) -> xr . DataArray : \"\"\" Band-stop Butterworth filter. todo: example Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) Returns: A band-stop filtered `xarray.DataArray` \"\"\" return filter . band_stop ( self . _obj , freq , order , cutoff ) Band-stop Butterworth filter. todo: example Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required Returns Type Description DataArray A band-stop filtered xarray.DataArray","title":"band_stop()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.center","text":"Show source code in motion/dataarray_accessor.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def center ( self , mu : Union [ xr . DataArray , np . array , float , int ] = None ) -> xr . DataArray : \"\"\" Center an array (i.e., subtract the mean). TODO: example with code Arguments: mu: mean of the signal to subtract. If not provided, takes the mean along the time_frame axis Returns: a `xarray.DataArray` containing the root-mean-square of the matrix \"\"\" return algebra . center ( self . _obj , mu ) Center an array (i.e., subtract the mean). TODO: example with code Parameters Name Type Description Default mu Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] mean of the signal to subtract. If not provided, takes the mean along the time_frame axis None Returns Type Description DataArray a xarray.DataArray containing the root-mean-square of the matrix","title":"center()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.detect_onset","text":"Show source code in motion/dataarray_accessor.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def detect_onset ( self , threshold : Union [ float , int ], n_above : int = 1 , n_below : int = 0 , threshold2 : int = None , n_above2 : int = 1 , ) -> np . array : \"\"\" Detects onset based on amplitude threshold todo: example Arguments: threshold: minimum amplitude to detect n_above: minimum number of continuous samples >= `threshold` to detect n_below: minimum number of continuous samples below `threshold` that will be ignored in the detection of `x` >= `threshold` threshold2: minimum amplitude of `n_above2` values in `x` to detect n_above2: minimum number of samples >= `threshold2` to detect Note: You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns: inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events \"\"\" return misc . detect_onset ( self . _obj , threshold , n_above , n_below , threshold2 , n_above2 ) Detects onset based on amplitude threshold todo: example Parameters Name Type Description Default threshold Union[float, int] minimum amplitude to detect required n_above int minimum number of continuous samples >= threshold to detect 1 n_below int minimum number of continuous samples below threshold that will be ignored in the detection of x >= threshold 0 threshold2 int minimum amplitude of n_above2 values in x to detect None n_above2 int minimum number of samples >= threshold2 to detect 1 Note You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns Type Description <built-in function array> inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events","title":"detect_onset()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.detect_outliers","text":"Show source code in motion/dataarray_accessor.py 320 321 322 323 324 325 326 327 328 329 330 331 332 def detect_outliers ( self , threshold : int = 3 ) -> xr . DataArray : \"\"\" Detects data points that are `threshold` times the standard deviation from the mean. todo: example Arguments: threshold: Multiple of standard deviation from which data is considered outlier Returns: A boolean `xarray.DataArray` containing the outliers \"\"\" return misc . detect_outliers ( self . _obj , threshold ) Detects data points that are threshold times the standard deviation from the mean. todo: example Parameters Name Type Description Default threshold int Multiple of standard deviation from which data is considered outlier 3 Returns Type Description DataArray A boolean xarray.DataArray containing the outliers","title":"detect_outliers()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.fft","text":"Show source code in motion/dataarray_accessor.py 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def fft ( self , freq : Union [ int , float ], only_positive : bool = True ) -> xr . DataArray : \"\"\" Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. todo: example Arguments: freq: Sampling frequency (usually in array.attrs['rate']) only_positive: Returns only the positives frequencies if true Returns: A `xarray.DataArray` with the corresponding amplitudes and frequencies \"\"\" return misc . fft ( self . _obj , freq , only_positive ) Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. todo: example Parameters Name Type Description Default freq Union[int, float] Sampling frequency (usually in array.attrs['rate']) required only_positive bool Returns only the positives frequencies if true True Returns: A xarray.DataArray with the corresponding amplitudes and frequencies","title":"fft()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.high_pass","text":"Show source code in motion/dataarray_accessor.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def high_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ int , float , np . array ] ) -> xr . DataArray : \"\"\" High-pass Butterworth filter. todo: example Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency Returns: A high-pass filtered `xarray.DataArray` \"\"\" return filter . high_pass ( self . _obj , freq , order , cutoff ) High-pass Butterworth filter. todo: example Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required Returns Type Description DataArray A high-pass filtered xarray.DataArray","title":"high_pass()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.low_pass","text":"Show source code in motion/dataarray_accessor.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def low_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ int , float , np . array ] ) -> xr . DataArray : \"\"\" Low-pass Butterworth filter. todo: example Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency Returns: A low-pass filtered `xarray.DataArray` \"\"\" return filter . low_pass ( self . _obj , freq , order , cutoff ) Low-pass Butterworth filter. todo: example Parameters Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required Returns Type Description DataArray A low-pass filtered xarray.DataArray","title":"low_pass()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.matmul","text":"Show source code in motion/dataarray_accessor.py 67 68 69 70 71 72 73 74 75 76 77 78 79 def matmul ( self , other : xr . DataArray ) -> xr . DataArray : \"\"\" Matrix product of two arrays TODO: example with code Arguments: other: second array to multiply Returns: A `xarray.DataArray` containing the matrix product of the two arrays \"\"\" return algebra . matmul ( self . _obj , other ) Matrix product of two arrays TODO: example with code Parameters Name Type Description Default other DataArray second array to multiply required Returns Type Description DataArray A xarray.DataArray containing the matrix product of the two arrays","title":"matmul()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.norm","text":"Show source code in motion/dataarray_accessor.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def norm ( self , dim : Union [ str , list ], ord : int = None ) -> xr . DataArray : \"\"\" Return the norm of an array. TODO: example with code Arguments: dim: Name(s) of the data dimension(s) ord: Order of the norm Returns: A `xarray.DataArray` containing the norm of the matrix. \"\"\" return algebra . norm ( self . _obj , dim , ord ) Return the norm of an array. TODO: example with code Parameters Name Type Description Default dim Union[str, list] Name(s) of the data dimension(s) required ord int Order of the norm None Returns Type Description DataArray A xarray.DataArray containing the norm of the matrix.","title":"norm()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.normalize","text":"Show source code in motion/dataarray_accessor.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def normalize ( self , ref : Union [ xr . DataArray , np . array , float , int ] = None , scale : Union [ int , float ] = 100 , ) -> xr . DataArray : \"\"\" Normalize a signal against `ref` on a scale of `scale`. TODO: example with code Arguments: ref: Reference value. Could have multiple dimensions. If not provided, takes the mean along the time_frame axis scale: Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) Returns: A `xarray.DataArray` containing the normalized signal \"\"\" return algebra . normalize ( self . _obj , ref , scale ) Normalize a signal against ref on a scale of scale . TODO: example with code Parameters Name Type Description Default ref Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] Reference value. Could have multiple dimensions. If not provided, takes the mean along the time_frame axis None scale Union[int, float] Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) 100 Returns Type Description DataArray A xarray.DataArray containing the normalized signal","title":"normalize()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.rms","text":"Show source code in motion/dataarray_accessor.py 130 131 132 133 134 135 136 137 138 139 def rms ( self ) -> xr . DataArray : \"\"\" Return the root-mean-square of an array. TODO: example with code Returns: A `xarray.DataArray` containing the root-mean-square of the matrix. \"\"\" return algebra . rms ( self . _obj ) Return the root-mean-square of an array. TODO: example with code Returns Type Description DataArray A xarray.DataArray containing the root-mean-square of the matrix.","title":"rms()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.sqrt","text":"Show source code in motion/dataarray_accessor.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def sqrt ( self , * args , ** kwargs ) -> xr . DataArray : \"\"\" Return the non-negative square-root of an array, element-wise. TODO: example with code Arguments: args: For other positional arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) Returns: A `xarray.DataArray` containing the square root of the matrix. \"\"\" return algebra . sqrt ( self . _obj , * args , ** kwargs ) Return the non-negative square-root of an array, element-wise. TODO: example with code Parameters Name Type Description Default *args _empty For other positional arguments, see the numpy docs () **kwargs _empty For other keyword-only arguments, see the numpy docs {} Returns Type Description DataArray A xarray.DataArray containing the square root of the matrix.","title":"sqrt()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.square","text":"Show source code in motion/dataarray_accessor.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def square ( self , * args , ** kwargs ) -> xr . DataArray : \"\"\" Return the element-wise square of the input TODO: example with code Arguments: args: For other positional arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) Returns: A `xarray.DataArray` containing the matrix squared. \"\"\" return algebra . square ( self . _obj , * args , ** kwargs ) Return the element-wise square of the input TODO: example with code Parameters Name Type Description Default *args _empty For other positional arguments, see the numpy docs () **kwargs _empty For other keyword-only arguments, see the numpy docs {} Returns Type Description DataArray A xarray.DataArray containing the matrix squared.","title":"square()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.time_normalize","text":"Show source code in motion/dataarray_accessor.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def time_normalize ( self , time_vector : Union [ xr . DataArray , np . array ] = None , n_frames : int = 100 , norm_time_frame : bool = False , ) -> xr . DataArray : \"\"\" Time normalization used for temporal alignment of data TODO: example with code Arguments: time_vector: desired time vector (first to last time_frame with n_frames points by default) n_frames: if time_vector is not specified, the length of the desired time vector norm_time_frame: Normalize the time_frame dimension from 0 to 100 if True Returns: A time-normalized `xarray.DataArray` \"\"\" return interp . time_normalize ( self . _obj , time_vector , n_frames , norm_time_frame = norm_time_frame ) Time normalization used for temporal alignment of data TODO: example with code Parameters Name Type Description Default time_vector Union[xarray.core.dataarray.DataArray, <built-in function array>] desired time vector (first to last time_frame with n_frames points by default) None n_frames int if time_vector is not specified, the length of the desired time vector 100 norm_time_frame bool Normalize the time_frame dimension from 0 to 100 if True False Returns Type Description DataArray A time-normalized xarray.DataArray","title":"time_normalize()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.to_csv","text":"Show source code in motion/dataarray_accessor.py 29 30 31 32 33 34 35 36 37 38 39 def to_csv ( self , filename : Union [ str , Path ], wide : Optional [ bool ] = True ): \"\"\" Write a csv file from a xarray.DataArray TODO: example with code Arguments: filename: File path wide: True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. \"\"\" write_csv ( self . _obj , filename , wide ) Write a csv file from a xarray.DataArray TODO: example with code Parameters Name Type Description Default filename Union[str, pathlib.Path] File path required wide Optional[bool] True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. True","title":"to_csv()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.to_matlab","text":"Show source code in motion/dataarray_accessor.py 18 19 20 21 22 23 24 25 26 27 def to_matlab ( self , filename : Union [ str , Path ]): \"\"\" Write a matlab file from a xarray.DataArray TODO: example with code Arguments: filename: File path \"\"\" write_matlab ( self . _obj , filename ) Write a matlab file from a xarray.DataArray TODO: example with code Parameters Name Type Description Default filename Union[str, pathlib.Path] File path required","title":"to_matlab()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.MecaDataArrayAccessor.to_wide_dataframe","text":"Show source code in motion/dataarray_accessor.py 41 42 43 44 45 46 47 48 49 50 51 52 def to_wide_dataframe ( self ) -> pd . DataFrame : \"\"\" Return a wide xarray.DataArray (one column by channel) TODO: example with code Returns: A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: `array.to_series()`, or `array.to_dataframe()`. \"\"\" return to_wide_dataframe ( self . _obj ) Return a wide xarray.DataArray (one column by channel) TODO: example with code Returns Type Description DataFrame A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: array.to_series() , or array.to_dataframe() .","title":"to_wide_dataframe()"},{"location":"api/markers/","text":"markers.py \u00b6 Markers \u00b6 __new__ ( cls , data = None , channels = None , time_frames = None , * args , ** kwargs ) (staticmethod) \u00b6 Show source code in motion/markers.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , channels : Optional [ list ] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Markers DataArray with `axis`, `channel` and `time_frame` dimensions To instantiate a `Markers` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from motion import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np.random.random(size=(n_axis, n_channels, n_frames)) markers = Markers(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] markers = Markers(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) markers = Markers(data, channels=names, time_frames=time_frames) ``` Calling `Markers()` generate an empty array. Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) else : coords [ \"axis\" ] = [ \"x\" , \"y\" , \"z\" , \"ones\" ] if data . shape [ 0 ] == 3 : data = np . insert ( data , obj = 3 , values = 1 , axis = 0 ) if channels : coords [ \"channel\" ] = channels if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"axis\" , \"channel\" , \"time_frame\" ), coords = coords , name = \"markers\" , * args , ** kwargs , ) Markers DataArray with axis , channel and time_frame dimensions To instantiate a Markers with 4 channels and 100 frames filled with some random data: import numpy as np from motion import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_axis , n_channels , n_frames )) markers = Markers ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] markers = Markers ( data , channels = names ) And an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) markers = Markers ( data , channels = names , time_frames = time_frames ) Calling Markers() generate an empty array. Parameters Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None *args _empty Positional argument(s) to be passed to xarray.DataArray () **kwargs _empty Keyword argument(s) to be passed to xarray.DataArray {} Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates from_c3d ( filename , usecols = None , prefix_delimiter = None , suffix_delimiter = None , attrs = None ) (classmethod) \u00b6 Show source code in motion/markers.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a c3d file To read [this c3d file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers_analogs.c3d), type: ```python from motion import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Daphnee:ASISl\", \"Daphnee:PSISr\", \"Daphnee:PSISl\"] markers = Markers.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"\"Daphnee:ASISl\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISl\", \"PSISr\", \"PSISl\"] markers = Markers.from_c3d(data_path, prefix_delimiter=\":\") ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs ) Markers DataArray from a c3d file To read this c3d file , type: from motion import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Daphnee:ASISl\" , \"Daphnee:PSISr\" , \"Daphnee:PSISl\" ] markers = Markers . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"\"Daphnee:ASISl\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISl\" , \"PSISr\" , \"PSISl\" ] markers = Markers . from_c3d ( data_path , prefix_delimiter = \":\" ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates from_csv ( filename , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , last_column_to_remove = None , prefix_delimiter = None , suffix_delimiter = None , skiprows = None , pandas_kwargs = None , attrs = None ) (classmethod) \u00b6 Show source code in motion/markers.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a csv file To read [this csv file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.csv), type: ```python from motion import Markers data_path = \"./tests/data/markers.csv\" markers = Markers.from_csv(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"Daphnee:ASISr\", \"Daphnee:ASISl\", \"Daphnee:PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Daphnee:ASISr\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISr\", \"ASISl\", \"PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , ) Markers DataArray from a csv file To read this csv file , type: from motion import Markers data_path = \"./tests/data/markers.csv\" markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"Daphnee:ASISr\" , \"Daphnee:ASISl\" , \"Daphnee:PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Daphnee:ASISr\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISr\" , \"ASISl\" , \"PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates from_excel ( filename , sheet_name = 0 , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , last_column_to_remove = None , prefix_delimiter = None , suffix_delimiter = None , skiprows = None , pandas_kwargs = None , attrs = None ) (classmethod) \u00b6 Show source code in motion/markers.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a excel file To read [this excel file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.xlsx), type: ```python from motion import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers.from_excel(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"boite:gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"boite:gauche_ext\"` and you specify `suffix_delimiter=\":\"`, you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , sheet_name , ) Markers DataArray from a excel file To read this excel file , type: from motion import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"boite:gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"boite:gauche_ext\" and you specify suffix_delimiter=\":\" , you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates from_random_data ( distribution = 'normal' , size = ( 3 , 10 , 100 ), * args , ** kwargs ) (classmethod) \u00b6 Show source code in motion/markers.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate a `Markers` with some random data sampled from a normal distribution: ```python from motion import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis, n_channels, n_frames markers = Markers.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python markers = Markers.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random markers `xarray.DataArray` sampled from a given distribution \"\"\" return Markers ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate a Markers with some random data sampled from a normal distribution: from motion import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis , n_channels , n_frames markers = Markers . from_random_data ( size = size ) You can choose any distribution available in numpy.random : markers = Markers . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 10, 100) *args _empty Positional argument(s) to be passed to numpy.random. distribution () **kwargs _empty Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random markers xarray.DataArray sampled from a given distribution from_trc ( filename , ** kwargs ) (classmethod) \u00b6 Show source code in motion/markers.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 @classmethod def from_trc ( cls , filename : Union [ str , Path ], ** kwargs ) -> xr . DataArray : \"\"\" Markers DataArray from a trc file To read [this trc file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.trc), type: ```python from motion import Markers data_path = \"./tests/data/markers.trc\" markers = Markers.from_trc(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"STER\", \"STERl\"] markers = Markers.from_trc(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] markers = Markers.from_trc(data_path, usecols=channels) ``` Arguments: filename: Any valid string path kwargs: Keyword arguments to be passed to `from_csv` Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_trc ( cls , filename , ** kwargs ) Markers DataArray from a trc file To read this trc file , type: from motion import Markers data_path = \"./tests/data/markers.trc\" markers = Markers . from_trc ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"STER\" , \"STERl\" ] markers = Markers . from_trc ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] markers = Markers . from_trc ( data_path , usecols = channels ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required **kwargs _empty Keyword arguments to be passed to from_csv {} Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates","title":"markers"},{"location":"api/markers/#markerspy","text":"","title":"markers.py"},{"location":"api/markers/#motion.markers.Markers","text":"","title":"Markers"},{"location":"api/markers/#motion.markers.Markers.__new__","text":"Show source code in motion/markers.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , channels : Optional [ list ] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Markers DataArray with `axis`, `channel` and `time_frame` dimensions To instantiate a `Markers` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from motion import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np.random.random(size=(n_axis, n_channels, n_frames)) markers = Markers(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] markers = Markers(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) markers = Markers(data, channels=names, time_frames=time_frames) ``` Calling `Markers()` generate an empty array. Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) else : coords [ \"axis\" ] = [ \"x\" , \"y\" , \"z\" , \"ones\" ] if data . shape [ 0 ] == 3 : data = np . insert ( data , obj = 3 , values = 1 , axis = 0 ) if channels : coords [ \"channel\" ] = channels if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"axis\" , \"channel\" , \"time_frame\" ), coords = coords , name = \"markers\" , * args , ** kwargs , ) Markers DataArray with axis , channel and time_frame dimensions To instantiate a Markers with 4 channels and 100 frames filled with some random data: import numpy as np from motion import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_axis , n_channels , n_frames )) markers = Markers ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] markers = Markers ( data , channels = names ) And an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) markers = Markers ( data , channels = names , time_frames = time_frames ) Calling Markers() generate an empty array. Parameters Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None *args _empty Positional argument(s) to be passed to xarray.DataArray () **kwargs _empty Keyword argument(s) to be passed to xarray.DataArray {} Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates","title":"__new__()"},{"location":"api/markers/#motion.markers.Markers.from_c3d","text":"Show source code in motion/markers.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a c3d file To read [this c3d file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers_analogs.c3d), type: ```python from motion import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Daphnee:ASISl\", \"Daphnee:PSISr\", \"Daphnee:PSISl\"] markers = Markers.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"\"Daphnee:ASISl\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISl\", \"PSISr\", \"PSISl\"] markers = Markers.from_c3d(data_path, prefix_delimiter=\":\") ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs ) Markers DataArray from a c3d file To read this c3d file , type: from motion import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Daphnee:ASISl\" , \"Daphnee:PSISr\" , \"Daphnee:PSISl\" ] markers = Markers . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"\"Daphnee:ASISl\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISl\" , \"PSISr\" , \"PSISl\" ] markers = Markers . from_c3d ( data_path , prefix_delimiter = \":\" ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates","title":"from_c3d()"},{"location":"api/markers/#motion.markers.Markers.from_csv","text":"Show source code in motion/markers.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a csv file To read [this csv file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.csv), type: ```python from motion import Markers data_path = \"./tests/data/markers.csv\" markers = Markers.from_csv(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"Daphnee:ASISr\", \"Daphnee:ASISl\", \"Daphnee:PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Daphnee:ASISr\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISr\", \"ASISl\", \"PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , ) Markers DataArray from a csv file To read this csv file , type: from motion import Markers data_path = \"./tests/data/markers.csv\" markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"Daphnee:ASISr\" , \"Daphnee:ASISl\" , \"Daphnee:PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Daphnee:ASISr\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISr\" , \"ASISl\" , \"PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates","title":"from_csv()"},{"location":"api/markers/#motion.markers.Markers.from_excel","text":"Show source code in motion/markers.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a excel file To read [this excel file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.xlsx), type: ```python from motion import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers.from_excel(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"boite:gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"boite:gauche_ext\"` and you specify `suffix_delimiter=\":\"`, you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , sheet_name , ) Markers DataArray from a excel file To read this excel file , type: from motion import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"boite:gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"boite:gauche_ext\" and you specify suffix_delimiter=\":\" , you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates","title":"from_excel()"},{"location":"api/markers/#motion.markers.Markers.from_random_data","text":"Show source code in motion/markers.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate a `Markers` with some random data sampled from a normal distribution: ```python from motion import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis, n_channels, n_frames markers = Markers.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python markers = Markers.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random markers `xarray.DataArray` sampled from a given distribution \"\"\" return Markers ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate a Markers with some random data sampled from a normal distribution: from motion import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis , n_channels , n_frames markers = Markers . from_random_data ( size = size ) You can choose any distribution available in numpy.random : markers = Markers . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 10, 100) *args _empty Positional argument(s) to be passed to numpy.random. distribution () **kwargs _empty Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random markers xarray.DataArray sampled from a given distribution","title":"from_random_data()"},{"location":"api/markers/#motion.markers.Markers.from_trc","text":"Show source code in motion/markers.py 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 @classmethod def from_trc ( cls , filename : Union [ str , Path ], ** kwargs ) -> xr . DataArray : \"\"\" Markers DataArray from a trc file To read [this trc file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.trc), type: ```python from motion import Markers data_path = \"./tests/data/markers.trc\" markers = Markers.from_trc(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"STER\", \"STERl\"] markers = Markers.from_trc(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] markers = Markers.from_trc(data_path, usecols=channels) ``` Arguments: filename: Any valid string path kwargs: Keyword arguments to be passed to `from_csv` Returns: Markers `xarray.DataArray` with the specified data and coordinates \"\"\" return read_trc ( cls , filename , ** kwargs ) Markers DataArray from a trc file To read this trc file , type: from motion import Markers data_path = \"./tests/data/markers.trc\" markers = Markers . from_trc ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"STER\" , \"STERl\" ] markers = Markers . from_trc ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] markers = Markers . from_trc ( data_path , usecols = channels ) Parameters Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required **kwargs _empty Keyword arguments to be passed to from_csv {} Returns Type Description DataArray Markers xarray.DataArray with the specified data and coordinates","title":"from_trc()"},{"location":"api/rototrans/","text":"rototrans.py \u00b6 Rototrans \u00b6 __new__ ( cls , data = None , time_frames = None , * args , ** kwargs ) (staticmethod) \u00b6 Show source code in motion/rototrans.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Rototrans DataArray with `axis`, `channel` and `time_frame` dimensions To instantiate a `Rototrans` 4 by 4 and 100 frames filled with some random data: ```python import numpy as np from motion import Rototrans n_row = 4 n_col = 4 n_frames = 100 data = np.random.random(size=(n_row, n_col, n_frames)) rt = Rototrans(data) ``` You can an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) rt = Rototrans(data, time_frames=time_frames) ``` Calling `Rototrans()` generate an empty array. Arguments: data: Array to be passed to xarray.DataArray time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Rototrans `xarray.DataArray` with the specified data and coordinates \"\"\" coords = {} if data is None : data = np . eye ( 4 ) if data . shape [ 0 ] != 4 or data . shape [ 1 ] != 4 : raise IndexError ( f \"data must have first and second dimensions of length 4, you have: {data.shape} \" ) if data . ndim == 2 : data = data [ ... , np . newaxis ] if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"row\" , \"col\" , \"time_frame\" ), coords = coords , name = \"rototrans\" , * args , ** kwargs , ) Rototrans DataArray with axis , channel and time_frame dimensions To instantiate a Rototrans 4 by 4 and 100 frames filled with some random data: import numpy as np from motion import Rototrans n_row = 4 n_col = 4 n_frames = 100 data = np . random . random ( size = ( n_row , n_col , n_frames )) rt = Rototrans ( data ) You can an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) rt = Rototrans ( data , time_frames = time_frames ) Calling Rototrans() generate an empty array. Parameters Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None *args _empty Positional argument(s) to be passed to xarray.DataArray () **kwargs _empty Keyword argument(s) to be passed to xarray.DataArray {} Returns Type Description DataArray Rototrans xarray.DataArray with the specified data and coordinates from_euler_angles ( angles = None , angle_sequence = None , translations = None ) (classmethod) \u00b6 Show source code in motion/rototrans.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @classmethod def from_euler_angles ( cls , angles : Optional [ xr . DataArray ] = None , angle_sequence : Optional [ str ] = None , translations : Optional [ xr . DataArray ] = None , ) -> xr . DataArray : \"\"\" Rototrans DataArray from euler angles and specified angle sequence To get the rototranslation matrix from random euler angles with a given angle sequence type: ```python from motion import Angles, Rototrans size = (3, 1, 100) angles = Angles.from_random_data(size=size) angles_sequence = \"xyz\" rt = Rototrans.from_euler_angles(angles=angles, angle_sequence=angles_sequence) ``` A translation vector can also be specified: ```python translation = Angles.from_random_data(size=size) rt = Rototrans.from_euler_angles( angles=angles, angle_sequence=angles_sequence, translations=translation ) ``` Arguments: angles: Euler angles of the rototranslation matrix angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" translations: Translation part of the Rototrans matrix Returns: Rototrans `xarray.DataArray` from the specified angles and angles sequence \"\"\" return rototrans_from_euler_angles ( cls , angles , angle_sequence , translations ) Rototrans DataArray from euler angles and specified angle sequence To get the rototranslation matrix from random euler angles with a given angle sequence type: from motion import Angles , Rototrans size = ( 3 , 1 , 100 ) angles = Angles . from_random_data ( size = size ) angles_sequence = \"xyz\" rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence ) A translation vector can also be specified: translation = Angles . from_random_data ( size = size ) rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence , translations = translation ) Parameters Name Type Description Default angles Optional[xarray.core.dataarray.DataArray] Euler angles of the rototranslation matrix None angle_sequence Optional[str] Euler sequence of angles. Valid values are all permutations of \"xyz\" None translations Optional[xarray.core.dataarray.DataArray] Translation part of the Rototrans matrix None Returns Type Description DataArray Rototrans xarray.DataArray from the specified angles and angles sequence from_random_data ( distribution = 'normal' , size = ( 4 , 4 , 100 ), * args , ** kwargs ) (classmethod) \u00b6 Show source code in motion/rototrans.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 4 , 4 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate a `Rototrans` with some random data sampled from a normal distribution: ```python from motion import Rototrans n_frames = 100 size = 4, 4, n_frames rt = Rototrans.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python rt = Rototrans.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random rototrans `xarray.DataArray` sampled from a given distribution \"\"\" return Rototrans ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate a Rototrans with some random data sampled from a normal distribution: from motion import Rototrans n_frames = 100 size = 4 , 4 , n_frames rt = Rototrans . from_random_data ( size = size ) You can choose any distribution available in numpy.random : rt = Rototrans . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (4, 4, 100) *args _empty Positional argument(s) to be passed to numpy.random. distribution () **kwargs _empty Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random rototrans xarray.DataArray sampled from a given distribution","title":"rototrans"},{"location":"api/rototrans/#rototranspy","text":"","title":"rototrans.py"},{"location":"api/rototrans/#motion.rototrans.Rototrans","text":"","title":"Rototrans"},{"location":"api/rototrans/#motion.rototrans.Rototrans.__new__","text":"Show source code in motion/rototrans.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Rototrans DataArray with `axis`, `channel` and `time_frame` dimensions To instantiate a `Rototrans` 4 by 4 and 100 frames filled with some random data: ```python import numpy as np from motion import Rototrans n_row = 4 n_col = 4 n_frames = 100 data = np.random.random(size=(n_row, n_col, n_frames)) rt = Rototrans(data) ``` You can an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) rt = Rototrans(data, time_frames=time_frames) ``` Calling `Rototrans()` generate an empty array. Arguments: data: Array to be passed to xarray.DataArray time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Rototrans `xarray.DataArray` with the specified data and coordinates \"\"\" coords = {} if data is None : data = np . eye ( 4 ) if data . shape [ 0 ] != 4 or data . shape [ 1 ] != 4 : raise IndexError ( f \"data must have first and second dimensions of length 4, you have: {data.shape} \" ) if data . ndim == 2 : data = data [ ... , np . newaxis ] if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"row\" , \"col\" , \"time_frame\" ), coords = coords , name = \"rototrans\" , * args , ** kwargs , ) Rototrans DataArray with axis , channel and time_frame dimensions To instantiate a Rototrans 4 by 4 and 100 frames filled with some random data: import numpy as np from motion import Rototrans n_row = 4 n_col = 4 n_frames = 100 data = np . random . random ( size = ( n_row , n_col , n_frames )) rt = Rototrans ( data ) You can an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) rt = Rototrans ( data , time_frames = time_frames ) Calling Rototrans() generate an empty array. Parameters Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None *args _empty Positional argument(s) to be passed to xarray.DataArray () **kwargs _empty Keyword argument(s) to be passed to xarray.DataArray {} Returns Type Description DataArray Rototrans xarray.DataArray with the specified data and coordinates","title":"__new__()"},{"location":"api/rototrans/#motion.rototrans.Rototrans.from_euler_angles","text":"Show source code in motion/rototrans.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @classmethod def from_euler_angles ( cls , angles : Optional [ xr . DataArray ] = None , angle_sequence : Optional [ str ] = None , translations : Optional [ xr . DataArray ] = None , ) -> xr . DataArray : \"\"\" Rototrans DataArray from euler angles and specified angle sequence To get the rototranslation matrix from random euler angles with a given angle sequence type: ```python from motion import Angles, Rototrans size = (3, 1, 100) angles = Angles.from_random_data(size=size) angles_sequence = \"xyz\" rt = Rototrans.from_euler_angles(angles=angles, angle_sequence=angles_sequence) ``` A translation vector can also be specified: ```python translation = Angles.from_random_data(size=size) rt = Rototrans.from_euler_angles( angles=angles, angle_sequence=angles_sequence, translations=translation ) ``` Arguments: angles: Euler angles of the rototranslation matrix angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" translations: Translation part of the Rototrans matrix Returns: Rototrans `xarray.DataArray` from the specified angles and angles sequence \"\"\" return rototrans_from_euler_angles ( cls , angles , angle_sequence , translations ) Rototrans DataArray from euler angles and specified angle sequence To get the rototranslation matrix from random euler angles with a given angle sequence type: from motion import Angles , Rototrans size = ( 3 , 1 , 100 ) angles = Angles . from_random_data ( size = size ) angles_sequence = \"xyz\" rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence ) A translation vector can also be specified: translation = Angles . from_random_data ( size = size ) rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence , translations = translation ) Parameters Name Type Description Default angles Optional[xarray.core.dataarray.DataArray] Euler angles of the rototranslation matrix None angle_sequence Optional[str] Euler sequence of angles. Valid values are all permutations of \"xyz\" None translations Optional[xarray.core.dataarray.DataArray] Translation part of the Rototrans matrix None Returns Type Description DataArray Rototrans xarray.DataArray from the specified angles and angles sequence","title":"from_euler_angles()"},{"location":"api/rototrans/#motion.rototrans.Rototrans.from_random_data","text":"Show source code in motion/rototrans.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 4 , 4 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk To instantiate a `Rototrans` with some random data sampled from a normal distribution: ```python from motion import Rototrans n_frames = 100 size = 4, 4, n_frames rt = Rototrans.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python rt = Rototrans.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random rototrans `xarray.DataArray` sampled from a given distribution \"\"\" return Rototrans ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) Create random data from a specified distribution (normal by default) using random walk To instantiate a Rototrans with some random data sampled from a normal distribution: from motion import Rototrans n_frames = 100 size = 4 , 4 , n_frames rt = Rototrans . from_random_data ( size = size ) You can choose any distribution available in numpy.random : rt = Rototrans . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Parameters Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (4, 4, 100) *args _empty Positional argument(s) to be passed to numpy.random. distribution () **kwargs _empty Keyword argument(s) to be passed to numpy.random. distribution {} Returns Type Description DataArray Random rototrans xarray.DataArray sampled from a given distribution","title":"from_random_data()"}]}