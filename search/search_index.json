{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pyomeca is a python library allowing you to carry out a complete biomechanical analysis; in a simple, logical and concise way. Pyomeca documentation See Pyomeca's documentation site . Example Here is an example of a complete EMG pipeline in just one command: from motion import Analogs Features Object-oriented architecture where each class is associated with common and specialized functionalities: Markers3d : 3d markers positions Analogs3d : analogs (emg, force or any analog meca) GeneralizedCoordinate : generalized coordinate (joint angle) RotoTrans : roto-translation matrix Specialized functionalities including processing routine commonly used in biomechanics: filters, normalization, onset detection, outliers detection, derivative, etc. Each functionality can be chained. In addition to making it easier to write and read code, it allows you to add and remove analysis steps easily (such as Lego blocks). Each class inherits from a numpy array, so you can create your own analysis step easily. Easy reading and writing interface to common files in biomechanics ( .c3d , .csv , .xlsx , .mat , .sto , .trc , .mot ): Common linear algebra routine implemented: get Euler angles to/from roto-translation matrix, create a system of axes, set a rotation or translation, transpose or inverse, etc. Installation Using Conda First, install miniconda or anaconda . Then type: conda install pyomeca -c conda-forge Using pip First, you need to install python, swig and numpy. Then, follow the instructions to compile ezc3d . Finally, install pyomeca with: pip install git+https://github.com/pyomeca/pyomeca/ ` Integration with other modules Pyomeca is designed to work well with other libraries that we have developed: pyosim : interface between OpenSim and pyomeca to perform batch musculoskeletal analyses ezc3d : Easy to use C3D reader/writer in C++, Python and Matlab biorbd : C++ interface and add-ons to the Rigid Body Dynamics Library, with Python and Matlab binders. Bug Reports & Questions Pyomeca is Apache-licensed and the source code is available on GitHub . If any questions or issues come up as you use pyomeca, please get in touch via GitHub issues . We welcome any input, feedback, bug reports, and contributions.","title":"Home"},{"location":"#pyomeca-documentation","text":"See Pyomeca's documentation site .","title":"Pyomeca documentation"},{"location":"#example","text":"Here is an example of a complete EMG pipeline in just one command: from motion import Analogs","title":"Example"},{"location":"#features","text":"Object-oriented architecture where each class is associated with common and specialized functionalities: Markers3d : 3d markers positions Analogs3d : analogs (emg, force or any analog meca) GeneralizedCoordinate : generalized coordinate (joint angle) RotoTrans : roto-translation matrix Specialized functionalities including processing routine commonly used in biomechanics: filters, normalization, onset detection, outliers detection, derivative, etc. Each functionality can be chained. In addition to making it easier to write and read code, it allows you to add and remove analysis steps easily (such as Lego blocks). Each class inherits from a numpy array, so you can create your own analysis step easily. Easy reading and writing interface to common files in biomechanics ( .c3d , .csv , .xlsx , .mat , .sto , .trc , .mot ): Common linear algebra routine implemented: get Euler angles to/from roto-translation matrix, create a system of axes, set a rotation or translation, transpose or inverse, etc.","title":"Features"},{"location":"#installation","text":"","title":"Installation"},{"location":"#using-conda","text":"First, install miniconda or anaconda . Then type: conda install pyomeca -c conda-forge","title":"Using Conda"},{"location":"#using-pip","text":"First, you need to install python, swig and numpy. Then, follow the instructions to compile ezc3d . Finally, install pyomeca with: pip install git+https://github.com/pyomeca/pyomeca/ `","title":"Using pip"},{"location":"#integration-with-other-modules","text":"Pyomeca is designed to work well with other libraries that we have developed: pyosim : interface between OpenSim and pyomeca to perform batch musculoskeletal analyses ezc3d : Easy to use C3D reader/writer in C++, Python and Matlab biorbd : C++ interface and add-ons to the Rigid Body Dynamics Library, with Python and Matlab binders.","title":"Integration with other modules"},{"location":"#bug-reports-questions","text":"Pyomeca is Apache-licensed and the source code is available on GitHub . If any questions or issues come up as you use pyomeca, please get in touch via GitHub issues . We welcome any input, feedback, bug reports, and contributions.","title":"Bug Reports &amp; Questions"},{"location":"about/","text":"Licence Citing Motion Papers citing Motion Support and sponsors","title":"About"},{"location":"about/#licence","text":"","title":"Licence"},{"location":"about/#citing-motion","text":"","title":"Citing Motion"},{"location":"about/#papers-citing-motion","text":"","title":"Papers citing Motion"},{"location":"about/#support-and-sponsors","text":"","title":"Support and sponsors"},{"location":"case-studies/","text":"","title":"Case Studies"},{"location":"data-processing/","text":"","title":"Data processing"},{"location":"getting-started/","text":"Installation Before you can use motion, you will need to get it installed. Motion itself is a pure Python package, but its dependencies are not. The easiest way to get everything installed is to use conda . To install motion with its recommended dependencies using the conda command line tool: conda install -c conda-forge motion Now that you have installed motion, you should be able to import it: import motion Note Want to test motion from your browser and without installing anything? Try out our binder server: Quick overview Here is a short introduction to xarray and motion, geared mainly for new users. You should be able to follow along and complete this short example in 10 about minutes. We will carry out common tasks in biomechanics, including reading files, manipulating and processing data, making figures and writing files. Object creation Let's begin by creating a biomechanical data structure with motion. In this tutorial, we will analyze the skin marker data available in this c3d file . Motion provides the from_c3d function to read c3d files. As we want to analyse markers data, we will use the Markers class: from motion import Markers data_path = \"../tests/data/markers_analogs.c3d\" markers = Markers . from_c3d ( data_path , prefix_delimiter = \":\" ) Make sure to always have a check on the data after reading it. When used in Jupyter notebooks , data can be explored interactively. A standard text representation is available otherwise. markers Show/Hide data repr Show/Hide attributes /* CSS stylesheet for displaying xarray objects in jupyterlab. * */ :root { --xr-font-color0: var(--jp-content-font-color0, rgba(0, 0, 0, 1)); --xr-font-color2: var(--jp-content-font-color2, rgba(0, 0, 0, 0.54)); --xr-font-color3: var(--jp-content-font-color3, rgba(0, 0, 0, 0.38)); --xr-border-color: var(--jp-border-color2, #e0e0e0); --xr-disabled-color: var(--jp-layout-color3, #bdbdbd); --xr-background-color: var(--jp-layout-color0, white); --xr-background-color-row-even: var(--jp-layout-color1, white); --xr-background-color-row-odd: var(--jp-layout-color2, #eeeeee); } .xr-wrap { min-width: 300px; max-width: 700px; } .xr-header { padding-top: 6px; padding-bottom: 6px; margin-bottom: 4px; border-bottom: solid 1px var(--xr-border-color); } .xr-header > div, .xr-header > ul { display: inline; margin-top: 0; margin-bottom: 0; } .xr-obj-type, .xr-array-name { margin-left: 2px; margin-right: 10px; } .xr-obj-type { color: var(--xr-font-color2); } .xr-sections { padding-left: 0 !important; display: grid; grid-template-columns: 150px auto auto 1fr 20px 20px; } .xr-section-item { display: contents; } .xr-section-item input { display: none; } .xr-section-item input + label { color: var(--xr-disabled-color); } .xr-section-item input:enabled + label { cursor: pointer; color: var(--xr-font-color2); } .xr-section-item input:enabled + label:hover { color: var(--xr-font-color0); } .xr-section-summary { grid-column: 1; color: var(--xr-font-color2); font-weight: 500; } .xr-section-summary > span { display: inline-block; padding-left: 0.5em; } .xr-section-summary-in:disabled + label { color: var(--xr-font-color2); } .xr-section-summary-in + label:before { display: inline-block; content: '\u25ba'; font-size: 11px; width: 15px; text-align: center; } .xr-section-summary-in:disabled + label:before { color: var(--xr-disabled-color); } .xr-section-summary-in:checked + label:before { content: '\u25bc'; } .xr-section-summary-in:checked + label > span { display: none; } .xr-section-summary, .xr-section-inline-details { padding-top: 4px; padding-bottom: 4px; } .xr-section-inline-details { grid-column: 2 / -1; } .xr-section-details { display: none; grid-column: 1 / -1; margin-bottom: 5px; } .xr-section-summary-in:checked ~ .xr-section-details { display: contents; } .xr-array-wrap { grid-column: 1 / -1; display: grid; grid-template-columns: 20px auto; } .xr-array-wrap > label { grid-column: 1; vertical-align: top; } .xr-preview { color: var(--xr-font-color3); } .xr-array-preview, .xr-array-data { padding: 0 5px !important; grid-column: 2; } .xr-array-data, .xr-array-in:checked ~ .xr-array-preview { display: none; } .xr-array-in:checked ~ .xr-array-data, .xr-array-preview { display: inline-block; } .xr-dim-list { display: inline-block !important; list-style: none; padding: 0 !important; margin: 0; } .xr-dim-list li { display: inline-block; padding: 0; margin: 0; } .xr-dim-list:before { content: '('; } .xr-dim-list:after { content: ')'; } .xr-dim-list li:not(:last-child):after { content: ','; padding-right: 5px; } .xr-has-index { font-weight: bold; } .xr-var-list, .xr-var-item { display: contents; } .xr-var-item > div, .xr-var-item label, .xr-var-item > .xr-var-name span { background-color: var(--xr-background-color-row-even); margin-bottom: 0; } .xr-var-item > .xr-var-name:hover span { padding-right: 5px; } .xr-var-list > li:nth-child(odd) > div, .xr-var-list > li:nth-child(odd) > label, .xr-var-list > li:nth-child(odd) > .xr-var-name span { background-color: var(--xr-background-color-row-odd); } .xr-var-name { grid-column: 1; } .xr-var-dims { grid-column: 2; } .xr-var-dtype { grid-column: 3; text-align: right; color: var(--xr-font-color2); } .xr-var-preview { grid-column: 4; } .xr-var-name, .xr-var-dims, .xr-var-dtype, .xr-preview, .xr-attrs dt { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 10px; } .xr-var-name:hover, .xr-var-dims:hover, .xr-var-dtype:hover, .xr-attrs dt:hover { overflow: visible; width: auto; z-index: 1; } .xr-var-attrs, .xr-var-data { display: none; background-color: var(--xr-background-color) !important; padding-bottom: 5px !important; } .xr-var-attrs-in:checked ~ .xr-var-attrs, .xr-var-data-in:checked ~ .xr-var-data { display: block; } .xr-var-data > table { float: right; } .xr-var-name span, .xr-var-data, .xr-attrs { padding-left: 25px !important; } .xr-attrs, .xr-var-attrs, .xr-var-data { grid-column: 1 / -1; } dl.xr-attrs { padding: 0; margin: 0; display: grid; grid-template-columns: 125px auto; } .xr-attrs dt, dd { padding: 0; margin: 0; float: left; padding-right: 10px; width: auto; } .xr-attrs dt { font-weight: normal; grid-column: 1; } .xr-attrs dt:hover span { display: inline-block; background: var(--xr-background-color); padding-right: 10px; } .xr-attrs dd { grid-column: 2; white-space: pre-wrap; word-break: break-all; } .xr-icon-database, .xr-icon-file-text2 { display: inline-block; vertical-align: middle; width: 1em; height: 1.5em !important; stroke-width: 0; stroke: currentColor; fill: currentColor; } xarray.DataArray 'markers' axis : 4 channel : 51 time_frame : 580 44.16 44.17 44.16 44.17 44.17 44.19 44.2 ... 1.0 1.0 1.0 1.0 1.0 1.0 array([[[ 44.16278839, 44.16666412, 44.16487122, ..., 99.22426605, 99.24201965, 99.25963593], [ 32.57229614, 32.57104111, 32.56489563, ..., 87.51286316, 87.52822876, 87.54118347], [ -93.72181702, -93.72447968, -93.72324371, ..., -41.1590271 , -41.14812851, -41.12734985], ..., [ 562.26068115, 562.41027832, 562.56695557, ..., 625.63555908, 625.98504639, 626.25811768], [ 568.24200439, 568.37792969, 568.49249268, ..., 624.18139648, 624.51190186, 624.78894043], [ 568.44470215, 568.52038574, 568.59216309, ..., 623.09222412, 623.44036865, 623.75152588]], [[-276.86193848, -276.86169434, -276.86407471, ..., -259.15292358, -259.16690063, -259.17092896], [-243.14048767, -243.14073181, -243.13331604, ..., -225.44718933, -225.45556641, -225.46226501], [ 124.78598022, 124.78731537, 124.78870392, ..., 141.820755 , 141.80741882, 141.80308533], ..., [ 638.35144043, 638.4241333 , 638.50653076, ..., 592.00372314, 592.15686035, 592.27819824], [ 626.79144287, 626.86114502, 626.90710449, ..., 584.15661621, 584.27709961, 584.38830566], [ 651.37927246, 651.45532227, 651.49957275, ..., 610.59655762, 610.72821045, 610.84472656]], [[ 675.69683838, 675.69873047, 675.6986084 , ..., 903.97650146, 903.96801758, 903.980896 ], [ 676.57452393, 676.58099365, 676.57720947, ..., 904.61694336, 904.61645508, 904.63104248], [ 674.27874756, 674.27947998, 674.28033447, ..., 902.77349854, 902.77819824, 902.78143311], ..., [ 81.34425354, 81.32899475, 81.2776413 , ..., 53.45215607, 53.57727814, 53.72877121], [ 110.84020996, 110.81329346, 110.76582336, ..., 83.92819214, 84.07093048, 84.20204163], [ 129.69673157, 129.6789856 , 129.62939453, ..., 99.39131165, 99.52735138, 99.68258667]], [[ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], ..., [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ]]]) Coordinates: (3) axis (axis) <U4 'x' 'y' 'z' 'ones' array(['x', 'y', 'z', 'ones'], dtype='<U4') channel (channel) <U14 'gauche_ext' ... 'LATH' array(['gauche_ext', 'gauche_int', 'droite_int', 'droite_ext', 'avant_gauche', 'avant_droit', 'arriere_droit', 'arriere_gauche', 'ASISr', 'ASISl', 'PSISr', 'PSISl', 'STERr', 'STERl', 'STER', 'XIPH', 'T1', 'T10', 'CLAV_SC', 'CLAVm', 'CLAV_ant', 'CLAV_post', 'CLAVl', 'CLAV_AC', 'ACRO_tip', 'SCAP_AA', 'SCAPl', 'SCAPm', 'SCAP_CP', 'SCAP_RS', 'SCAP_SA', 'SCAP_IA', 'DELT', 'ARMl', 'ARMm', 'ARMp_up', 'ARMp_do', 'EPICl', 'EPICm', 'LARMm', 'LARMl', 'LARM_elb', 'LARM_ant', 'STYLr', 'STYLr_up', 'STYLu', 'WRIST', 'INDEX', 'LASTC', 'MEDH', 'LATH'], dtype='<U14') time_frame (time_frame) float64 0.0 0.01 0.02 ... 5.77 5.78 5.79 array([0. , 0.01, 0.02, ..., 5.77, 5.78, 5.79]) Attributes: (4) first_frame : 0 last_frame : 579 rate : 100.0 units : mm In this case, we have generated a 3D array with the axis , channel and time_frame dimensions. Note There are several ways to create objects in motion: by supplying data, from files of from other data structure. A more complete guide on object creation is available in the objection creation section of the documentation. Indexing Since we have labels associated with each dimension, we have several kind of indexing available with varying levels of convenience and intuitiveness. Let's see three ways to get the same data (ninth marker and first time frame). Positional indexing Indexing directly works just like it does for numpy arrays. markers [:, 9 , 0 ] <xarray.DataArray 'markers' (axis: 4)> array([753.43908691, 75.9487381 , 187.7590332 , 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'ASISl' time_frame float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm Label-based indexing Label-based indexing frees us from having to know how the data are organized. We do not have to rely on dimension order and can use them explicitly to index the data. The isel method is used when the dimension lookup is by name and the index lookup is by integer markers . isel ( channel = 9 , time_frame = 0 ) <xarray.DataArray 'markers' (axis: 4)> array([753.43908691, 75.9487381 , 187.7590332 , 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'ASISl' time_frame float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm The isel method is used when the dimension and index lookups are both by name. markers . sel ( channel = \"ASISl\" , time_frame = 0 ) <xarray.DataArray 'markers' (axis: 4)> array([753.43908691, 75.9487381 , 187.7590332 , 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'ASISl' time_frame float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm Note xarray offers extremely flexible indexing routines. For more details on indexing see the xarray documentation . Metadata Biomechanical datasets are usually more than just raw numbers and have various metadata attributes. Some metadata are already filled by motion and available in the attrs Python dictionnary. markers . attrs >> {'first_frame': 0, 'last_frame': 579, 'rate': 100.0, 'units': 'mm'} They can be accessed using the standard dictionnary indexing markers . attrs [ \"rate\" ] >> 100.0 Or directly as a propriety markers . rate >> 100.0 You can assign anything you wish. markers . attrs [ \"description\" ] = \"Skin marker positions recorded in Montreal.\" markers . attrs [ \"participant_id\" ] = 12 markers . time_frame . attrs [ \"units\" ] = \"seconds\" markers <xarray.DataArray 'markers' (axis: 4, channel: 51, time_frame: 580)> array([[[ 44.16278839, 44.16666412, 44.16487122, ..., 99.22426605, 99.24201965, 99.25963593], [ 32.57229614, 32.57104111, 32.56489563, ..., 87.51286316, 87.52822876, 87.54118347], [ -93.72181702, -93.72447968, -93.72324371, ..., -41.1590271 , -41.14812851, -41.12734985], ..., [ 562.26068115, 562.41027832, 562.56695557, ..., 625.63555908, 625.98504639, 626.25811768], [ 568.24200439, 568.37792969, 568.49249268, ..., 624.18139648, 624.51190186, 624.78894043], [ 568.44470215, 568.52038574, 568.59216309, ..., 623.09222412, 623.44036865, 623.75152588]], [[-276.86193848, -276.86169434, -276.86407471, ..., -259.15292358, -259.16690063, -259.17092896], [-243.14048767, -243.14073181, -243.13331604, ..., -225.44718933, -225.45556641, -225.46226501], [ 124.78598022, 124.78731537, 124.78870392, ..., 141.820755 , 141.80741882, 141.80308533], ..., [ 638.35144043, 638.4241333 , 638.50653076, ..., 592.00372314, 592.15686035, 592.27819824], [ 626.79144287, 626.86114502, 626.90710449, ..., 584.15661621, 584.27709961, 584.38830566], [ 651.37927246, 651.45532227, 651.49957275, ..., 610.59655762, 610.72821045, 610.84472656]], [[ 675.69683838, 675.69873047, 675.6986084 , ..., 903.97650146, 903.96801758, 903.980896 ], [ 676.57452393, 676.58099365, 676.57720947, ..., 904.61694336, 904.61645508, 904.63104248], [ 674.27874756, 674.27947998, 674.28033447, ..., 902.77349854, 902.77819824, 902.78143311], ..., [ 81.34425354, 81.32899475, 81.2776413 , ..., 53.45215607, 53.57727814, 53.72877121], [ 110.84020996, 110.81329346, 110.76582336, ..., 83.92819214, 84.07093048, 84.20204163], [ 129.69673157, 129.6789856 , 129.62939453, ..., 99.39131165, 99.52735138, 99.68258667]], [[ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], ..., [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ]]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' * channel (channel) <U14 'gauche_ext' 'gauche_int' ... 'MEDH' 'LATH' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 ... 5.76 5.77 5.78 5.79 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 Computation Arithmetic As the underlying data-structure is a numpy array, xarray data arrays work the same way you would expect if you are used to numpy. subset = markers [:, 0 , : 6 ] subset + 10 <xarray.DataArray 'markers' (axis: 4, time_frame: 6)> array([[ 54.16278839, 54.16666412, 54.16487122, 54.16558075, 54.17311096, 54.18517685], [-266.86193848, -266.86169434, -266.86407471, -266.86123657, -266.85812378, -266.85818481], [ 685.69683838, 685.69873047, 685.6986084 , 685.69775391, 685.7041626 , 685.69592285], [ 11. , 11. , 11. , 11. , 11. , 11. ]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 0.04 0.05 subset . T # transpose <xarray.DataArray 'markers' (time_frame: 6, axis: 4)> array([[ 44.16278839, -276.86193848, 675.69683838, 1. ], [ 44.16666412, -276.86169434, 675.69873047, 1. ], [ 44.16487122, -276.86407471, 675.6986084 , 1. ], [ 44.16558075, -276.86123657, 675.69775391, 1. ], [ 44.17311096, -276.85812378, 675.7041626 , 1. ], [ 44.18517685, -276.85818481, 675.69592285, 1. ]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 0.04 0.05 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 subset . mean () <xarray.DataArray 'markers' ()> array(111.00187318) Coordinates: channel <U14 'gauche_ext' subset . mean ( axis = 1 ) <xarray.DataArray 'markers' (axis: 4)> array([ 44.16969872, -276.86087545, 675.69866943, 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' We can, however, take advantage of the labels instead of axis numbers subset . mean ( dim = \"time_frame\" ) <xarray.DataArray 'markers' (axis: 4)> array([ 44.16969872, -276.86087545, 675.69866943, 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' Arithmetic operations broadcast based on dimension name. This means you don\u2019t need to insert dummy dimensions for alignment: only_first_axis = subset . sel ( axis = \"x\" ) only_first_frame = subset . isel ( time_frame = 0 ) only_first_axis <xarray.DataArray 'markers' (time_frame: 6)> array([44.16278839, 44.16666412, 44.16487122, 44.16558075, 44.17311096, 44.18517685]) Coordinates: axis <U4 'x' channel <U14 'gauche_ext' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 0.04 0.05 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 only_first_frame <xarray.DataArray 'markers' (axis: 4)> array([ 44.16278839, -276.86193848, 675.69683838, 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' time_frame float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 only_first_frame + only_first_axis <xarray.DataArray 'markers' (axis: 4, time_frame: 6)> array([[ 88.32557678, 88.32945251, 88.32765961, 88.32836914, 88.33589935, 88.34796524], [-232.69915009, -232.69527435, -232.69706726, -232.69635773, -232.68882751, -232.67676163], [ 719.85962677, 719.8635025 , 719.86170959, 719.86241913, 719.86994934, 719.88201523], [ 45.16278839, 45.16666412, 45.16487122, 45.16558075, 45.17311096, 45.18517685]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 0.04 0.05 Let's compare with the sum made with numpy arrays: only_first_axis . values + only_first_axis . values >> array([88.32557678, 88.33332825, 88.32974243, 88.3311615 , 88.34622192, 88.3703537 ]) And we do not need to worry about the order of dimensions subset - subset . T <xarray.DataArray 'markers' (axis: 4, time_frame: 6)> array([[0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 0.04 0.05 Whereas this is not possible with numpy arrays: subset . values - subset . values . T ValueError : operands could not be broadcast together with shapes ( 4 , 6 ) ( 6 , 4 ) Note xarray supports powerful shortcust for computation. For more, see the xarray documentation . Exploring missing values When we visualize some of our markers, we can realize that there are some missing values markers . sel ( axis = \"x\" , channel = \"SCAP_CP\" ) . plot . line ( x = \"time_frame\" ); Let's investigate those missing values markers_null_values = markers . sel ( axis = \"x\" ) . isnull () print ( f \"There are { markers_null_values . sum () . values } missing values\" ) >> There are 305 missing values What are the 5 markers with the most missing values? markers_null_values . sum ( dim = \"time_frame\" ) . to_series () . nlargest ( 5 ) . plot . barh (); The cumulative number of missing values can tell us when marker occlusions occur markers_null_values . sum ( \"channel\" ) . cumsum ( \"time_frame\" ) . plot (); Now that we know more about the missing values, we can use xarray for filling missing values via 1D interpolation markers_without_null = markers . interpolate_na ( dim = \"time_frame\" , method = \"cubic\" ) import matplotlib.pyplot as plt markers . sel ( axis = \"x\" , channel = \"SCAP_CP\" ) . plot . line ( x = \"time_frame\" ) markers_without_null . where ( markers . isnull ()) . sel ( axis = \"x\" , channel = \"SCAP_CP\" ) . plot . line ( x = \"time_frame\" , label = \"interpolated\" , color = \"r\" ) plt . legend (); Electromyographic pipeline Motion implements specialized functionalities commonly used in biomechanics. Let's proccess the electromyographic data contained in our c3d file. from motion import Analogs muscles = [ \"Delt_med\" , \"Delt_post\" , \"Biceps\" , \"Triceps\" , \"Trap_sup\" , \"Trap_inf\" , \"Gd_dent\" , \"Supra\" , ] emg = Analogs . from_c3d ( data_path , suffix_delimiter = \".\" , usecols = muscles ) emg . time_frame . attrs [ \"units\" ] = \"seconds\" emg . plot ( x = \"time_frame\" , col = \"channel\" , col_wrap = 4 ); emg_processed = ( emg . meca . band_pass ( freq = emg . rate , order = 2 , cutoff = [ 10 , 425 ]) . meca . center () . meca . abs () . meca . low_pass ( freq = emg . rate , order = 4 , cutoff = 5 ) . meca . normalize () ) emg_processed . plot ( x = \"time_frame\" , col = \"channel\" , col_wrap = 4 ); emg_processed . meca . to_wide_dataframe () . plot . box ( figsize = ( 8 , 4 )); fig , axes = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) emg_processed . mean ( \"channel\" ) . plot ( ax = axes [ 0 ]) axes [ 0 ] . set_title ( \"Mean EMG activation\" ) emg_processed . plot . hist ( ax = axes [ 1 ], bins = 50 ) axes [ 1 ] . set_title ( \"EMG activation distribution\" ); emg_processed . meca . to_wide_dataframe () . corr () . round ( 2 ) . style . background_gradient () . format ( \" {:.2} \" ) #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col0 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col1 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col2 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col3 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col4 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col5 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col6 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col7 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col0 { background-color: #f0eaf4; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col1 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col2 { background-color: #056ead; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col3 { background-color: #046096; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col4 { background-color: #045788; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col5 { background-color: #187cb6; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col6 { background-color: #04639b; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col7 { background-color: #034d79; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col0 { background-color: #ece7f2; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col1 { background-color: #056dab; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col2 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col3 { background-color: #056dab; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col4 { background-color: #04649d; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col5 { background-color: #4295c3; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col6 { background-color: #3991c1; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col7 { background-color: #056aa6; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col0 { background-color: #ced0e6; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col1 { background-color: #045b8e; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col2 { background-color: #0567a1; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col3 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col4 { background-color: #046299; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col5 { background-color: #0567a2; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col6 { background-color: #0569a5; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col7 { background-color: #04649d; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col0 { background-color: #dbdaeb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col1 { background-color: #045382; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col2 { background-color: #046198; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col3 { background-color: #04649d; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col4 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col5 { background-color: #187cb6; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col6 { background-color: #045585; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col7 { background-color: #045f95; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col0 { background-color: #c9cee4; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col1 { background-color: #056fae; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col2 { background-color: #2685bb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col3 { background-color: #0566a0; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col4 { background-color: #0d75b3; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col5 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col6 { background-color: #2182b9; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col7 { background-color: #2081b9; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col0 { background-color: #d3d4e7; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col1 { background-color: #045e94; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col2 { background-color: #2685bb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col3 { background-color: #056ba7; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col4 { background-color: #045483; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col5 { background-color: #2786bb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col6 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col7 { background-color: #0a73b2; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col0 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col1 { background-color: #03517e; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col2 { background-color: #056faf; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col3 { background-color: #056fae; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col4 { background-color: #0566a0; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col5 { background-color: #549cc7; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col6 { background-color: #2a88bc; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col7 { background-color: #023858; color: #f1f1f1; } channel Biceps Delt_med Delt_post Gd_dent Supra Trap_inf Trap_sup Triceps channel Biceps 1.0 0.01 0.04 0.18 0.12 0.2 0.16 -0.1 Delt_med 0.01 1.0 0.77 0.87 0.9 0.76 0.85 0.91 Delt_post 0.04 0.77 1.0 0.81 0.84 0.68 0.68 0.76 Gd_dent 0.18 0.87 0.81 1.0 0.85 0.84 0.82 0.8 Supra 0.12 0.9 0.84 0.85 1.0 0.76 0.91 0.83 Trap_inf 0.2 0.76 0.68 0.84 0.76 1.0 0.73 0.65 Trap_sup 0.16 0.85 0.68 0.82 0.91 0.73 1.0 0.71 Triceps -0.1 0.91 0.76 0.8 0.83 0.65 0.71 1.0 Note For more details, see the data processing section of the documentation. Datasets Datasets are a usefull xarray feature to store multiple data arrays with common dimensions import xarray as xr import numpy as np trials = xr . Dataset ( { f \"trial { i } \" : Analogs . from_random_data ( size = ( 2 , 100 )) for i in range ( 10 )}, coords = { \"channel\" : [ \"biceps\" , \"triceps\" ], \"time_frame\" : np . arange ( start = 0 , stop = 1 , step = 1 / 100 ), }, ) trials <xarray.Dataset> Dimensions: (channel: 2, time_frame: 100) Coordinates: * channel (channel) <U7 'biceps' 'triceps' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 ... 0.96 0.97 0.98 0.99 Data variables: trial 0 (channel, time_frame) float64 0.6213 1.719 0.866 ... 9.505 8.115 trial 1 (channel, time_frame) float64 0.4762 -1.526 ... -19.32 -19.3 trial 2 (channel, time_frame) float64 0.3844 1.646 1.07 ... 7.246 6.323 trial 3 (channel, time_frame) float64 1.449 1.019 ... -0.7756 -0.4806 trial 4 (channel, time_frame) float64 -0.8075 -0.8303 ... 4.079 3.83 trial 5 (channel, time_frame) float64 0.4531 -1.098 ... 2.398 3.985 trial 6 (channel, time_frame) float64 -1.182 -1.656 ... -2.581 -2.192 trial 7 (channel, time_frame) float64 -2.592 -3.178 ... 15.51 15.27 trial 8 (channel, time_frame) float64 -0.3918 -1.442 ... 25.23 26.19 trial 9 (channel, time_frame) float64 -1.481 -2.139 ... 0.9357 1.831 We can still access the individual data arrays trials [ \"trial 1\" ] <xarray.DataArray 'trial 1' (channel: 2, time_frame: 100)> array([[ 0.47623852, -1.52647846, -1.96738802, -1.42058653, -2.50657205, -2.39306107, -2.38815955, -3.96941323, -6.37847912, -6.24926056, -7.50760797, -8.00105399, -7.64407712, -8.61989586, -7.61570536, -7.95773563, -9.20630194, -9.91979492, -10.52154282, -12.85969668, -13.62744403, -14.49864251, -14.43498671, -12.29269643, -13.02242288, -12.80080327, -11.67041621, -11.24812038, -9.66059498, -9.93072116, -9.74923083, -10.06229148, -11.13082113, -12.49845396, -14.237828 , -15.81771657, -16.44600458, -16.50841704, -17.42825405, -18.18971984, -16.78854839, -19.47244051, -21.28145729, -20.47938508, -18.33201631, -17.91306457, -17.21616681, -18.86668992, -18.31816582, -16.02543226, -16.64301578, -17.03206438, -17.42983904, -15.77192179, -13.98902039, -14.03357541, -13.48182332, -13.70065456, -14.33658026, -12.67135754, -13.53896994, -13.5048632 , -11.61352025, -11.60257998, -12.55901814, -13.5419003 , -14.26830579, -14.60865389, -14.2919254 , -15.89631716, -15.4440441 , -14.83500062, -16.4688737 , -17.16844731, -18.02335305, -16.197262 , -17.00791146, -16.90529553, -14.86090342, -14.14735878, -14.83183833, -13.17862687, -13.81717689, -13.38957044, -13.74157632, -13.94395614, -13.12239669, -12.81361114, -14.77627099, -15.49713256, -14.17186861, -15.13607837, -15.08852131, -16.39951157, -15.69023501, -17.48194166, -17.89564911, -18.46966648, -19.10539655, -18.86210539], [ -0.07562232, -2.13157313, -2.52565624, -3.16737923, -3.47872793, -3.39455281, -3.58575229, -4.52984777, -2.32309177, -1.22442814, -0.70818375, -1.40633073, -2.49285451, -2.37423871, -1.78166419, -1.36713184, -2.04649093, -3.05242068, -2.49374956, -2.94197875, -3.14761933, -2.26566867, -2.3992928 , -1.82904497, -2.6197727 , -4.10526706, -3.02491866, -3.52888903, -3.46395081, -3.54457552, -2.35200931, -1.83294786, -1.38317291, -1.10246625, -0.63363609, -2.59831925, -2.840266 , -4.43755361, -3.03045171, -2.3281822 , -1.85689469, -1.52041305, -0.28943751, -1.0495644 , -0.13113076, -2.76416536, -3.33035513, -3.26453514, -3.87142215, -3.50035367, -4.0517286 , -5.0390548 , -4.94376262, -3.74177457, -5.3685079 , -6.03157489, -7.19781985, -8.22252785, -8.96124884, -10.46496616, -11.84970806, -10.06281609, -10.05809348, -11.10129014, -11.39836653, -12.08978453, -11.92826824, -11.33826858, -10.33361977, -11.26835467, -13.77656503, -12.90916429, -13.53178288, -13.21946147, -13.03004045, -12.9658466 , -12.79456943, -14.6075092 , -14.92044819, -14.99394043, -17.62197044, -17.54441968, -18.32578838, -17.70853203, -16.47186952, -17.30728455, -18.76528554, -17.05165987, -17.83764451, -18.87369267, -19.35153227, -19.97146621, -19.85233526, -19.49087653, -19.83187261, -19.86927008, -18.48532508, -19.56761191, -19.32498661, -19.30402421]]) Coordinates: * channel (channel) <U7 'biceps' 'triceps' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 ... 0.96 0.97 0.98 0.99 While being able to do indexing and computation on the whole dataset trials . sel ( channel = \"biceps\" ) + 100 <xarray.Dataset> Dimensions: (time_frame: 100) Coordinates: channel <U7 'biceps' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 ... 0.96 0.97 0.98 0.99 Data variables: trial 0 (time_frame) float64 100.6 101.7 100.9 ... 95.29 95.84 95.57 trial 1 (time_frame) float64 100.5 98.47 98.03 ... 81.53 80.89 81.14 trial 2 (time_frame) float64 100.4 101.6 101.1 ... 92.7 92.26 90.23 trial 3 (time_frame) float64 101.4 101.0 101.5 ... 102.2 101.0 100.7 trial 4 (time_frame) float64 99.19 99.17 101.0 ... 108.6 106.8 108.0 trial 5 (time_frame) float64 100.5 98.9 99.64 ... 94.22 95.92 94.42 trial 6 (time_frame) float64 98.82 98.34 97.76 ... 116.7 116.1 115.2 trial 7 (time_frame) float64 97.41 96.82 96.98 97.8 ... 97.0 97.46 98.0 trial 8 (time_frame) float64 99.61 98.56 98.87 ... 97.05 95.71 96.23 trial 9 (time_frame) float64 98.52 97.86 98.33 ... 97.85 98.54 98.53 File IO NetCDF is the recommended file format to save and share xarray object. emg . to_netcdf ( \"emg.nc\" ) xr . open_dataarray ( \"emg.nc\" ) <xarray.DataArray 'analogs' (channel: 8, time_frame: 11600)> array([[-4.021073e-05, -6.808358e-05, -8.640526e-05, ..., 4.983108e-05, 4.229912e-05, 3.812956e-05], [-1.361103e-05, -1.327931e-05, -1.273931e-05, ..., -2.546135e-05, -2.306871e-05, -1.898580e-05], [ 9.727633e-06, 9.567407e-06, 9.567407e-06, ..., 9.903105e-06, 1.118365e-05, 1.182195e-05], ..., [-9.918351e-06, -1.089098e-05, -1.067791e-05, ..., -1.001964e-06, -1.264539e-05, -1.919743e-05], [-2.296531e-06, -9.303800e-07, -1.047933e-06, ..., 1.562380e-06, 2.389907e-06, 3.062012e-06], [ 2.975303e-04, 1.551703e-04, 3.527764e-05, ..., -2.581336e-04, -4.462923e-04, -5.757854e-04]]) Coordinates: * time_frame (time_frame) timedelta64[ns] 00:00:00 ... 00:00:05.799500 * channel (channel) object 'Delt_med' 'Delt_post' ... 'Gd_dent' 'Supra' Attributes: first_frame: 0 last_frame: 11580 rate: 2000.0 units: V trials . to_netcdf ( \"trials.nc\" ) import xarray as xr xr . open_dataset ( \"trials.nc\" ) <xarray.Dataset> Dimensions: (channel: 2, time_frame: 100) Coordinates: * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 ... 0.96 0.97 0.98 0.99 * channel (channel) object 'biceps' 'triceps' Data variables: trial 0 (channel, time_frame) float64 ... trial 1 (channel, time_frame) float64 ... trial 2 (channel, time_frame) float64 ... trial 3 (channel, time_frame) float64 ... trial 4 (channel, time_frame) float64 ... trial 5 (channel, time_frame) float64 ... trial 6 (channel, time_frame) float64 ... trial 7 (channel, time_frame) float64 ... trial 8 (channel, time_frame) float64 ... trial 9 (channel, time_frame) float64 ... Motion implements function to read various file format commonly used in biomechanics such as c3d , csv , xlsx , sto , trc and mot . Users can also write Matlab and csv files. emg . meca . to_matlab ( \"emg.mat\" ) emg . meca . to_csv ( \"emg.csv\" )","title":"Getting Started"},{"location":"getting-started/#installation","text":"Before you can use motion, you will need to get it installed. Motion itself is a pure Python package, but its dependencies are not. The easiest way to get everything installed is to use conda . To install motion with its recommended dependencies using the conda command line tool: conda install -c conda-forge motion Now that you have installed motion, you should be able to import it: import motion Note Want to test motion from your browser and without installing anything? Try out our binder server:","title":"Installation"},{"location":"getting-started/#quick-overview","text":"Here is a short introduction to xarray and motion, geared mainly for new users. You should be able to follow along and complete this short example in 10 about minutes. We will carry out common tasks in biomechanics, including reading files, manipulating and processing data, making figures and writing files.","title":"Quick overview"},{"location":"getting-started/#object-creation","text":"Let's begin by creating a biomechanical data structure with motion. In this tutorial, we will analyze the skin marker data available in this c3d file . Motion provides the from_c3d function to read c3d files. As we want to analyse markers data, we will use the Markers class: from motion import Markers data_path = \"../tests/data/markers_analogs.c3d\" markers = Markers . from_c3d ( data_path , prefix_delimiter = \":\" ) Make sure to always have a check on the data after reading it. When used in Jupyter notebooks , data can be explored interactively. A standard text representation is available otherwise. markers Show/Hide data repr Show/Hide attributes /* CSS stylesheet for displaying xarray objects in jupyterlab. * */ :root { --xr-font-color0: var(--jp-content-font-color0, rgba(0, 0, 0, 1)); --xr-font-color2: var(--jp-content-font-color2, rgba(0, 0, 0, 0.54)); --xr-font-color3: var(--jp-content-font-color3, rgba(0, 0, 0, 0.38)); --xr-border-color: var(--jp-border-color2, #e0e0e0); --xr-disabled-color: var(--jp-layout-color3, #bdbdbd); --xr-background-color: var(--jp-layout-color0, white); --xr-background-color-row-even: var(--jp-layout-color1, white); --xr-background-color-row-odd: var(--jp-layout-color2, #eeeeee); } .xr-wrap { min-width: 300px; max-width: 700px; } .xr-header { padding-top: 6px; padding-bottom: 6px; margin-bottom: 4px; border-bottom: solid 1px var(--xr-border-color); } .xr-header > div, .xr-header > ul { display: inline; margin-top: 0; margin-bottom: 0; } .xr-obj-type, .xr-array-name { margin-left: 2px; margin-right: 10px; } .xr-obj-type { color: var(--xr-font-color2); } .xr-sections { padding-left: 0 !important; display: grid; grid-template-columns: 150px auto auto 1fr 20px 20px; } .xr-section-item { display: contents; } .xr-section-item input { display: none; } .xr-section-item input + label { color: var(--xr-disabled-color); } .xr-section-item input:enabled + label { cursor: pointer; color: var(--xr-font-color2); } .xr-section-item input:enabled + label:hover { color: var(--xr-font-color0); } .xr-section-summary { grid-column: 1; color: var(--xr-font-color2); font-weight: 500; } .xr-section-summary > span { display: inline-block; padding-left: 0.5em; } .xr-section-summary-in:disabled + label { color: var(--xr-font-color2); } .xr-section-summary-in + label:before { display: inline-block; content: '\u25ba'; font-size: 11px; width: 15px; text-align: center; } .xr-section-summary-in:disabled + label:before { color: var(--xr-disabled-color); } .xr-section-summary-in:checked + label:before { content: '\u25bc'; } .xr-section-summary-in:checked + label > span { display: none; } .xr-section-summary, .xr-section-inline-details { padding-top: 4px; padding-bottom: 4px; } .xr-section-inline-details { grid-column: 2 / -1; } .xr-section-details { display: none; grid-column: 1 / -1; margin-bottom: 5px; } .xr-section-summary-in:checked ~ .xr-section-details { display: contents; } .xr-array-wrap { grid-column: 1 / -1; display: grid; grid-template-columns: 20px auto; } .xr-array-wrap > label { grid-column: 1; vertical-align: top; } .xr-preview { color: var(--xr-font-color3); } .xr-array-preview, .xr-array-data { padding: 0 5px !important; grid-column: 2; } .xr-array-data, .xr-array-in:checked ~ .xr-array-preview { display: none; } .xr-array-in:checked ~ .xr-array-data, .xr-array-preview { display: inline-block; } .xr-dim-list { display: inline-block !important; list-style: none; padding: 0 !important; margin: 0; } .xr-dim-list li { display: inline-block; padding: 0; margin: 0; } .xr-dim-list:before { content: '('; } .xr-dim-list:after { content: ')'; } .xr-dim-list li:not(:last-child):after { content: ','; padding-right: 5px; } .xr-has-index { font-weight: bold; } .xr-var-list, .xr-var-item { display: contents; } .xr-var-item > div, .xr-var-item label, .xr-var-item > .xr-var-name span { background-color: var(--xr-background-color-row-even); margin-bottom: 0; } .xr-var-item > .xr-var-name:hover span { padding-right: 5px; } .xr-var-list > li:nth-child(odd) > div, .xr-var-list > li:nth-child(odd) > label, .xr-var-list > li:nth-child(odd) > .xr-var-name span { background-color: var(--xr-background-color-row-odd); } .xr-var-name { grid-column: 1; } .xr-var-dims { grid-column: 2; } .xr-var-dtype { grid-column: 3; text-align: right; color: var(--xr-font-color2); } .xr-var-preview { grid-column: 4; } .xr-var-name, .xr-var-dims, .xr-var-dtype, .xr-preview, .xr-attrs dt { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 10px; } .xr-var-name:hover, .xr-var-dims:hover, .xr-var-dtype:hover, .xr-attrs dt:hover { overflow: visible; width: auto; z-index: 1; } .xr-var-attrs, .xr-var-data { display: none; background-color: var(--xr-background-color) !important; padding-bottom: 5px !important; } .xr-var-attrs-in:checked ~ .xr-var-attrs, .xr-var-data-in:checked ~ .xr-var-data { display: block; } .xr-var-data > table { float: right; } .xr-var-name span, .xr-var-data, .xr-attrs { padding-left: 25px !important; } .xr-attrs, .xr-var-attrs, .xr-var-data { grid-column: 1 / -1; } dl.xr-attrs { padding: 0; margin: 0; display: grid; grid-template-columns: 125px auto; } .xr-attrs dt, dd { padding: 0; margin: 0; float: left; padding-right: 10px; width: auto; } .xr-attrs dt { font-weight: normal; grid-column: 1; } .xr-attrs dt:hover span { display: inline-block; background: var(--xr-background-color); padding-right: 10px; } .xr-attrs dd { grid-column: 2; white-space: pre-wrap; word-break: break-all; } .xr-icon-database, .xr-icon-file-text2 { display: inline-block; vertical-align: middle; width: 1em; height: 1.5em !important; stroke-width: 0; stroke: currentColor; fill: currentColor; } xarray.DataArray 'markers' axis : 4 channel : 51 time_frame : 580 44.16 44.17 44.16 44.17 44.17 44.19 44.2 ... 1.0 1.0 1.0 1.0 1.0 1.0 array([[[ 44.16278839, 44.16666412, 44.16487122, ..., 99.22426605, 99.24201965, 99.25963593], [ 32.57229614, 32.57104111, 32.56489563, ..., 87.51286316, 87.52822876, 87.54118347], [ -93.72181702, -93.72447968, -93.72324371, ..., -41.1590271 , -41.14812851, -41.12734985], ..., [ 562.26068115, 562.41027832, 562.56695557, ..., 625.63555908, 625.98504639, 626.25811768], [ 568.24200439, 568.37792969, 568.49249268, ..., 624.18139648, 624.51190186, 624.78894043], [ 568.44470215, 568.52038574, 568.59216309, ..., 623.09222412, 623.44036865, 623.75152588]], [[-276.86193848, -276.86169434, -276.86407471, ..., -259.15292358, -259.16690063, -259.17092896], [-243.14048767, -243.14073181, -243.13331604, ..., -225.44718933, -225.45556641, -225.46226501], [ 124.78598022, 124.78731537, 124.78870392, ..., 141.820755 , 141.80741882, 141.80308533], ..., [ 638.35144043, 638.4241333 , 638.50653076, ..., 592.00372314, 592.15686035, 592.27819824], [ 626.79144287, 626.86114502, 626.90710449, ..., 584.15661621, 584.27709961, 584.38830566], [ 651.37927246, 651.45532227, 651.49957275, ..., 610.59655762, 610.72821045, 610.84472656]], [[ 675.69683838, 675.69873047, 675.6986084 , ..., 903.97650146, 903.96801758, 903.980896 ], [ 676.57452393, 676.58099365, 676.57720947, ..., 904.61694336, 904.61645508, 904.63104248], [ 674.27874756, 674.27947998, 674.28033447, ..., 902.77349854, 902.77819824, 902.78143311], ..., [ 81.34425354, 81.32899475, 81.2776413 , ..., 53.45215607, 53.57727814, 53.72877121], [ 110.84020996, 110.81329346, 110.76582336, ..., 83.92819214, 84.07093048, 84.20204163], [ 129.69673157, 129.6789856 , 129.62939453, ..., 99.39131165, 99.52735138, 99.68258667]], [[ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], ..., [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ]]]) Coordinates: (3) axis (axis) <U4 'x' 'y' 'z' 'ones' array(['x', 'y', 'z', 'ones'], dtype='<U4') channel (channel) <U14 'gauche_ext' ... 'LATH' array(['gauche_ext', 'gauche_int', 'droite_int', 'droite_ext', 'avant_gauche', 'avant_droit', 'arriere_droit', 'arriere_gauche', 'ASISr', 'ASISl', 'PSISr', 'PSISl', 'STERr', 'STERl', 'STER', 'XIPH', 'T1', 'T10', 'CLAV_SC', 'CLAVm', 'CLAV_ant', 'CLAV_post', 'CLAVl', 'CLAV_AC', 'ACRO_tip', 'SCAP_AA', 'SCAPl', 'SCAPm', 'SCAP_CP', 'SCAP_RS', 'SCAP_SA', 'SCAP_IA', 'DELT', 'ARMl', 'ARMm', 'ARMp_up', 'ARMp_do', 'EPICl', 'EPICm', 'LARMm', 'LARMl', 'LARM_elb', 'LARM_ant', 'STYLr', 'STYLr_up', 'STYLu', 'WRIST', 'INDEX', 'LASTC', 'MEDH', 'LATH'], dtype='<U14') time_frame (time_frame) float64 0.0 0.01 0.02 ... 5.77 5.78 5.79 array([0. , 0.01, 0.02, ..., 5.77, 5.78, 5.79]) Attributes: (4) first_frame : 0 last_frame : 579 rate : 100.0 units : mm In this case, we have generated a 3D array with the axis , channel and time_frame dimensions. Note There are several ways to create objects in motion: by supplying data, from files of from other data structure. A more complete guide on object creation is available in the objection creation section of the documentation.","title":"Object creation"},{"location":"getting-started/#indexing","text":"Since we have labels associated with each dimension, we have several kind of indexing available with varying levels of convenience and intuitiveness. Let's see three ways to get the same data (ninth marker and first time frame).","title":"Indexing"},{"location":"getting-started/#positional-indexing","text":"Indexing directly works just like it does for numpy arrays. markers [:, 9 , 0 ] <xarray.DataArray 'markers' (axis: 4)> array([753.43908691, 75.9487381 , 187.7590332 , 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'ASISl' time_frame float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm","title":"Positional indexing"},{"location":"getting-started/#label-based-indexing","text":"Label-based indexing frees us from having to know how the data are organized. We do not have to rely on dimension order and can use them explicitly to index the data. The isel method is used when the dimension lookup is by name and the index lookup is by integer markers . isel ( channel = 9 , time_frame = 0 ) <xarray.DataArray 'markers' (axis: 4)> array([753.43908691, 75.9487381 , 187.7590332 , 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'ASISl' time_frame float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm The isel method is used when the dimension and index lookups are both by name. markers . sel ( channel = \"ASISl\" , time_frame = 0 ) <xarray.DataArray 'markers' (axis: 4)> array([753.43908691, 75.9487381 , 187.7590332 , 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'ASISl' time_frame float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm Note xarray offers extremely flexible indexing routines. For more details on indexing see the xarray documentation .","title":"Label-based indexing"},{"location":"getting-started/#metadata","text":"Biomechanical datasets are usually more than just raw numbers and have various metadata attributes. Some metadata are already filled by motion and available in the attrs Python dictionnary. markers . attrs >> {'first_frame': 0, 'last_frame': 579, 'rate': 100.0, 'units': 'mm'} They can be accessed using the standard dictionnary indexing markers . attrs [ \"rate\" ] >> 100.0 Or directly as a propriety markers . rate >> 100.0 You can assign anything you wish. markers . attrs [ \"description\" ] = \"Skin marker positions recorded in Montreal.\" markers . attrs [ \"participant_id\" ] = 12 markers . time_frame . attrs [ \"units\" ] = \"seconds\" markers <xarray.DataArray 'markers' (axis: 4, channel: 51, time_frame: 580)> array([[[ 44.16278839, 44.16666412, 44.16487122, ..., 99.22426605, 99.24201965, 99.25963593], [ 32.57229614, 32.57104111, 32.56489563, ..., 87.51286316, 87.52822876, 87.54118347], [ -93.72181702, -93.72447968, -93.72324371, ..., -41.1590271 , -41.14812851, -41.12734985], ..., [ 562.26068115, 562.41027832, 562.56695557, ..., 625.63555908, 625.98504639, 626.25811768], [ 568.24200439, 568.37792969, 568.49249268, ..., 624.18139648, 624.51190186, 624.78894043], [ 568.44470215, 568.52038574, 568.59216309, ..., 623.09222412, 623.44036865, 623.75152588]], [[-276.86193848, -276.86169434, -276.86407471, ..., -259.15292358, -259.16690063, -259.17092896], [-243.14048767, -243.14073181, -243.13331604, ..., -225.44718933, -225.45556641, -225.46226501], [ 124.78598022, 124.78731537, 124.78870392, ..., 141.820755 , 141.80741882, 141.80308533], ..., [ 638.35144043, 638.4241333 , 638.50653076, ..., 592.00372314, 592.15686035, 592.27819824], [ 626.79144287, 626.86114502, 626.90710449, ..., 584.15661621, 584.27709961, 584.38830566], [ 651.37927246, 651.45532227, 651.49957275, ..., 610.59655762, 610.72821045, 610.84472656]], [[ 675.69683838, 675.69873047, 675.6986084 , ..., 903.97650146, 903.96801758, 903.980896 ], [ 676.57452393, 676.58099365, 676.57720947, ..., 904.61694336, 904.61645508, 904.63104248], [ 674.27874756, 674.27947998, 674.28033447, ..., 902.77349854, 902.77819824, 902.78143311], ..., [ 81.34425354, 81.32899475, 81.2776413 , ..., 53.45215607, 53.57727814, 53.72877121], [ 110.84020996, 110.81329346, 110.76582336, ..., 83.92819214, 84.07093048, 84.20204163], [ 129.69673157, 129.6789856 , 129.62939453, ..., 99.39131165, 99.52735138, 99.68258667]], [[ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], ..., [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ], [ 1. , 1. , 1. , ..., 1. , 1. , 1. ]]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' * channel (channel) <U14 'gauche_ext' 'gauche_int' ... 'MEDH' 'LATH' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 ... 5.76 5.77 5.78 5.79 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12","title":"Metadata"},{"location":"getting-started/#computation","text":"","title":"Computation"},{"location":"getting-started/#arithmetic","text":"As the underlying data-structure is a numpy array, xarray data arrays work the same way you would expect if you are used to numpy. subset = markers [:, 0 , : 6 ] subset + 10 <xarray.DataArray 'markers' (axis: 4, time_frame: 6)> array([[ 54.16278839, 54.16666412, 54.16487122, 54.16558075, 54.17311096, 54.18517685], [-266.86193848, -266.86169434, -266.86407471, -266.86123657, -266.85812378, -266.85818481], [ 685.69683838, 685.69873047, 685.6986084 , 685.69775391, 685.7041626 , 685.69592285], [ 11. , 11. , 11. , 11. , 11. , 11. ]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 0.04 0.05 subset . T # transpose <xarray.DataArray 'markers' (time_frame: 6, axis: 4)> array([[ 44.16278839, -276.86193848, 675.69683838, 1. ], [ 44.16666412, -276.86169434, 675.69873047, 1. ], [ 44.16487122, -276.86407471, 675.6986084 , 1. ], [ 44.16558075, -276.86123657, 675.69775391, 1. ], [ 44.17311096, -276.85812378, 675.7041626 , 1. ], [ 44.18517685, -276.85818481, 675.69592285, 1. ]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 0.04 0.05 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 subset . mean () <xarray.DataArray 'markers' ()> array(111.00187318) Coordinates: channel <U14 'gauche_ext' subset . mean ( axis = 1 ) <xarray.DataArray 'markers' (axis: 4)> array([ 44.16969872, -276.86087545, 675.69866943, 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' We can, however, take advantage of the labels instead of axis numbers subset . mean ( dim = \"time_frame\" ) <xarray.DataArray 'markers' (axis: 4)> array([ 44.16969872, -276.86087545, 675.69866943, 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' Arithmetic operations broadcast based on dimension name. This means you don\u2019t need to insert dummy dimensions for alignment: only_first_axis = subset . sel ( axis = \"x\" ) only_first_frame = subset . isel ( time_frame = 0 ) only_first_axis <xarray.DataArray 'markers' (time_frame: 6)> array([44.16278839, 44.16666412, 44.16487122, 44.16558075, 44.17311096, 44.18517685]) Coordinates: axis <U4 'x' channel <U14 'gauche_ext' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 0.04 0.05 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 only_first_frame <xarray.DataArray 'markers' (axis: 4)> array([ 44.16278839, -276.86193848, 675.69683838, 1. ]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' time_frame float64 0.0 Attributes: first_frame: 0 last_frame: 579 rate: 100.0 units: mm description: Skin marker positions recorded in Montreal. participant_id: 12 only_first_frame + only_first_axis <xarray.DataArray 'markers' (axis: 4, time_frame: 6)> array([[ 88.32557678, 88.32945251, 88.32765961, 88.32836914, 88.33589935, 88.34796524], [-232.69915009, -232.69527435, -232.69706726, -232.69635773, -232.68882751, -232.67676163], [ 719.85962677, 719.8635025 , 719.86170959, 719.86241913, 719.86994934, 719.88201523], [ 45.16278839, 45.16666412, 45.16487122, 45.16558075, 45.17311096, 45.18517685]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 0.04 0.05 Let's compare with the sum made with numpy arrays: only_first_axis . values + only_first_axis . values >> array([88.32557678, 88.33332825, 88.32974243, 88.3311615 , 88.34622192, 88.3703537 ]) And we do not need to worry about the order of dimensions subset - subset . T <xarray.DataArray 'markers' (axis: 4, time_frame: 6)> array([[0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0.]]) Coordinates: * axis (axis) <U4 'x' 'y' 'z' 'ones' channel <U14 'gauche_ext' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 0.04 0.05 Whereas this is not possible with numpy arrays: subset . values - subset . values . T ValueError : operands could not be broadcast together with shapes ( 4 , 6 ) ( 6 , 4 ) Note xarray supports powerful shortcust for computation. For more, see the xarray documentation .","title":"Arithmetic"},{"location":"getting-started/#exploring-missing-values","text":"When we visualize some of our markers, we can realize that there are some missing values markers . sel ( axis = \"x\" , channel = \"SCAP_CP\" ) . plot . line ( x = \"time_frame\" ); Let's investigate those missing values markers_null_values = markers . sel ( axis = \"x\" ) . isnull () print ( f \"There are { markers_null_values . sum () . values } missing values\" ) >> There are 305 missing values What are the 5 markers with the most missing values? markers_null_values . sum ( dim = \"time_frame\" ) . to_series () . nlargest ( 5 ) . plot . barh (); The cumulative number of missing values can tell us when marker occlusions occur markers_null_values . sum ( \"channel\" ) . cumsum ( \"time_frame\" ) . plot (); Now that we know more about the missing values, we can use xarray for filling missing values via 1D interpolation markers_without_null = markers . interpolate_na ( dim = \"time_frame\" , method = \"cubic\" ) import matplotlib.pyplot as plt markers . sel ( axis = \"x\" , channel = \"SCAP_CP\" ) . plot . line ( x = \"time_frame\" ) markers_without_null . where ( markers . isnull ()) . sel ( axis = \"x\" , channel = \"SCAP_CP\" ) . plot . line ( x = \"time_frame\" , label = \"interpolated\" , color = \"r\" ) plt . legend ();","title":"Exploring missing values"},{"location":"getting-started/#electromyographic-pipeline","text":"Motion implements specialized functionalities commonly used in biomechanics. Let's proccess the electromyographic data contained in our c3d file. from motion import Analogs muscles = [ \"Delt_med\" , \"Delt_post\" , \"Biceps\" , \"Triceps\" , \"Trap_sup\" , \"Trap_inf\" , \"Gd_dent\" , \"Supra\" , ] emg = Analogs . from_c3d ( data_path , suffix_delimiter = \".\" , usecols = muscles ) emg . time_frame . attrs [ \"units\" ] = \"seconds\" emg . plot ( x = \"time_frame\" , col = \"channel\" , col_wrap = 4 ); emg_processed = ( emg . meca . band_pass ( freq = emg . rate , order = 2 , cutoff = [ 10 , 425 ]) . meca . center () . meca . abs () . meca . low_pass ( freq = emg . rate , order = 4 , cutoff = 5 ) . meca . normalize () ) emg_processed . plot ( x = \"time_frame\" , col = \"channel\" , col_wrap = 4 ); emg_processed . meca . to_wide_dataframe () . plot . box ( figsize = ( 8 , 4 )); fig , axes = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) emg_processed . mean ( \"channel\" ) . plot ( ax = axes [ 0 ]) axes [ 0 ] . set_title ( \"Mean EMG activation\" ) emg_processed . plot . hist ( ax = axes [ 1 ], bins = 50 ) axes [ 1 ] . set_title ( \"EMG activation distribution\" ); emg_processed . meca . to_wide_dataframe () . corr () . round ( 2 ) . style . background_gradient () . format ( \" {:.2} \" ) #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col0 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col1 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col2 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col3 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col4 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col5 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col6 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row0_col7 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col0 { background-color: #f0eaf4; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col1 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col2 { background-color: #056ead; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col3 { background-color: #046096; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col4 { background-color: #045788; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col5 { background-color: #187cb6; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col6 { background-color: #04639b; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row1_col7 { background-color: #034d79; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col0 { background-color: #ece7f2; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col1 { background-color: #056dab; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col2 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col3 { background-color: #056dab; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col4 { background-color: #04649d; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col5 { background-color: #4295c3; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col6 { background-color: #3991c1; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row2_col7 { background-color: #056aa6; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col0 { background-color: #ced0e6; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col1 { background-color: #045b8e; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col2 { background-color: #0567a1; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col3 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col4 { background-color: #046299; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col5 { background-color: #0567a2; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col6 { background-color: #0569a5; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row3_col7 { background-color: #04649d; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col0 { background-color: #dbdaeb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col1 { background-color: #045382; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col2 { background-color: #046198; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col3 { background-color: #04649d; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col4 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col5 { background-color: #187cb6; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col6 { background-color: #045585; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row4_col7 { background-color: #045f95; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col0 { background-color: #c9cee4; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col1 { background-color: #056fae; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col2 { background-color: #2685bb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col3 { background-color: #0566a0; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col4 { background-color: #0d75b3; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col5 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col6 { background-color: #2182b9; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row5_col7 { background-color: #2081b9; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col0 { background-color: #d3d4e7; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col1 { background-color: #045e94; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col2 { background-color: #2685bb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col3 { background-color: #056ba7; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col4 { background-color: #045483; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col5 { background-color: #2786bb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col6 { background-color: #023858; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row6_col7 { background-color: #0a73b2; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col0 { background-color: #fff7fb; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col1 { background-color: #03517e; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col2 { background-color: #056faf; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col3 { background-color: #056fae; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col4 { background-color: #0566a0; color: #f1f1f1; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col5 { background-color: #549cc7; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col6 { background-color: #2a88bc; color: #000000; } #T_bbf99190_79ea_11ea_b4aa_9cb6d0d1e6f9row7_col7 { background-color: #023858; color: #f1f1f1; } channel Biceps Delt_med Delt_post Gd_dent Supra Trap_inf Trap_sup Triceps channel Biceps 1.0 0.01 0.04 0.18 0.12 0.2 0.16 -0.1 Delt_med 0.01 1.0 0.77 0.87 0.9 0.76 0.85 0.91 Delt_post 0.04 0.77 1.0 0.81 0.84 0.68 0.68 0.76 Gd_dent 0.18 0.87 0.81 1.0 0.85 0.84 0.82 0.8 Supra 0.12 0.9 0.84 0.85 1.0 0.76 0.91 0.83 Trap_inf 0.2 0.76 0.68 0.84 0.76 1.0 0.73 0.65 Trap_sup 0.16 0.85 0.68 0.82 0.91 0.73 1.0 0.71 Triceps -0.1 0.91 0.76 0.8 0.83 0.65 0.71 1.0 Note For more details, see the data processing section of the documentation.","title":"Electromyographic pipeline"},{"location":"getting-started/#datasets","text":"Datasets are a usefull xarray feature to store multiple data arrays with common dimensions import xarray as xr import numpy as np trials = xr . Dataset ( { f \"trial { i } \" : Analogs . from_random_data ( size = ( 2 , 100 )) for i in range ( 10 )}, coords = { \"channel\" : [ \"biceps\" , \"triceps\" ], \"time_frame\" : np . arange ( start = 0 , stop = 1 , step = 1 / 100 ), }, ) trials <xarray.Dataset> Dimensions: (channel: 2, time_frame: 100) Coordinates: * channel (channel) <U7 'biceps' 'triceps' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 ... 0.96 0.97 0.98 0.99 Data variables: trial 0 (channel, time_frame) float64 0.6213 1.719 0.866 ... 9.505 8.115 trial 1 (channel, time_frame) float64 0.4762 -1.526 ... -19.32 -19.3 trial 2 (channel, time_frame) float64 0.3844 1.646 1.07 ... 7.246 6.323 trial 3 (channel, time_frame) float64 1.449 1.019 ... -0.7756 -0.4806 trial 4 (channel, time_frame) float64 -0.8075 -0.8303 ... 4.079 3.83 trial 5 (channel, time_frame) float64 0.4531 -1.098 ... 2.398 3.985 trial 6 (channel, time_frame) float64 -1.182 -1.656 ... -2.581 -2.192 trial 7 (channel, time_frame) float64 -2.592 -3.178 ... 15.51 15.27 trial 8 (channel, time_frame) float64 -0.3918 -1.442 ... 25.23 26.19 trial 9 (channel, time_frame) float64 -1.481 -2.139 ... 0.9357 1.831 We can still access the individual data arrays trials [ \"trial 1\" ] <xarray.DataArray 'trial 1' (channel: 2, time_frame: 100)> array([[ 0.47623852, -1.52647846, -1.96738802, -1.42058653, -2.50657205, -2.39306107, -2.38815955, -3.96941323, -6.37847912, -6.24926056, -7.50760797, -8.00105399, -7.64407712, -8.61989586, -7.61570536, -7.95773563, -9.20630194, -9.91979492, -10.52154282, -12.85969668, -13.62744403, -14.49864251, -14.43498671, -12.29269643, -13.02242288, -12.80080327, -11.67041621, -11.24812038, -9.66059498, -9.93072116, -9.74923083, -10.06229148, -11.13082113, -12.49845396, -14.237828 , -15.81771657, -16.44600458, -16.50841704, -17.42825405, -18.18971984, -16.78854839, -19.47244051, -21.28145729, -20.47938508, -18.33201631, -17.91306457, -17.21616681, -18.86668992, -18.31816582, -16.02543226, -16.64301578, -17.03206438, -17.42983904, -15.77192179, -13.98902039, -14.03357541, -13.48182332, -13.70065456, -14.33658026, -12.67135754, -13.53896994, -13.5048632 , -11.61352025, -11.60257998, -12.55901814, -13.5419003 , -14.26830579, -14.60865389, -14.2919254 , -15.89631716, -15.4440441 , -14.83500062, -16.4688737 , -17.16844731, -18.02335305, -16.197262 , -17.00791146, -16.90529553, -14.86090342, -14.14735878, -14.83183833, -13.17862687, -13.81717689, -13.38957044, -13.74157632, -13.94395614, -13.12239669, -12.81361114, -14.77627099, -15.49713256, -14.17186861, -15.13607837, -15.08852131, -16.39951157, -15.69023501, -17.48194166, -17.89564911, -18.46966648, -19.10539655, -18.86210539], [ -0.07562232, -2.13157313, -2.52565624, -3.16737923, -3.47872793, -3.39455281, -3.58575229, -4.52984777, -2.32309177, -1.22442814, -0.70818375, -1.40633073, -2.49285451, -2.37423871, -1.78166419, -1.36713184, -2.04649093, -3.05242068, -2.49374956, -2.94197875, -3.14761933, -2.26566867, -2.3992928 , -1.82904497, -2.6197727 , -4.10526706, -3.02491866, -3.52888903, -3.46395081, -3.54457552, -2.35200931, -1.83294786, -1.38317291, -1.10246625, -0.63363609, -2.59831925, -2.840266 , -4.43755361, -3.03045171, -2.3281822 , -1.85689469, -1.52041305, -0.28943751, -1.0495644 , -0.13113076, -2.76416536, -3.33035513, -3.26453514, -3.87142215, -3.50035367, -4.0517286 , -5.0390548 , -4.94376262, -3.74177457, -5.3685079 , -6.03157489, -7.19781985, -8.22252785, -8.96124884, -10.46496616, -11.84970806, -10.06281609, -10.05809348, -11.10129014, -11.39836653, -12.08978453, -11.92826824, -11.33826858, -10.33361977, -11.26835467, -13.77656503, -12.90916429, -13.53178288, -13.21946147, -13.03004045, -12.9658466 , -12.79456943, -14.6075092 , -14.92044819, -14.99394043, -17.62197044, -17.54441968, -18.32578838, -17.70853203, -16.47186952, -17.30728455, -18.76528554, -17.05165987, -17.83764451, -18.87369267, -19.35153227, -19.97146621, -19.85233526, -19.49087653, -19.83187261, -19.86927008, -18.48532508, -19.56761191, -19.32498661, -19.30402421]]) Coordinates: * channel (channel) <U7 'biceps' 'triceps' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 ... 0.96 0.97 0.98 0.99 While being able to do indexing and computation on the whole dataset trials . sel ( channel = \"biceps\" ) + 100 <xarray.Dataset> Dimensions: (time_frame: 100) Coordinates: channel <U7 'biceps' * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 ... 0.96 0.97 0.98 0.99 Data variables: trial 0 (time_frame) float64 100.6 101.7 100.9 ... 95.29 95.84 95.57 trial 1 (time_frame) float64 100.5 98.47 98.03 ... 81.53 80.89 81.14 trial 2 (time_frame) float64 100.4 101.6 101.1 ... 92.7 92.26 90.23 trial 3 (time_frame) float64 101.4 101.0 101.5 ... 102.2 101.0 100.7 trial 4 (time_frame) float64 99.19 99.17 101.0 ... 108.6 106.8 108.0 trial 5 (time_frame) float64 100.5 98.9 99.64 ... 94.22 95.92 94.42 trial 6 (time_frame) float64 98.82 98.34 97.76 ... 116.7 116.1 115.2 trial 7 (time_frame) float64 97.41 96.82 96.98 97.8 ... 97.0 97.46 98.0 trial 8 (time_frame) float64 99.61 98.56 98.87 ... 97.05 95.71 96.23 trial 9 (time_frame) float64 98.52 97.86 98.33 ... 97.85 98.54 98.53","title":"Datasets"},{"location":"getting-started/#file-io","text":"NetCDF is the recommended file format to save and share xarray object. emg . to_netcdf ( \"emg.nc\" ) xr . open_dataarray ( \"emg.nc\" ) <xarray.DataArray 'analogs' (channel: 8, time_frame: 11600)> array([[-4.021073e-05, -6.808358e-05, -8.640526e-05, ..., 4.983108e-05, 4.229912e-05, 3.812956e-05], [-1.361103e-05, -1.327931e-05, -1.273931e-05, ..., -2.546135e-05, -2.306871e-05, -1.898580e-05], [ 9.727633e-06, 9.567407e-06, 9.567407e-06, ..., 9.903105e-06, 1.118365e-05, 1.182195e-05], ..., [-9.918351e-06, -1.089098e-05, -1.067791e-05, ..., -1.001964e-06, -1.264539e-05, -1.919743e-05], [-2.296531e-06, -9.303800e-07, -1.047933e-06, ..., 1.562380e-06, 2.389907e-06, 3.062012e-06], [ 2.975303e-04, 1.551703e-04, 3.527764e-05, ..., -2.581336e-04, -4.462923e-04, -5.757854e-04]]) Coordinates: * time_frame (time_frame) timedelta64[ns] 00:00:00 ... 00:00:05.799500 * channel (channel) object 'Delt_med' 'Delt_post' ... 'Gd_dent' 'Supra' Attributes: first_frame: 0 last_frame: 11580 rate: 2000.0 units: V trials . to_netcdf ( \"trials.nc\" ) import xarray as xr xr . open_dataset ( \"trials.nc\" ) <xarray.Dataset> Dimensions: (channel: 2, time_frame: 100) Coordinates: * time_frame (time_frame) float64 0.0 0.01 0.02 0.03 ... 0.96 0.97 0.98 0.99 * channel (channel) object 'biceps' 'triceps' Data variables: trial 0 (channel, time_frame) float64 ... trial 1 (channel, time_frame) float64 ... trial 2 (channel, time_frame) float64 ... trial 3 (channel, time_frame) float64 ... trial 4 (channel, time_frame) float64 ... trial 5 (channel, time_frame) float64 ... trial 6 (channel, time_frame) float64 ... trial 7 (channel, time_frame) float64 ... trial 8 (channel, time_frame) float64 ... trial 9 (channel, time_frame) float64 ... Motion implements function to read various file format commonly used in biomechanics such as c3d , csv , xlsx , sto , trc and mot . Users can also write Matlab and csv files. emg . meca . to_matlab ( \"emg.mat\" ) emg . meca . to_csv ( \"emg.csv\" )","title":"File IO"},{"location":"object-creation/","text":"Subset of api exploration viz From scratch From files From other data structures","title":"Object creation"},{"location":"object-creation/#from-scratch","text":"","title":"From scratch"},{"location":"object-creation/#from-files","text":"","title":"From files"},{"location":"object-creation/#from-other-data-structures","text":"","title":"From other data structures"},{"location":"overview/","text":"Working with labelled multi-dimensional arrays Motion introduces a concise interface to read, analyse, visualize and plot biomechanical data. Such data are typically multi-dimensional , such as joint angles with associated axes, degrees of freedom and time frames. NumPy is the fundamental package for multi-dimensional computing with Python. While NumPy provides an efficient data structure and an intuitive interface, biomechanical datasets are usually more than just raw numbers and have labels which encode how the array values map to different dimensions such as axes, degrees of freedom, channels or time frames. Motion is build upon and extend the core strengths of xarray , which keeps tracks of labels and provides a powerful and concise interface which makes it easy to: Apply any operations over dimensions by name ( array.sum(dim=\"time_frame\") ) instead of arbitrary axis ( array.sum(axis=2) ). Select values by labels ( array.sel(axis=\"x\") or emg.sel(channel=\"biceps\") ) Vectorize computation across multiple dimensions. Use the split-apply-combine paradigm, for example: emg.groupby(\"channel\").mean() or any custom function: emg.groupby('channel').map(lambda x: x - x.mean()) ). Keep track of metadata in the array.attrs Python dictionary ( array.attrs[\"rate\"] ). Extent the xarray interface with domain specific functionalities with custom accessors on xarray objects. In motion, the biomechanics specific functions are registered under the meca name space ( array.meca ). Working with labels makes it much easier to work with multi-dimensional arrays as you do not have to keep track of the order of the dimensions or insert dummy dimensions to align arrays. This allows for a more intuitive, more concise, and less error-prone developer experience. Note As the underlying data-structure is still a NumPy array, NumPy functions ( np.abs(array) ) and indexing ( array[:, 0, 1] ) work out of the box. By leveraging xarray data structures, Motion inherit their features such as built-in interpolation , computation , GroupBy , data wrangling , parallel computing and plotting . Extending xarray Xarray is designed as a general purpose library and tries to avoid including domain specific functionalities. But inevitably, the need for more domain specific logic arises. That's why motion and dozens of other scientific packages extend xarray. Extending data structure in Python is usually achieved with class inheritance. However inheritance is not very robust for large class such as xarray.DataArray . To add domain specific functionality, motion follows xarray developpers' recommendations and use a custom \"accessor\". To read why, you can check out the xarray documentation . Core functionalities Motion has four data structures build upon xarray . Each structure is associated with a specific biomechanical data type and have specialized functionalities: Class Dimensions Description Analogs (\"channel\", \"time_frame\") Generic signals such as EMGs, force signals or any other analog signal Angles (\"axis\", \"channel\", \"time_frame\") Joint angles Markers (\"axis\", \"channel\", \"time_frame\") Skin marker positions Rototrans (\"row\", \"col\", \"time_frame\") Rototranslation matrix There is technically dozens of functions in motion, but you can actually bucket then into two specific categories: Object creation with the from_* methods. For example, if you want to define a marker array from a csv file: markers = Markers.from_csv(...) . Data processing with the meca array accessor. To low-pass filter our previous markers: markers.meca.low_pass(...) . Note Check out the API reference to see the parameters, use cases and examples associated with each function. You can explore all of motion's public API on the following interactive visualization. Hover the mouse over any bloc to display a short description with some examples and click to jump to the corresponding API reference. drawMatrix(\"angles-matrix\", [3, 2, 5], [\"axes\", \"degrees of freedom\", \"time frames\"], \"Joint angles\"); drawApi(\"api-exploration\");","title":"Overview"},{"location":"overview/#working-with-labelled-multi-dimensional-arrays","text":"Motion introduces a concise interface to read, analyse, visualize and plot biomechanical data. Such data are typically multi-dimensional , such as joint angles with associated axes, degrees of freedom and time frames. NumPy is the fundamental package for multi-dimensional computing with Python. While NumPy provides an efficient data structure and an intuitive interface, biomechanical datasets are usually more than just raw numbers and have labels which encode how the array values map to different dimensions such as axes, degrees of freedom, channels or time frames. Motion is build upon and extend the core strengths of xarray , which keeps tracks of labels and provides a powerful and concise interface which makes it easy to: Apply any operations over dimensions by name ( array.sum(dim=\"time_frame\") ) instead of arbitrary axis ( array.sum(axis=2) ). Select values by labels ( array.sel(axis=\"x\") or emg.sel(channel=\"biceps\") ) Vectorize computation across multiple dimensions. Use the split-apply-combine paradigm, for example: emg.groupby(\"channel\").mean() or any custom function: emg.groupby('channel').map(lambda x: x - x.mean()) ). Keep track of metadata in the array.attrs Python dictionary ( array.attrs[\"rate\"] ). Extent the xarray interface with domain specific functionalities with custom accessors on xarray objects. In motion, the biomechanics specific functions are registered under the meca name space ( array.meca ). Working with labels makes it much easier to work with multi-dimensional arrays as you do not have to keep track of the order of the dimensions or insert dummy dimensions to align arrays. This allows for a more intuitive, more concise, and less error-prone developer experience. Note As the underlying data-structure is still a NumPy array, NumPy functions ( np.abs(array) ) and indexing ( array[:, 0, 1] ) work out of the box. By leveraging xarray data structures, Motion inherit their features such as built-in interpolation , computation , GroupBy , data wrangling , parallel computing and plotting . Extending xarray Xarray is designed as a general purpose library and tries to avoid including domain specific functionalities. But inevitably, the need for more domain specific logic arises. That's why motion and dozens of other scientific packages extend xarray. Extending data structure in Python is usually achieved with class inheritance. However inheritance is not very robust for large class such as xarray.DataArray . To add domain specific functionality, motion follows xarray developpers' recommendations and use a custom \"accessor\". To read why, you can check out the xarray documentation .","title":"Working with labelled multi-dimensional arrays"},{"location":"overview/#core-functionalities","text":"Motion has four data structures build upon xarray . Each structure is associated with a specific biomechanical data type and have specialized functionalities: Class Dimensions Description Analogs (\"channel\", \"time_frame\") Generic signals such as EMGs, force signals or any other analog signal Angles (\"axis\", \"channel\", \"time_frame\") Joint angles Markers (\"axis\", \"channel\", \"time_frame\") Skin marker positions Rototrans (\"row\", \"col\", \"time_frame\") Rototranslation matrix There is technically dozens of functions in motion, but you can actually bucket then into two specific categories: Object creation with the from_* methods. For example, if you want to define a marker array from a csv file: markers = Markers.from_csv(...) . Data processing with the meca array accessor. To low-pass filter our previous markers: markers.meca.low_pass(...) . Note Check out the API reference to see the parameters, use cases and examples associated with each function. You can explore all of motion's public API on the following interactive visualization. Hover the mouse over any bloc to display a short description with some examples and click to jump to the corresponding API reference. drawMatrix(\"angles-matrix\", [3, 2, 5], [\"axes\", \"degrees of freedom\", \"time frames\"], \"Joint angles\"); drawApi(\"api-exploration\");","title":"Core functionalities"},{"location":"api/analogs/","text":"analogs.py Analogs __new__ ( cls , data = None , channels = None , time_frames = None , * args , ** kwargs ) special staticmethod Analogs DataArray with channel and time_frame dimensions used for generic signals such as EMGs, force signals or any other analog signal. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None args Positional argument(s) to be passed to xarray.DataArray () kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To instantiate an Analogs with 4 channels and 100 frames filled with some random data: import numpy as np from motion import Analogs n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_channels , n_frames )) analogs = Analogs ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] analogs = Analogs ( data , channels = names ) And an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) analogs = Analogs ( data , channels = names , time_frames = time_frames ) Note Calling Analogs() generate an empty array. Source code in motion/analogs.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , channels : Optional [ list ] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Analogs DataArray with `channel` and `time_frame` dimensions used for generic signals such as EMGs, force signals or any other analog signal. Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To instantiate an `Analogs` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from motion import Analogs n_channels = 4 n_frames = 100 data = np.random.random(size=(n_channels, n_frames)) analogs = Analogs(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] analogs = Analogs(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) analogs = Analogs(data, channels=names, time_frames=time_frames) ``` !!! note Calling `Analogs()` generate an empty array. \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 )) if channels is not None : coords [ \"channel\" ] = channels if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"channel\" , \"time_frame\" ), coords = coords , name = \"analogs\" , * args , ** kwargs , ) from_c3d ( filename , usecols = None , prefix_delimiter = None , suffix_delimiter = None , attrs = None ) classmethod Analogs DataArray from a c3d file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this c3d file , type: from motion import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Voltage.1\" , \"Voltage.2\" , \"Voltage.3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Voltage.1\" and you specify suffix_delimiter=\".\" , you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": channels = [ \"1\" , \"2\" , \"3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels , prefix_delimiter = \".\" ) Source code in motion/analogs.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a c3d file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this c3d file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers_analogs.c3d), type: ```python from motion import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Voltage.1\", \"Voltage.2\", \"Voltage.3\"] analogs = Analogs.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Voltage.1\"` and you specify `suffix_delimiter=\".\"`, you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": ```python channels = [\"1\", \"2\", \"3\"] analogs = Analogs.from_c3d(data_path, usecols=channels, prefix_delimiter=\".\") ``` \"\"\" return read . read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs ) from_csv ( filename , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , last_column_to_remove = None , prefix_delimiter = None , suffix_delimiter = None , skiprows = None , pandas_kwargs = None , attrs = None ) classmethod Analogs DataArray from a csv file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this csv file , type: from motion import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"IM EMG1\" , \"IM EMG2\" , \"IM EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"IM EMG1\" and you specify suffix_delimiter=\" \" , you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": channels = [ \"EMG1\" , \"EMG2\" , \"EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels , suffix_delimiter = \" \" , ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in motion/analogs.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a csv file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this csv file](https://github.com/romainmartinez/motion/blob/master/tests/data/analogs.csv), type: ```python from motion import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs.from_csv(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"IM EMG1\", \"IM EMG2\", \"IM EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"IM EMG1\"` and you specify `suffix_delimiter=\" \"`, you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": ```python channels = [\"EMG1\", \"EMG2\", \"EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels, suffix_delimiter=\" \", ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , ) from_excel ( filename , sheet_name = 0 , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , last_column_to_remove = None , prefix_delimiter = None , suffix_delimiter = None , skiprows = None , pandas_kwargs = None , attrs = None ) classmethod Analogs DataArray from a excel file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this excel file , type: from motion import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"A\" ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in motion/analogs.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a excel file. Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this excel file](https://github.com/romainmartinez/motion/blob/master/tests/data/analogs.xlsx), type: ```python from motion import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs.from_excel(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"A\"] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , sheet_name , ) from_mot ( filename , end_header = None , ** kwargs ) classmethod Analogs DataArray from a mot file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined. None kwargs Keyword arguments to be passed to from_csv {} Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this mot file , type: from motion import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs . from_mot ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"elbow_flexion\" , \"pro_sup\" ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Source code in motion/analogs.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 @classmethod def from_mot ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a mot file. Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined. kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this mot file](https://github.com/romainmartinez/motion/blob/master/tests/data/inverse_kin.mot), type: ```python from motion import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs.from_mot(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"elbow_flexion\", \"pro_sup\"] analogs = Analogs.from_mot(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_mot(data_path, usecols=channels) ``` \"\"\" return read . read_sto_or_mot ( cls , filename , end_header , ** kwargs ) from_random_data ( distribution = 'normal' , size = ( 10 , 100 ), * args , ** kwargs ) classmethod Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (10, 100) args Positional argument(s) to be passed to numpy.random. distribution () kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random Analogs xarray.DataArray sampled from a given distribution Example To instantiate an Analogs with some random data sampled from a normal distribution: from motion import Analogs n_channels = 10 n_frames = 100 size = n_channels , n_frames analogs = Analogs . from_random_data ( size = size ) You can choose any distribution available in numpy.random : analogs = Analogs . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in motion/analogs.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random Analogs `xarray.DataArray` sampled from a given distribution !!! example To instantiate an `Analogs` with some random data sampled from a normal distribution: ```python from motion import Analogs n_channels = 10 n_frames = 100 size = n_channels, n_frames analogs = Analogs.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python analogs = Analogs.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Analogs ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) from_sto ( filename , end_header = None , ** kwargs ) classmethod Analogs DataArray from a sto file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined None kwargs Keyword arguments to be passed to from_csv {} Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this sto file , type: from motion import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs . from_sto ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"shoulder_plane_moment\" , \"shoulder_ele_moment\" ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Source code in motion/analogs.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 @classmethod def from_sto ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a sto file. Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this sto file](https://github.com/romainmartinez/motion/blob/master/tests/data/inverse_dyn.sto), type: ```python from motion import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs.from_sto(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"shoulder_plane_moment\", \"shoulder_ele_moment\"] analogs = Analogs.from_sto(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_sto(data_path, usecols=channels) ``` \"\"\" return read . read_sto_or_mot ( cls , filename , end_header , ** kwargs )","title":"Analogs"},{"location":"api/analogs/#analogspy","text":"","title":"analogs.py"},{"location":"api/analogs/#motion.analogs","text":"","title":"motion.analogs"},{"location":"api/analogs/#motion.analogs.Analogs","text":"","title":"Analogs"},{"location":"api/analogs/#motion.analogs.Analogs.__new__","text":"Analogs DataArray with channel and time_frame dimensions used for generic signals such as EMGs, force signals or any other analog signal. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None args Positional argument(s) to be passed to xarray.DataArray () kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To instantiate an Analogs with 4 channels and 100 frames filled with some random data: import numpy as np from motion import Analogs n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_channels , n_frames )) analogs = Analogs ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] analogs = Analogs ( data , channels = names ) And an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) analogs = Analogs ( data , channels = names , time_frames = time_frames ) Note Calling Analogs() generate an empty array. Source code in motion/analogs.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , channels : Optional [ list ] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Analogs DataArray with `channel` and `time_frame` dimensions used for generic signals such as EMGs, force signals or any other analog signal. Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To instantiate an `Analogs` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from motion import Analogs n_channels = 4 n_frames = 100 data = np.random.random(size=(n_channels, n_frames)) analogs = Analogs(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] analogs = Analogs(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) analogs = Analogs(data, channels=names, time_frames=time_frames) ``` !!! note Calling `Analogs()` generate an empty array. \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 )) if channels is not None : coords [ \"channel\" ] = channels if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"channel\" , \"time_frame\" ), coords = coords , name = \"analogs\" , * args , ** kwargs , )","title":"__new__()"},{"location":"api/analogs/#motion.analogs.Analogs.from_c3d","text":"Analogs DataArray from a c3d file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this c3d file , type: from motion import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Voltage.1\" , \"Voltage.2\" , \"Voltage.3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Voltage.1\" and you specify suffix_delimiter=\".\" , you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": channels = [ \"1\" , \"2\" , \"3\" ] analogs = Analogs . from_c3d ( data_path , usecols = channels , prefix_delimiter = \".\" ) Source code in motion/analogs.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a c3d file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this c3d file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers_analogs.c3d), type: ```python from motion import Analogs data_path = \"./tests/data/markers_analogs.c3d\" analogs = Analogs.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Voltage.1\", \"Voltage.2\", \"Voltage.3\"] analogs = Analogs.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Voltage.1\"` and you specify `suffix_delimiter=\".\"`, you will select \"Voltage\". Similarly, if you specify `prefix_delimiter=\".\": ```python channels = [\"1\", \"2\", \"3\"] analogs = Analogs.from_c3d(data_path, usecols=channels, prefix_delimiter=\".\") ``` \"\"\" return read . read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs )","title":"from_c3d()"},{"location":"api/analogs/#motion.analogs.Analogs.from_csv","text":"Analogs DataArray from a csv file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this csv file , type: from motion import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"IM EMG1\" , \"IM EMG2\" , \"IM EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"IM EMG1\" and you specify suffix_delimiter=\" \" , you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": channels = [ \"EMG1\" , \"EMG2\" , \"EMG3\" ] analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels , suffix_delimiter = \" \" , ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_csv ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in motion/analogs.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a csv file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this csv file](https://github.com/romainmartinez/motion/blob/master/tests/data/analogs.csv), type: ```python from motion import Analogs data_path = \"./tests/data/analogs.csv\" analogs = Analogs.from_csv(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"IM EMG1\", \"IM EMG2\", \"IM EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"IM EMG1\"` and you specify `suffix_delimiter=\" \"`, you will select \"IM\". Similarly, if you specify `prefix_delimiter=\" \": ```python channels = [\"EMG1\", \"EMG2\", \"EMG3\"] analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=2, usecols=channels, suffix_delimiter=\" \", ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_csv( data_path, header=3, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , )","title":"from_csv()"},{"location":"api/analogs/#motion.analogs.Analogs.from_excel","text":"Analogs DataArray from a excel file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this excel file , type: from motion import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"A\" ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 2 , usecols = channels ) It is also possible to specify a column containing the time vector: analogs = Analogs . from_excel ( data_path , header = 3 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in motion/analogs.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Analogs DataArray from a excel file. Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz'] header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this excel file](https://github.com/romainmartinez/motion/blob/master/tests/data/analogs.xlsx), type: ```python from motion import Analogs data_path = \"./tests/data/analogs.xlsx\" analogs = Analogs.from_excel(data_path, header=3, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"A\"] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=2, usecols=channels ) ``` It is also possible to specify a column containing the time vector: ```python analogs = Analogs.from_excel( data_path, header=3, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , sheet_name , )","title":"from_excel()"},{"location":"api/analogs/#motion.analogs.Analogs.from_mot","text":"Analogs DataArray from a mot file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined. None kwargs Keyword arguments to be passed to from_csv {} Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this mot file , type: from motion import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs . from_mot ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"elbow_flexion\" , \"pro_sup\" ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_mot ( data_path , usecols = channels ) Source code in motion/analogs.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 @classmethod def from_mot ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a mot file. Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined. kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this mot file](https://github.com/romainmartinez/motion/blob/master/tests/data/inverse_kin.mot), type: ```python from motion import Analogs data_path = \"./tests/data/inverse_kin.mot\" analogs = Analogs.from_mot(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"elbow_flexion\", \"pro_sup\"] analogs = Analogs.from_mot(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_mot(data_path, usecols=channels) ``` \"\"\" return read . read_sto_or_mot ( cls , filename , end_header , ** kwargs )","title":"from_mot()"},{"location":"api/analogs/#motion.analogs.Analogs.from_random_data","text":"Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (10, 100) args Positional argument(s) to be passed to numpy.random. distribution () kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random Analogs xarray.DataArray sampled from a given distribution Example To instantiate an Analogs with some random data sampled from a normal distribution: from motion import Analogs n_channels = 10 n_frames = 100 size = n_channels , n_frames analogs = Analogs . from_random_data ( size = size ) You can choose any distribution available in numpy.random : analogs = Analogs . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in motion/analogs.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random Analogs `xarray.DataArray` sampled from a given distribution !!! example To instantiate an `Analogs` with some random data sampled from a normal distribution: ```python from motion import Analogs n_channels = 10 n_frames = 100 size = n_channels, n_frames analogs = Analogs.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python analogs = Analogs.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Analogs ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) )","title":"from_random_data()"},{"location":"api/analogs/#motion.analogs.Analogs.from_sto","text":"Analogs DataArray from a sto file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required end_header Optional[bool] Index where endheader appears (0 indexed). If not provided, the index is automatically determined None kwargs Keyword arguments to be passed to from_csv {} Returns: Type Description DataArray Analogs xarray.DataArray with the specified data and coordinates Example To read this sto file , type: from motion import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs . from_sto ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"shoulder_plane_moment\" , \"shoulder_ele_moment\" ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] analogs = Analogs . from_sto ( data_path , usecols = channels ) Source code in motion/analogs.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 @classmethod def from_sto ( cls , filename : Union [ str , Path ], end_header : Optional [ bool ] = None , ** kwargs ) -> xr . DataArray : \"\"\" Analogs DataArray from a sto file. Arguments: filename: Any valid string path end_header: Index where `endheader` appears (0 indexed). If not provided, the index is automatically determined kwargs: Keyword arguments to be passed to `from_csv` Returns: Analogs `xarray.DataArray` with the specified data and coordinates !!! example To read [this sto file](https://github.com/romainmartinez/motion/blob/master/tests/data/inverse_dyn.sto), type: ```python from motion import Analogs data_path = \"./tests/data/inverse_dyn.sto\" analogs = Analogs.from_sto(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"shoulder_plane_moment\", \"shoulder_ele_moment\"] analogs = Analogs.from_sto(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] analogs = Analogs.from_sto(data_path, usecols=channels) ``` \"\"\" return read . read_sto_or_mot ( cls , filename , end_header , ** kwargs )","title":"from_sto()"},{"location":"api/angles/","text":"angles.py Angles __new__ ( cls , data = None , time_frames = None , * args , ** kwargs ) special staticmethod Angles DataArray with axis , channel and time_frame dimensions used for joint angles. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None args Positional argument(s) to be passed to xarray.DataArray () kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Angles xarray.DataArray with the specified data and coordinates Example To instantiate an Angles 4 by 4 and 100 frames filled with some random data: import numpy as np from motion import Angles n_axis = 3 n_channel = 3 n_frames = 100 data = np . random . random ( size = ( n_axis , n_channel , n_frames )) angles = Angles ( data ) You can an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) angles = Angles ( data , time_frames = time_frames ) Note Calling Angles() generate an empty array. Source code in motion/angles.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Angles DataArray with `axis`, `channel` and `time_frame` dimensions used for joint angles. Arguments: data: Array to be passed to xarray.DataArray time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Angles `xarray.DataArray` with the specified data and coordinates !!! example To instantiate an `Angles` 4 by 4 and 100 frames filled with some random data: ```python import numpy as np from motion import Angles n_axis = 3 n_channel = 3 n_frames = 100 data = np.random.random(size=(n_axis, n_channel, n_frames)) angles = Angles(data) ``` You can an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) angles = Angles(data, time_frames=time_frames) ``` !!! note Calling `Angles()` generate an empty array. \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"axis\" , \"channel\" , \"time_frame\" ), coords = coords , name = \"angles\" , * args , ** kwargs , ) from_random_data ( distribution = 'normal' , size = ( 3 , 10 , 100 ), * args , ** kwargs ) classmethod Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 10, 100) args Positional argument(s) to be passed to numpy.random. distribution () kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random angles xarray.DataArray sampled from a given distribution Example To instantiate an Angles with some random data sampled from a normal distribution: from motion import Angles n_frames = 100 size = 10 , 10 , n_frames angles = Angles . from_random_data ( size = size ) You can choose any distribution available in numpy.random : angles = Angles . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in motion/angles.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random angles `xarray.DataArray` sampled from a given distribution !!! example To instantiate an `Angles` with some random data sampled from a normal distribution: ```python from motion import Angles n_frames = 100 size = 10, 10, n_frames angles = Angles.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python angles = Angles.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Angles ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) from_rototrans ( rototrans , angle_sequence ) classmethod Angles DataArray from a rototranslation matrix and specified angle sequence. Parameters: Name Type Description Default rototrans DataArray Rototranslation matrix created with motion.Rototrans() required angle_sequence str Euler sequence of angles. Valid values are all permutations of \"xyz\" required Returns: Type Description DataArray Angles xarray.DataArray from the specified rototrans and angles sequence Example To get the euler angles from a random rototranslation matrix with a given angle sequence type: from motion import Angles , Rototrans size = ( 4 , 4 , 100 ) rt = Rototrans . from_random_data ( size = size ) angles_sequence = \"xyz\" angles = Angles . from_rototrans ( rototrans = rt , angle_sequence = angles_sequence ) Source code in motion/angles.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 @classmethod def from_rototrans ( cls , rototrans : xr . DataArray , angle_sequence : str ) -> xr . DataArray : \"\"\" Angles DataArray from a rototranslation matrix and specified angle sequence. Arguments: rototrans: Rototranslation matrix created with motion.Rototrans() angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" Returns: Angles `xarray.DataArray` from the specified rototrans and angles sequence !!! example To get the euler angles from a random rototranslation matrix with a given angle sequence type: ```python from motion import Angles, Rototrans size = (4, 4, 100) rt = Rototrans.from_random_data(size=size) angles_sequence = \"xyz\" angles = Angles.from_rototrans(rototrans=rt, angle_sequence=angles_sequence) ``` \"\"\" return angles . angles_from_rototrans ( cls , rototrans , angle_sequence )","title":"Angles"},{"location":"api/angles/#anglespy","text":"","title":"angles.py"},{"location":"api/angles/#motion.angles","text":"","title":"motion.angles"},{"location":"api/angles/#motion.angles.Angles","text":"","title":"Angles"},{"location":"api/angles/#motion.angles.Angles.__new__","text":"Angles DataArray with axis , channel and time_frame dimensions used for joint angles. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None args Positional argument(s) to be passed to xarray.DataArray () kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Angles xarray.DataArray with the specified data and coordinates Example To instantiate an Angles 4 by 4 and 100 frames filled with some random data: import numpy as np from motion import Angles n_axis = 3 n_channel = 3 n_frames = 100 data = np . random . random ( size = ( n_axis , n_channel , n_frames )) angles = Angles ( data ) You can an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) angles = Angles ( data , time_frames = time_frames ) Note Calling Angles() generate an empty array. Source code in motion/angles.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Angles DataArray with `axis`, `channel` and `time_frame` dimensions used for joint angles. Arguments: data: Array to be passed to xarray.DataArray time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Angles `xarray.DataArray` with the specified data and coordinates !!! example To instantiate an `Angles` 4 by 4 and 100 frames filled with some random data: ```python import numpy as np from motion import Angles n_axis = 3 n_channel = 3 n_frames = 100 data = np.random.random(size=(n_axis, n_channel, n_frames)) angles = Angles(data) ``` You can an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) angles = Angles(data, time_frames=time_frames) ``` !!! note Calling `Angles()` generate an empty array. \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"axis\" , \"channel\" , \"time_frame\" ), coords = coords , name = \"angles\" , * args , ** kwargs , )","title":"__new__()"},{"location":"api/angles/#motion.angles.Angles.from_random_data","text":"Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 10, 100) args Positional argument(s) to be passed to numpy.random. distribution () kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random angles xarray.DataArray sampled from a given distribution Example To instantiate an Angles with some random data sampled from a normal distribution: from motion import Angles n_frames = 100 size = 10 , 10 , n_frames angles = Angles . from_random_data ( size = size ) You can choose any distribution available in numpy.random : angles = Angles . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in motion/angles.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random angles `xarray.DataArray` sampled from a given distribution !!! example To instantiate an `Angles` with some random data sampled from a normal distribution: ```python from motion import Angles n_frames = 100 size = 10, 10, n_frames angles = Angles.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python angles = Angles.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Angles ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) )","title":"from_random_data()"},{"location":"api/angles/#motion.angles.Angles.from_rototrans","text":"Angles DataArray from a rototranslation matrix and specified angle sequence. Parameters: Name Type Description Default rototrans DataArray Rototranslation matrix created with motion.Rototrans() required angle_sequence str Euler sequence of angles. Valid values are all permutations of \"xyz\" required Returns: Type Description DataArray Angles xarray.DataArray from the specified rototrans and angles sequence Example To get the euler angles from a random rototranslation matrix with a given angle sequence type: from motion import Angles , Rototrans size = ( 4 , 4 , 100 ) rt = Rototrans . from_random_data ( size = size ) angles_sequence = \"xyz\" angles = Angles . from_rototrans ( rototrans = rt , angle_sequence = angles_sequence ) Source code in motion/angles.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 @classmethod def from_rototrans ( cls , rototrans : xr . DataArray , angle_sequence : str ) -> xr . DataArray : \"\"\" Angles DataArray from a rototranslation matrix and specified angle sequence. Arguments: rototrans: Rototranslation matrix created with motion.Rototrans() angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" Returns: Angles `xarray.DataArray` from the specified rototrans and angles sequence !!! example To get the euler angles from a random rototranslation matrix with a given angle sequence type: ```python from motion import Angles, Rototrans size = (4, 4, 100) rt = Rototrans.from_random_data(size=size) angles_sequence = \"xyz\" angles = Angles.from_rototrans(rototrans=rt, angle_sequence=angles_sequence) ``` \"\"\" return angles . angles_from_rototrans ( cls , rototrans , angle_sequence )","title":"from_rototrans()"},{"location":"api/dataarray_accessor/","text":"dataarray_accessor.py DataArrayAccessor Meca DataArray accessor used for processing or file writing. abs ( self ) Calculate the absolute value element-wise. Returns: Type Description DataArray A xarray.DataArray containing the absolute of each element Example To compute the absolute value of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . abs () Source code in motion/dataarray_accessor.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def abs ( self ) -> xr . DataArray : \"\"\" Calculate the absolute value element-wise. Returns: A `xarray.DataArray` containing the absolute of each element !!! example To compute the absolute value of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.abs() ``` \"\"\" return algebra . abs_ ( self . _obj ) band_pass ( self , freq , order , cutoff ) Band-pass Butterworth filter. Parameters: Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required Returns: Type Description DataArray A band-pass filtered xarray.DataArray Example To band-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 10-200Hz: import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz band_pass = analogs . meca . band_pass ( freq = freq , order = 2 , cutoff = [ 10 , 200 ]) analogs . plot ( label = \"raw\" ) band_pass . plot ( label = \"band-pass @ 10-200Hz\" ) plt . legend () plt . show () Source code in motion/dataarray_accessor.py 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 def band_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ list , tuple , np . array ] ) -> xr . DataArray : \"\"\" Band-pass Butterworth filter. Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) Returns: A band-pass filtered `xarray.DataArray` !!! example To band-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 10-200Hz: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz band_pass = analogs.meca.band_pass(freq=freq, order=2, cutoff=[10, 200]) analogs.plot(label=\"raw\") band_pass.plot(label=\"band-pass @ 10-200Hz\") plt.legend() plt.show() ``` ![band_pass](../../images/api/band_pass.svg) \"\"\" return filter . band_pass ( self . _obj , freq , order , cutoff ) band_stop ( self , freq , order , cutoff ) Band-stop Butterworth filter. Parameters: Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required Returns: Type Description DataArray A band-stop filtered xarray.DataArray Example To band-stop any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 40-60Hz: import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz band_stop = analogs . meca . band_stop ( freq = freq , order = 2 , cutoff = [ 40 , 60 ]) analogs . plot ( label = \"raw\" ) band_stop . plot ( label = \"band-stop @ 40-60Hz\" ) plt . legend () plt . show () Source code in motion/dataarray_accessor.py 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 def band_stop ( self , freq : Union [ int , float ], order : int , cutoff : Union [ list , tuple , np . array ] ) -> xr . DataArray : \"\"\" Band-stop Butterworth filter. Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) Returns: A band-stop filtered `xarray.DataArray` !!! example To band-stop any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 40-60Hz: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz band_stop = analogs.meca.band_stop(freq=freq, order=2, cutoff=[40, 60]) analogs.plot(label=\"raw\") band_stop.plot(label=\"band-stop @ 40-60Hz\") plt.legend() plt.show() ``` ![band_stop](../../images/api/band_stop.svg) \"\"\" return filter . band_stop ( self . _obj , freq , order , cutoff ) center ( self , mu = None ) Center an array (i.e., subtract the mean). Parameters: Name Type Description Default mu Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] mean of the signal to subtract. If not provided, takes the mean along the time_frame axis None Returns: Type Description DataArray a xarray.DataArray containing the root-mean-square of the matrix Example To center any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import numpy as np from motion import Analogs random_data = np . random . uniform ( low = 2 , high = 4 , size = ( 1 , 100 )) analogs = Analogs ( random_data ) centered = analogs . meca . center () This will substract the mean of the signal by default. The previous random signal was sampled from a uniform distribution from 2 and 4 (mean around 3). When centered, the signal is now center around 0 (mean around 0). import matplotlib.pyplot as plt analogs . plot ( label = \"raw\" ) centered . plot ( label = \"centered\" ) plt . legend () plt . show () Source code in motion/dataarray_accessor.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 def center ( self , mu : Union [ xr . DataArray , np . array , float , int ] = None ) -> xr . DataArray : \"\"\" Center an array (i.e., subtract the mean). Arguments: mu: mean of the signal to subtract. If not provided, takes the mean along the time_frame axis Returns: a `xarray.DataArray` containing the root-mean-square of the matrix !!! example To center any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import numpy as np from motion import Analogs random_data = np.random.uniform(low=2, high=4, size=(1, 100)) analogs = Analogs(random_data) centered = analogs.meca.center() ``` This will substract the mean of the signal by default. The previous random signal was sampled from a uniform distribution from 2 and 4 (mean around 3). When centered, the signal is now center around 0 (mean around 0). ```python import matplotlib.pyplot as plt analogs.plot(label=\"raw\") centered.plot(label=\"centered\") plt.legend() plt.show() ``` ![center](../../images/api/center.svg) \"\"\" return algebra . center ( self . _obj , mu ) detect_onset ( self , threshold , n_above = 1 , n_below = 0 , threshold2 = None , n_above2 = 1 ) Detects onset based on amplitude threshold. Parameters: Name Type Description Default threshold Union[float, int] minimum amplitude to detect required n_above int minimum number of continuous samples >= threshold to detect 1 n_below int minimum number of continuous samples below threshold that will be ignored in the detection of x >= threshold 0 threshold2 int minimum amplitude of n_above2 values in x to detect None n_above2 int minimum number of samples >= threshold2 to detect 1 Note You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns: Type Description <built-in function array> inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events Example To detect the onsets of any one-dimensional xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt import numpy as np import scipy.signal as sig from motion import Analogs # simulate fake ecg data rr = 2.5 # rr time in seconds freq = 100 # sampling rate pqrst = sig . resample ( sig . wavelets . daub ( 10 ), int ( rr * freq )) ecg = np . concatenate ([ pqrst , pqrst , pqrst ]) . reshape ( 1 , - 1 ) analogs = Analogs ( ecg ) analogs . plot () onsets = analogs . sel ( channel = 0 ) . meca . detect_onset ( threshold = analogs . mean (), # mean of the signal n_above = freq / 2 , # we want at least 1/2 second above the threshold n_below = freq / 2 , # we accept point below threshold for 1/2 second ) for ( start , end ) in onsets : plt . axvline ( x = start , color = \"g\" ) plt . axvline ( x = end , color = \"r\" ) plt . show () Warning detect_onset works only for 1-dimensional data. For example, you can select a dimension using analogs.sel(channel='EMG1') or analogs.isel(channel=0) . Source code in motion/dataarray_accessor.py 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 def detect_onset ( self , threshold : Union [ float , int ], n_above : int = 1 , n_below : int = 0 , threshold2 : int = None , n_above2 : int = 1 , ) -> np . array : \"\"\" Detects onset based on amplitude threshold. Arguments: threshold: minimum amplitude to detect n_above: minimum number of continuous samples >= `threshold` to detect n_below: minimum number of continuous samples below `threshold` that will be ignored in the detection of `x` >= `threshold` threshold2: minimum amplitude of `n_above2` values in `x` to detect n_above2: minimum number of samples >= `threshold2` to detect Note: You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns: inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events !!! example To detect the onsets of any __one-dimensional__ `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt import numpy as np import scipy.signal as sig from motion import Analogs # simulate fake ecg data rr = 2.5 # rr time in seconds freq = 100 # sampling rate pqrst = sig.resample(sig.wavelets.daub(10), int(rr * freq)) ecg = np.concatenate([pqrst, pqrst, pqrst]).reshape(1, -1) analogs = Analogs(ecg) analogs.plot() onsets = analogs.sel(channel=0).meca.detect_onset( threshold=analogs.mean(), # mean of the signal n_above=freq / 2, # we want at least 1/2 second above the threshold n_below=freq / 2, # we accept point below threshold for 1/2 second ) for (start, end) in onsets: plt.axvline(x=start, color=\"g\") plt.axvline(x=end, color=\"r\") plt.show() ``` ![detect_onset](../../images/api/detect_onset.svg) !!! warning `detect_onset` works only for 1-dimensional data. For example, you can select a dimension using `analogs.sel(channel='EMG1')` or `analogs.isel(channel=0)`. \"\"\" return misc . detect_onset ( self . _obj , threshold , n_above , n_below , threshold2 , n_above2 ) detect_outliers ( self , threshold = 3 ) Detects data points that are threshold times the standard deviation from the mean. Parameters: Name Type Description Default threshold int Multiple of standard deviation from which data is considered outlier 3 Returns: Type Description DataArray A boolean xarray.DataArray containing the outliers Example To get a boolean xr.DataArray containing the data that are 3 times the mean +/- standard deviation: from motion import Analogs analogs = Analogs . from_random_data () outliers = analogs . meca . detect_outliers ( threshold = 1 ) Let's plot the data that are 1 time the mean +/- standard deviation on an analog vector: import matplotlib.pyplot as plt analogs = Analogs . from_random_data ( size = ( 1 , 100 )) threshold = 1 outliers = analogs . meca . detect_outliers ( threshold = threshold ) analogs . plot . line ( x = \"time_frame\" , color = \"black\" , add_legend = False ) analogs . where ( outliers ) . plot . line ( x = \"time_frame\" , color = \"red\" , add_legend = False , marker = \"o\" , label = \"outliers\" ) mu = analogs . mean () sigma = analogs . std () plt . axhline ( mu , color = \"grey\" ) plt . axhspan ( mu - threshold * sigma , mu + threshold * sigma , color = \"grey\" , alpha = 0.3 , label = f \"mean +/- { threshold } std\" , ) plt . legend () plt . show () Note detect_outliers is not limited on one-dimensional data and can detect outliers for any number of dimensions. Source code in motion/dataarray_accessor.py 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 def detect_outliers ( self , threshold : int = 3 ) -> xr . DataArray : \"\"\" Detects data points that are `threshold` times the standard deviation from the mean. Arguments: threshold: Multiple of standard deviation from which data is considered outlier Returns: A boolean `xarray.DataArray` containing the outliers !!! example To get a boolean `xr.DataArray` containing the data that are 3 times the mean +/- standard deviation: ```python from motion import Analogs analogs = Analogs.from_random_data() outliers = analogs.meca.detect_outliers(threshold=1) ``` Let's plot the data that are 1 time the mean +/- standard deviation on an analog vector: ```python import matplotlib.pyplot as plt analogs = Analogs.from_random_data(size=(1, 100)) threshold = 1 outliers = analogs.meca.detect_outliers(threshold=threshold) analogs.plot.line(x=\"time_frame\", color=\"black\", add_legend=False) analogs.where(outliers).plot.line( x=\"time_frame\", color=\"red\", add_legend=False, marker=\"o\", label=\"outliers\" ) mu = analogs.mean() sigma = analogs.std() plt.axhline(mu, color=\"grey\") plt.axhspan( mu - threshold * sigma, mu + threshold * sigma, color=\"grey\", alpha=0.3, label=f\"mean +/- {threshold} std\", ) plt.legend() plt.show() ``` ![detect_outliers](../../images/api/detect_outliers.svg) Note: `detect_outliers` is not limited on one-dimensional data and can detect outliers for any number of dimensions. \"\"\" return misc . detect_outliers ( self . _obj , threshold ) fft ( self , freq , only_positive = True ) Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. Parameters: Name Type Description Default freq Union[int, float] Sampling frequency (usually stored in array.attrs[\"rate\"] ) required only_positive bool If True , returns only the positive frequencies True Returns: Type Description DataArray A xarray.DataArray with the corresponding amplitudes and frequencies Example Let's compare the resulting fft on a raw and low-passed signal: import matplotlib.pyplot as plt import numpy as np from motion import Analogs # generate fake data freq = 100 time = np . arange ( 0 , 1 , 0.01 ) w = 2 * np . pi y = np . sin ( w * time ) + 0.1 * np . sin ( 10 * w * time ) analogs = Analogs ( y . reshape ( 1 , - 1 )) analogs_low_passed = analogs . meca . low_pass ( freq = freq , order = 2 , cutoff = 5 ) # compute fft on raw and low-passed signal fft_raw = analogs . meca . fft ( freq = freq ) fft_low_passed = analogs_low_passed . meca . fft ( freq = freq ) fig , ax = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) # plot signal vs. time analogs . plot . line ( x = \"time_frame\" , ax = ax [ 0 ], color = \"black\" , add_legend = False ) analogs_low_passed . plot . line ( x = \"time_frame\" , ax = ax [ 0 ], color = \"red\" , add_legend = False ) ax [ 0 ] . set_title ( \"Signal vs. Time\" ) # plot amplitudes vs. frequencies fft_raw . plot . line ( x = \"freq\" , ax = ax [ 1 ], color = \"black\" , label = \"raw\" ) fft_low_passed . plot . line ( x = \"freq\" , ax = ax [ 1 ], color = \"red\" , label = \"low-pass @ 5Hz\" ) ax [ 1 ] . set_title ( \"Amplitudes vs. Freq\" ) plt . legend () plt . show () Source code in motion/dataarray_accessor.py 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 def fft ( self , freq : Union [ int , float ], only_positive : bool = True ) -> xr . DataArray : \"\"\" Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. Arguments: freq: Sampling frequency (usually stored in `array.attrs[\"rate\"]`) only_positive: If `True`, returns only the positive frequencies Returns: A `xarray.DataArray` with the corresponding amplitudes and frequencies !!! example Let's compare the resulting fft on a raw and low-passed signal: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs # generate fake data freq = 100 time = np.arange(0, 1, 0.01) w = 2 * np.pi y = np.sin(w * time) + 0.1 * np.sin(10 * w * time) analogs = Analogs(y.reshape(1, -1)) analogs_low_passed = analogs.meca.low_pass(freq=freq, order=2, cutoff=5) # compute fft on raw and low-passed signal fft_raw = analogs.meca.fft(freq=freq) fft_low_passed = analogs_low_passed.meca.fft(freq=freq) fig, ax = plt.subplots(ncols=2, figsize=(10, 4)) # plot signal vs. time analogs.plot.line(x=\"time_frame\", ax=ax[0], color=\"black\", add_legend=False) analogs_low_passed.plot.line(x=\"time_frame\", ax=ax[0], color=\"red\", add_legend=False) ax[0].set_title(\"Signal vs. Time\") # plot amplitudes vs. frequencies fft_raw.plot.line(x=\"freq\", ax=ax[1], color=\"black\", label=\"raw\") fft_low_passed.plot.line(x=\"freq\", ax=ax[1], color=\"red\", label=\"low-pass @ 5Hz\") ax[1].set_title(\"Amplitudes vs. Freq\") plt.legend() plt.show() ``` ![band_pass](../../images/api/fft.svg) \"\"\" return misc . fft ( self . _obj , freq , only_positive ) high_pass ( self , freq , order , cutoff ) High-pass Butterworth filter. Parameters: Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required Returns: Type Description DataArray A high-pass filtered xarray.DataArray Example To high-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 100Hz: import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz high_pass = analogs . meca . high_pass ( freq = freq , order = 2 , cutoff = 100 ) analogs . plot ( label = \"raw\" ) high_pass . plot ( label = \"high-pass @ 100Hz\" ) plt . legend () plt . show () Source code in motion/dataarray_accessor.py 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 def high_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ int , float , np . array ] ) -> xr . DataArray : \"\"\" High-pass Butterworth filter. Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency Returns: A high-pass filtered `xarray.DataArray` !!! example To high-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 100Hz: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz high_pass = analogs.meca.high_pass(freq=freq, order=2, cutoff=100) analogs.plot(label=\"raw\") high_pass.plot(label=\"high-pass @ 100Hz\") plt.legend() plt.show() ``` ![high_pass](../../images/api/high_pass.svg) \"\"\" return filter . high_pass ( self . _obj , freq , order , cutoff ) low_pass ( self , freq , order , cutoff ) Low-pass Butterworth filter. Parameters: Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required Returns: Type Description DataArray A low-pass filtered xarray.DataArray Example To low-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 5Hz: from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . low_pass ( freq = 100 , order = 2 , cutoff = 5 ) Let's see how the low-pass smooth a fake sinusoidal signal: import matplotlib.pyplot as plt import numpy as np # generate fake data freq = 100 # Hz time_vector = np . linspace ( start = 0 , stop = 100 , num = 100 ) w = 2 * np . pi * 1 y = np . sin ( w * time_vector ) + 0.1 * np . sin ( 10 * w * time_vector ) analogs = Analogs ( y . reshape ( 1 , - 1 )) low_pass = analogs . meca . low_pass ( freq = freq , order = 2 , cutoff = 5 ) analogs . plot ( label = \"raw\" ) low_pass . plot ( label = \"low-pass @ 5Hz\" ) plt . legend () plt . show () Source code in motion/dataarray_accessor.py 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 def low_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ int , float , np . array ] ) -> xr . DataArray : \"\"\" Low-pass Butterworth filter. Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency Returns: A low-pass filtered `xarray.DataArray` !!! example To low-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 5Hz: ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.low_pass(freq=100, order=2, cutoff=5) ``` Let's see how the low-pass smooth a fake sinusoidal signal: ```python import matplotlib.pyplot as plt import numpy as np # generate fake data freq = 100 # Hz time_vector = np.linspace(start=0, stop=100, num=100) w = 2 * np.pi * 1 y = np.sin(w * time_vector) + 0.1 * np.sin(10 * w * time_vector) analogs = Analogs(y.reshape(1, -1)) low_pass = analogs.meca.low_pass(freq=freq, order=2, cutoff=5) analogs.plot(label=\"raw\") low_pass.plot(label=\"low-pass @ 5Hz\") plt.legend() plt.show() ``` ![low_pass](../../images/api/low_pass.svg) \"\"\" return filter . low_pass ( self . _obj , freq , order , cutoff ) matmul ( self , other ) Matrix product of two arrays. Parameters: Name Type Description Default other DataArray second array to multiply required Returns: Type Description DataArray A xarray.DataArray containing the matrix product of the two arrays Example To compute the matrix product of two xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs first_analogs = Analogs . from_random_data () second_analogs = Analogs . from_random_data () first_analogs . meca . matmul ( second_analogs ) You can also use the shorthand @ : first_analogs @ second_analogs Source code in motion/dataarray_accessor.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def matmul ( self , other : xr . DataArray ) -> xr . DataArray : \"\"\" Matrix product of two arrays. Arguments: other: second array to multiply Returns: A `xarray.DataArray` containing the matrix product of the two arrays !!! example To compute the matrix product of two `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs first_analogs = Analogs.from_random_data() second_analogs = Analogs.from_random_data() first_analogs.meca.matmul(second_analogs) ``` You can also use the shorthand `@`: ```python first_analogs @ second_analogs ``` \"\"\" return algebra . matmul ( self . _obj , other ) norm ( self , dim , ord = None ) Return the norm of an array. Parameters: Name Type Description Default dim Union[str, list] Name(s) of the data dimension(s) required ord int Order of the norm None Returns: Type Description DataArray A xarray.DataArray containing the norm of the matrix. Example To compute the norm of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) along a given dimension: from motion import Markers markers = Markers . from_random_data () markers . meca . norm ( dim = \"axis\" ) Note If the array contains an \"axis\" dimension with a \"ones\" coordinate (e.g., the object was created using motion.Markers ), this coordinate is ignored. Source code in motion/dataarray_accessor.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def norm ( self , dim : Union [ str , list ], ord : int = None ) -> xr . DataArray : \"\"\" Return the norm of an array. Arguments: dim: Name(s) of the data dimension(s) ord: Order of the norm Returns: A `xarray.DataArray` containing the norm of the matrix. !!! example To compute the norm of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) along a given dimension: ```python from motion import Markers markers = Markers.from_random_data() markers.meca.norm(dim=\"axis\") ``` Note: If the array contains an `\"axis\"` dimension with a `\"ones\"` coordinate (e.g., the object was created using `motion.Markers`), this coordinate is ignored. \"\"\" return algebra . norm ( self . _obj , dim , ord ) normalize ( self , ref = None , scale = 100 ) Normalize a signal against ref on a scale of scale . Parameters: Name Type Description Default ref Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] Reference value. Could have multiple dimensions. If not provided, takes the mean along the time_frame axis None scale Union[int, float] Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) 100 Returns: Type Description DataArray A xarray.DataArray containing the normalized signal Example To normalize any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs . from_random_data ( size = ( 1 , 100 )) . meca . abs () normalized = analogs . meca . normalize () normalized . plot () plt . show () By default, this function normalize against the signal's max. To specify any other value, use the ref parameter: normalized = analogs . meca . normalize ( ref = 1 ) Source code in motion/dataarray_accessor.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def normalize ( self , ref : Union [ xr . DataArray , np . array , float , int ] = None , scale : Union [ int , float ] = 100 , ) -> xr . DataArray : \"\"\" Normalize a signal against `ref` on a scale of `scale`. Arguments: ref: Reference value. Could have multiple dimensions. If not provided, takes the mean along the time_frame axis scale: Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) Returns: A `xarray.DataArray` containing the normalized signal !!! example To normalize any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs.from_random_data(size=(1, 100)).meca.abs() normalized = analogs.meca.normalize() normalized.plot() plt.show() ``` ![normalize](../../images/api/normalize.svg) By default, this function normalize against the signal's max. To specify any other value, use the `ref` parameter: ```python normalized = analogs.meca.normalize(ref=1) ``` \"\"\" return algebra . normalize ( self . _obj , ref , scale ) rms ( self ) Return the root-mean-square of an array. Returns: Type Description DataArray A xarray.DataArray containing the root-mean-square of the matrix. Example To compute the root-mean-square of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . rms () Source code in motion/dataarray_accessor.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 def rms ( self ) -> xr . DataArray : \"\"\" Return the root-mean-square of an array. Returns: A `xarray.DataArray` containing the root-mean-square of the matrix. !!! example To compute the root-mean-square of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.rms() ``` \"\"\" return algebra . rms ( self . _obj ) rotate ( self , rt ) Rotates markers data from a rototrans matrix. Parameters: Name Type Description Default rt DataArray Rototrans to rotate about required Returns: Type Description DataArray A rotated xarray.DataArray Example To rotate a random markers set from random angles: Note rotate works only for markers (created with motion.Markers ). Source code in motion/dataarray_accessor.py 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 def rotate ( self , rt : xr . DataArray ) -> xr . DataArray : \"\"\" Rotates markers data from a rototrans matrix. Arguments: rt: Rototrans to rotate about Returns: A rotated `xarray.DataArray` !!! example To rotate a random markers set from random angles: ```python from motion import Angles, Rototrans, Markers n_frames = 100 n_markers = 10 angles = Angles.from_random_data(size=(3, 1, n_frames)) rt = Rototrans.from_euler_angles(angles, \"xyz\") markers = Markers.from_random_data(size=(3, n_markers, n_frames)) rotated_markers = markers.meca.rotate(rt) ``` Note: `rotate` works only for markers (created with `motion.Markers`). \"\"\" return markers . rotate_markers ( self . _obj , rt ) sqrt ( self , * args , ** kwargs ) Return the non-negative square-root of an array, element-wise. Parameters: Name Type Description Default args For other positional arguments, see the numpy docs () kwargs For other keyword-only arguments, see the numpy docs {} Returns: Type Description DataArray A xarray.DataArray containing the square root of the matrix. Example To compute the non-negative square-root of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . sqrt () Source code in motion/dataarray_accessor.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def sqrt ( self , * args , ** kwargs ) -> xr . DataArray : \"\"\" Return the non-negative square-root of an array, element-wise. Arguments: args: For other positional arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) Returns: A `xarray.DataArray` containing the square root of the matrix. !!! example To compute the non-negative square-root of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.sqrt() ``` \"\"\" return algebra . sqrt ( self . _obj , * args , ** kwargs ) square ( self , * args , ** kwargs ) Return the element-wise square of the input. Parameters: Name Type Description Default args For other positional arguments, see the numpy docs () kwargs For other keyword-only arguments, see the numpy docs {} Returns: Type Description DataArray A xarray.DataArray containing the matrix squared. Example To compute the element-wise square of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . square () Source code in motion/dataarray_accessor.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def square ( self , * args , ** kwargs ) -> xr . DataArray : \"\"\" Return the element-wise square of the input. Arguments: args: For other positional arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) Returns: A `xarray.DataArray` containing the matrix squared. !!! example To compute the element-wise square of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.square() ``` \"\"\" return algebra . square ( self . _obj , * args , ** kwargs ) time_normalize ( self , time_vector = None , n_frames = 100 , norm_time_frame = False ) Time normalization used for temporal alignment of data. Parameters: Name Type Description Default time_vector Union[xarray.core.dataarray.DataArray, <built-in function array>] desired time vector (first to last time_frame with n_frames points by default) None n_frames int if time_vector is not specified, the length of the desired time vector 100 norm_time_frame bool Normalize the time_frame dimension from 0 to 100 if True False Returns: Type Description DataArray A time-normalized xarray.DataArray Example To time-normalize any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs . from_random_data ( size = ( 1 , 847 )) time_normalized = analogs . meca . time_normalize () print ( time_normalized . time_frame . size ) # 100 To normalize the corresponding time_frame dimension from 0 to 100%, specify norm_time_frame=True : time_normalized = analogs . meca . time_normalize ( norm_time_frame = True ) time_normalized . plot () plt . show () By default, time_normalize use a time vector with 100 frames from 0 to 100. However, you can specify the desired number of frames: time_normalized = analogs . meca . time_normalize ( n_frames = 500 ) print ( time_normalized . time_frame . size ) # 500 You can also specify the desired time_vector directly in the time_vector parameter: import numpy as np time_normalized = analogs . meca . time_normalize ( time_vector = np . linspace ( 0 , 200 , 300 )) Source code in motion/dataarray_accessor.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def time_normalize ( self , time_vector : Union [ xr . DataArray , np . array ] = None , n_frames : int = 100 , norm_time_frame : bool = False , ) -> xr . DataArray : \"\"\" Time normalization used for temporal alignment of data. Arguments: time_vector: desired time vector (first to last time_frame with n_frames points by default) n_frames: if time_vector is not specified, the length of the desired time vector norm_time_frame: Normalize the time_frame dimension from 0 to 100 if True Returns: A time-normalized `xarray.DataArray` !!! example To time-normalize any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs.from_random_data(size=(1, 847)) time_normalized = analogs.meca.time_normalize() print(time_normalized.time_frame.size) # 100 ``` To normalize the corresponding time_frame dimension from 0 to 100%, specify `norm_time_frame=True`: ```python time_normalized = analogs.meca.time_normalize(norm_time_frame=True) time_normalized.plot() plt.show() ``` ![time_normalize](../../images/api/time_normalize.svg) By default, `time_normalize` use a time vector with 100 frames from 0 to 100. However, you can specify the desired number of frames: ```python time_normalized = analogs.meca.time_normalize(n_frames=500) print(time_normalized.time_frame.size) # 500 ``` You can also specify the desired time_vector directly in the `time_vector` parameter: ```python import numpy as np time_normalized = analogs.meca.time_normalize(time_vector=np.linspace(0, 200, 300)) ``` \"\"\" return interp . time_normalize ( self . _obj , time_vector , n_frames , norm_time_frame = norm_time_frame ) to_csv ( self , filename , wide = True ) Write a csv file from a xarray.DataArray. Parameters: Name Type Description Default filename Union[str, pathlib.Path] File path required wide Optional[bool] True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. True Example To write a csv file from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . to_csv ( filename = \"temp.csv\" ) By default, to_csv will export the data in a \"wide\" format (1 column by channel). You can also export the data in a \"tidy\" format with wide=False : analogs . meca . to_csv ( filename = \"temp.csv\" , wide = False ) Source code in motion/dataarray_accessor.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def to_csv ( self , filename : Union [ str , Path ], wide : Optional [ bool ] = True ): \"\"\" Write a csv file from a xarray.DataArray. Arguments: filename: File path wide: True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. !!! example To write a csv file from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.to_csv(filename=\"temp.csv\") ``` By default, `to_csv` will export the data in a \"wide\" format (1 column by channel). You can also export the data in a \"tidy\" format with `wide=False`: ```python analogs.meca.to_csv(filename=\"temp.csv\", wide=False) ``` \"\"\" write . write_csv ( self . _obj , filename , wide ) to_matlab ( self , filename ) Write a matlab file from a xarray.DataArray. Parameters: Name Type Description Default filename Union[str, pathlib.Path] File path required Example To write a matlab file from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . to_matlab ( filename = \"temp.mat\" ) Source code in motion/dataarray_accessor.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def to_matlab ( self , filename : Union [ str , Path ]): \"\"\" Write a matlab file from a xarray.DataArray. Arguments: filename: File path !!! example To write a matlab file from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.to_matlab(filename=\"temp.mat\") ``` \"\"\" write . write_matlab ( self . _obj , filename ) to_wide_dataframe ( self ) Return a wide pandas.DataFrame (one column by channel). Returns: Type Description DataFrame A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: array.to_series() , or array.to_dataframe() . Example To return a dataframe from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . to_wide_dataframe () Source code in motion/dataarray_accessor.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def to_wide_dataframe ( self ) -> pd . DataFrame : \"\"\" Return a wide pandas.DataFrame (one column by channel). Returns: A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: `array.to_series()`, or `array.to_dataframe()`. !!! example To return a dataframe from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.to_wide_dataframe() ``` \"\"\" return write . to_wide_dataframe ( self . _obj )","title":"Dataarray_accessor"},{"location":"api/dataarray_accessor/#dataarray_accessorpy","text":"","title":"dataarray_accessor.py"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor","text":"","title":"motion.dataarray_accessor"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor","text":"Meca DataArray accessor used for processing or file writing.","title":"DataArrayAccessor"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.abs","text":"Calculate the absolute value element-wise. Returns: Type Description DataArray A xarray.DataArray containing the absolute of each element Example To compute the absolute value of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . abs () Source code in motion/dataarray_accessor.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def abs ( self ) -> xr . DataArray : \"\"\" Calculate the absolute value element-wise. Returns: A `xarray.DataArray` containing the absolute of each element !!! example To compute the absolute value of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.abs() ``` \"\"\" return algebra . abs_ ( self . _obj )","title":"abs()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.band_pass","text":"Band-pass Butterworth filter. Parameters: Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required Returns: Type Description DataArray A band-pass filtered xarray.DataArray Example To band-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 10-200Hz: import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz band_pass = analogs . meca . band_pass ( freq = freq , order = 2 , cutoff = [ 10 , 200 ]) analogs . plot ( label = \"raw\" ) band_pass . plot ( label = \"band-pass @ 10-200Hz\" ) plt . legend () plt . show () Source code in motion/dataarray_accessor.py 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 def band_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ list , tuple , np . array ] ) -> xr . DataArray : \"\"\" Band-pass Butterworth filter. Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) Returns: A band-pass filtered `xarray.DataArray` !!! example To band-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 10-200Hz: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz band_pass = analogs.meca.band_pass(freq=freq, order=2, cutoff=[10, 200]) analogs.plot(label=\"raw\") band_pass.plot(label=\"band-pass @ 10-200Hz\") plt.legend() plt.show() ``` ![band_pass](../../images/api/band_pass.svg) \"\"\" return filter . band_pass ( self . _obj , freq , order , cutoff )","title":"band_pass()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.band_stop","text":"Band-stop Butterworth filter. Parameters: Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[list, tuple, <built-in function array>] Cut-off frequency such as (lower, upper) required Returns: Type Description DataArray A band-stop filtered xarray.DataArray Example To band-stop any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 40-60Hz: import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz band_stop = analogs . meca . band_stop ( freq = freq , order = 2 , cutoff = [ 40 , 60 ]) analogs . plot ( label = \"raw\" ) band_stop . plot ( label = \"band-stop @ 40-60Hz\" ) plt . legend () plt . show () Source code in motion/dataarray_accessor.py 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 def band_stop ( self , freq : Union [ int , float ], order : int , cutoff : Union [ list , tuple , np . array ] ) -> xr . DataArray : \"\"\" Band-stop Butterworth filter. Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency such as (lower, upper) Returns: A band-stop filtered `xarray.DataArray` !!! example To band-stop any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 40-60Hz: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz band_stop = analogs.meca.band_stop(freq=freq, order=2, cutoff=[40, 60]) analogs.plot(label=\"raw\") band_stop.plot(label=\"band-stop @ 40-60Hz\") plt.legend() plt.show() ``` ![band_stop](../../images/api/band_stop.svg) \"\"\" return filter . band_stop ( self . _obj , freq , order , cutoff )","title":"band_stop()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.center","text":"Center an array (i.e., subtract the mean). Parameters: Name Type Description Default mu Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] mean of the signal to subtract. If not provided, takes the mean along the time_frame axis None Returns: Type Description DataArray a xarray.DataArray containing the root-mean-square of the matrix Example To center any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import numpy as np from motion import Analogs random_data = np . random . uniform ( low = 2 , high = 4 , size = ( 1 , 100 )) analogs = Analogs ( random_data ) centered = analogs . meca . center () This will substract the mean of the signal by default. The previous random signal was sampled from a uniform distribution from 2 and 4 (mean around 3). When centered, the signal is now center around 0 (mean around 0). import matplotlib.pyplot as plt analogs . plot ( label = \"raw\" ) centered . plot ( label = \"centered\" ) plt . legend () plt . show () Source code in motion/dataarray_accessor.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 def center ( self , mu : Union [ xr . DataArray , np . array , float , int ] = None ) -> xr . DataArray : \"\"\" Center an array (i.e., subtract the mean). Arguments: mu: mean of the signal to subtract. If not provided, takes the mean along the time_frame axis Returns: a `xarray.DataArray` containing the root-mean-square of the matrix !!! example To center any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import numpy as np from motion import Analogs random_data = np.random.uniform(low=2, high=4, size=(1, 100)) analogs = Analogs(random_data) centered = analogs.meca.center() ``` This will substract the mean of the signal by default. The previous random signal was sampled from a uniform distribution from 2 and 4 (mean around 3). When centered, the signal is now center around 0 (mean around 0). ```python import matplotlib.pyplot as plt analogs.plot(label=\"raw\") centered.plot(label=\"centered\") plt.legend() plt.show() ``` ![center](../../images/api/center.svg) \"\"\" return algebra . center ( self . _obj , mu )","title":"center()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.detect_onset","text":"Detects onset based on amplitude threshold. Parameters: Name Type Description Default threshold Union[float, int] minimum amplitude to detect required n_above int minimum number of continuous samples >= threshold to detect 1 n_below int minimum number of continuous samples below threshold that will be ignored in the detection of x >= threshold 0 threshold2 int minimum amplitude of n_above2 values in x to detect None n_above2 int minimum number of samples >= threshold2 to detect 1 Note You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns: Type Description <built-in function array> inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events Example To detect the onsets of any one-dimensional xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt import numpy as np import scipy.signal as sig from motion import Analogs # simulate fake ecg data rr = 2.5 # rr time in seconds freq = 100 # sampling rate pqrst = sig . resample ( sig . wavelets . daub ( 10 ), int ( rr * freq )) ecg = np . concatenate ([ pqrst , pqrst , pqrst ]) . reshape ( 1 , - 1 ) analogs = Analogs ( ecg ) analogs . plot () onsets = analogs . sel ( channel = 0 ) . meca . detect_onset ( threshold = analogs . mean (), # mean of the signal n_above = freq / 2 , # we want at least 1/2 second above the threshold n_below = freq / 2 , # we accept point below threshold for 1/2 second ) for ( start , end ) in onsets : plt . axvline ( x = start , color = \"g\" ) plt . axvline ( x = end , color = \"r\" ) plt . show () Warning detect_onset works only for 1-dimensional data. For example, you can select a dimension using analogs.sel(channel='EMG1') or analogs.isel(channel=0) . Source code in motion/dataarray_accessor.py 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 def detect_onset ( self , threshold : Union [ float , int ], n_above : int = 1 , n_below : int = 0 , threshold2 : int = None , n_above2 : int = 1 , ) -> np . array : \"\"\" Detects onset based on amplitude threshold. Arguments: threshold: minimum amplitude to detect n_above: minimum number of continuous samples >= `threshold` to detect n_below: minimum number of continuous samples below `threshold` that will be ignored in the detection of `x` >= `threshold` threshold2: minimum amplitude of `n_above2` values in `x` to detect n_above2: minimum number of samples >= `threshold2` to detect Note: You might have to tune the parameters according to the signal-to-noise characteristic of the data. Returns: inds: 1D array_like [indi, indf] containing initial and final indexes of the onset events !!! example To detect the onsets of any __one-dimensional__ `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt import numpy as np import scipy.signal as sig from motion import Analogs # simulate fake ecg data rr = 2.5 # rr time in seconds freq = 100 # sampling rate pqrst = sig.resample(sig.wavelets.daub(10), int(rr * freq)) ecg = np.concatenate([pqrst, pqrst, pqrst]).reshape(1, -1) analogs = Analogs(ecg) analogs.plot() onsets = analogs.sel(channel=0).meca.detect_onset( threshold=analogs.mean(), # mean of the signal n_above=freq / 2, # we want at least 1/2 second above the threshold n_below=freq / 2, # we accept point below threshold for 1/2 second ) for (start, end) in onsets: plt.axvline(x=start, color=\"g\") plt.axvline(x=end, color=\"r\") plt.show() ``` ![detect_onset](../../images/api/detect_onset.svg) !!! warning `detect_onset` works only for 1-dimensional data. For example, you can select a dimension using `analogs.sel(channel='EMG1')` or `analogs.isel(channel=0)`. \"\"\" return misc . detect_onset ( self . _obj , threshold , n_above , n_below , threshold2 , n_above2 )","title":"detect_onset()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.detect_outliers","text":"Detects data points that are threshold times the standard deviation from the mean. Parameters: Name Type Description Default threshold int Multiple of standard deviation from which data is considered outlier 3 Returns: Type Description DataArray A boolean xarray.DataArray containing the outliers Example To get a boolean xr.DataArray containing the data that are 3 times the mean +/- standard deviation: from motion import Analogs analogs = Analogs . from_random_data () outliers = analogs . meca . detect_outliers ( threshold = 1 ) Let's plot the data that are 1 time the mean +/- standard deviation on an analog vector: import matplotlib.pyplot as plt analogs = Analogs . from_random_data ( size = ( 1 , 100 )) threshold = 1 outliers = analogs . meca . detect_outliers ( threshold = threshold ) analogs . plot . line ( x = \"time_frame\" , color = \"black\" , add_legend = False ) analogs . where ( outliers ) . plot . line ( x = \"time_frame\" , color = \"red\" , add_legend = False , marker = \"o\" , label = \"outliers\" ) mu = analogs . mean () sigma = analogs . std () plt . axhline ( mu , color = \"grey\" ) plt . axhspan ( mu - threshold * sigma , mu + threshold * sigma , color = \"grey\" , alpha = 0.3 , label = f \"mean +/- { threshold } std\" , ) plt . legend () plt . show () Note detect_outliers is not limited on one-dimensional data and can detect outliers for any number of dimensions. Source code in motion/dataarray_accessor.py 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 def detect_outliers ( self , threshold : int = 3 ) -> xr . DataArray : \"\"\" Detects data points that are `threshold` times the standard deviation from the mean. Arguments: threshold: Multiple of standard deviation from which data is considered outlier Returns: A boolean `xarray.DataArray` containing the outliers !!! example To get a boolean `xr.DataArray` containing the data that are 3 times the mean +/- standard deviation: ```python from motion import Analogs analogs = Analogs.from_random_data() outliers = analogs.meca.detect_outliers(threshold=1) ``` Let's plot the data that are 1 time the mean +/- standard deviation on an analog vector: ```python import matplotlib.pyplot as plt analogs = Analogs.from_random_data(size=(1, 100)) threshold = 1 outliers = analogs.meca.detect_outliers(threshold=threshold) analogs.plot.line(x=\"time_frame\", color=\"black\", add_legend=False) analogs.where(outliers).plot.line( x=\"time_frame\", color=\"red\", add_legend=False, marker=\"o\", label=\"outliers\" ) mu = analogs.mean() sigma = analogs.std() plt.axhline(mu, color=\"grey\") plt.axhspan( mu - threshold * sigma, mu + threshold * sigma, color=\"grey\", alpha=0.3, label=f\"mean +/- {threshold} std\", ) plt.legend() plt.show() ``` ![detect_outliers](../../images/api/detect_outliers.svg) Note: `detect_outliers` is not limited on one-dimensional data and can detect outliers for any number of dimensions. \"\"\" return misc . detect_outliers ( self . _obj , threshold )","title":"detect_outliers()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.fft","text":"Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. Parameters: Name Type Description Default freq Union[int, float] Sampling frequency (usually stored in array.attrs[\"rate\"] ) required only_positive bool If True , returns only the positive frequencies True Returns: Type Description DataArray A xarray.DataArray with the corresponding amplitudes and frequencies Example Let's compare the resulting fft on a raw and low-passed signal: import matplotlib.pyplot as plt import numpy as np from motion import Analogs # generate fake data freq = 100 time = np . arange ( 0 , 1 , 0.01 ) w = 2 * np . pi y = np . sin ( w * time ) + 0.1 * np . sin ( 10 * w * time ) analogs = Analogs ( y . reshape ( 1 , - 1 )) analogs_low_passed = analogs . meca . low_pass ( freq = freq , order = 2 , cutoff = 5 ) # compute fft on raw and low-passed signal fft_raw = analogs . meca . fft ( freq = freq ) fft_low_passed = analogs_low_passed . meca . fft ( freq = freq ) fig , ax = plt . subplots ( ncols = 2 , figsize = ( 10 , 4 )) # plot signal vs. time analogs . plot . line ( x = \"time_frame\" , ax = ax [ 0 ], color = \"black\" , add_legend = False ) analogs_low_passed . plot . line ( x = \"time_frame\" , ax = ax [ 0 ], color = \"red\" , add_legend = False ) ax [ 0 ] . set_title ( \"Signal vs. Time\" ) # plot amplitudes vs. frequencies fft_raw . plot . line ( x = \"freq\" , ax = ax [ 1 ], color = \"black\" , label = \"raw\" ) fft_low_passed . plot . line ( x = \"freq\" , ax = ax [ 1 ], color = \"red\" , label = \"low-pass @ 5Hz\" ) ax [ 1 ] . set_title ( \"Amplitudes vs. Freq\" ) plt . legend () plt . show () Source code in motion/dataarray_accessor.py 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 def fft ( self , freq : Union [ int , float ], only_positive : bool = True ) -> xr . DataArray : \"\"\" Performs a discrete Fourier Transform and return a DataArray with the corresponding amplitudes and frequencies. Arguments: freq: Sampling frequency (usually stored in `array.attrs[\"rate\"]`) only_positive: If `True`, returns only the positive frequencies Returns: A `xarray.DataArray` with the corresponding amplitudes and frequencies !!! example Let's compare the resulting fft on a raw and low-passed signal: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs # generate fake data freq = 100 time = np.arange(0, 1, 0.01) w = 2 * np.pi y = np.sin(w * time) + 0.1 * np.sin(10 * w * time) analogs = Analogs(y.reshape(1, -1)) analogs_low_passed = analogs.meca.low_pass(freq=freq, order=2, cutoff=5) # compute fft on raw and low-passed signal fft_raw = analogs.meca.fft(freq=freq) fft_low_passed = analogs_low_passed.meca.fft(freq=freq) fig, ax = plt.subplots(ncols=2, figsize=(10, 4)) # plot signal vs. time analogs.plot.line(x=\"time_frame\", ax=ax[0], color=\"black\", add_legend=False) analogs_low_passed.plot.line(x=\"time_frame\", ax=ax[0], color=\"red\", add_legend=False) ax[0].set_title(\"Signal vs. Time\") # plot amplitudes vs. frequencies fft_raw.plot.line(x=\"freq\", ax=ax[1], color=\"black\", label=\"raw\") fft_low_passed.plot.line(x=\"freq\", ax=ax[1], color=\"red\", label=\"low-pass @ 5Hz\") ax[1].set_title(\"Amplitudes vs. Freq\") plt.legend() plt.show() ``` ![band_pass](../../images/api/fft.svg) \"\"\" return misc . fft ( self . _obj , freq , only_positive )","title":"fft()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.high_pass","text":"High-pass Butterworth filter. Parameters: Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required Returns: Type Description DataArray A high-pass filtered xarray.DataArray Example To high-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 100Hz: import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np . random . uniform ( low =- 1 , high = 1 , size = ( 1 , 1000 )) analogs = Analogs ( fake_emg ) freq = 1000 # Hz high_pass = analogs . meca . high_pass ( freq = freq , order = 2 , cutoff = 100 ) analogs . plot ( label = \"raw\" ) high_pass . plot ( label = \"high-pass @ 100Hz\" ) plt . legend () plt . show () Source code in motion/dataarray_accessor.py 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 def high_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ int , float , np . array ] ) -> xr . DataArray : \"\"\" High-pass Butterworth filter. Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency Returns: A high-pass filtered `xarray.DataArray` !!! example To high-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 100Hz: ```python import matplotlib.pyplot as plt import numpy as np from motion import Analogs fake_emg = np.random.uniform(low=-1, high=1, size=(1, 1000)) analogs = Analogs(fake_emg) freq = 1000 # Hz high_pass = analogs.meca.high_pass(freq=freq, order=2, cutoff=100) analogs.plot(label=\"raw\") high_pass.plot(label=\"high-pass @ 100Hz\") plt.legend() plt.show() ``` ![high_pass](../../images/api/high_pass.svg) \"\"\" return filter . high_pass ( self . _obj , freq , order , cutoff )","title":"high_pass()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.low_pass","text":"Low-pass Butterworth filter. Parameters: Name Type Description Default freq Union[int, float] Sampling frequency required order int Order of the filter required cutoff Union[int, float, <built-in function array>] Cut-off frequency required Returns: Type Description DataArray A low-pass filtered xarray.DataArray Example To low-pass any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) signal at 5Hz: from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . low_pass ( freq = 100 , order = 2 , cutoff = 5 ) Let's see how the low-pass smooth a fake sinusoidal signal: import matplotlib.pyplot as plt import numpy as np # generate fake data freq = 100 # Hz time_vector = np . linspace ( start = 0 , stop = 100 , num = 100 ) w = 2 * np . pi * 1 y = np . sin ( w * time_vector ) + 0.1 * np . sin ( 10 * w * time_vector ) analogs = Analogs ( y . reshape ( 1 , - 1 )) low_pass = analogs . meca . low_pass ( freq = freq , order = 2 , cutoff = 5 ) analogs . plot ( label = \"raw\" ) low_pass . plot ( label = \"low-pass @ 5Hz\" ) plt . legend () plt . show () Source code in motion/dataarray_accessor.py 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 def low_pass ( self , freq : Union [ int , float ], order : int , cutoff : Union [ int , float , np . array ] ) -> xr . DataArray : \"\"\" Low-pass Butterworth filter. Arguments: freq: Sampling frequency order: Order of the filter cutoff: Cut-off frequency Returns: A low-pass filtered `xarray.DataArray` !!! example To low-pass any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) signal at 5Hz: ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.low_pass(freq=100, order=2, cutoff=5) ``` Let's see how the low-pass smooth a fake sinusoidal signal: ```python import matplotlib.pyplot as plt import numpy as np # generate fake data freq = 100 # Hz time_vector = np.linspace(start=0, stop=100, num=100) w = 2 * np.pi * 1 y = np.sin(w * time_vector) + 0.1 * np.sin(10 * w * time_vector) analogs = Analogs(y.reshape(1, -1)) low_pass = analogs.meca.low_pass(freq=freq, order=2, cutoff=5) analogs.plot(label=\"raw\") low_pass.plot(label=\"low-pass @ 5Hz\") plt.legend() plt.show() ``` ![low_pass](../../images/api/low_pass.svg) \"\"\" return filter . low_pass ( self . _obj , freq , order , cutoff )","title":"low_pass()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.matmul","text":"Matrix product of two arrays. Parameters: Name Type Description Default other DataArray second array to multiply required Returns: Type Description DataArray A xarray.DataArray containing the matrix product of the two arrays Example To compute the matrix product of two xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs first_analogs = Analogs . from_random_data () second_analogs = Analogs . from_random_data () first_analogs . meca . matmul ( second_analogs ) You can also use the shorthand @ : first_analogs @ second_analogs Source code in motion/dataarray_accessor.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def matmul ( self , other : xr . DataArray ) -> xr . DataArray : \"\"\" Matrix product of two arrays. Arguments: other: second array to multiply Returns: A `xarray.DataArray` containing the matrix product of the two arrays !!! example To compute the matrix product of two `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs first_analogs = Analogs.from_random_data() second_analogs = Analogs.from_random_data() first_analogs.meca.matmul(second_analogs) ``` You can also use the shorthand `@`: ```python first_analogs @ second_analogs ``` \"\"\" return algebra . matmul ( self . _obj , other )","title":"matmul()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.norm","text":"Return the norm of an array. Parameters: Name Type Description Default dim Union[str, list] Name(s) of the data dimension(s) required ord int Order of the norm None Returns: Type Description DataArray A xarray.DataArray containing the norm of the matrix. Example To compute the norm of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans) along a given dimension: from motion import Markers markers = Markers . from_random_data () markers . meca . norm ( dim = \"axis\" ) Note If the array contains an \"axis\" dimension with a \"ones\" coordinate (e.g., the object was created using motion.Markers ), this coordinate is ignored. Source code in motion/dataarray_accessor.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def norm ( self , dim : Union [ str , list ], ord : int = None ) -> xr . DataArray : \"\"\" Return the norm of an array. Arguments: dim: Name(s) of the data dimension(s) ord: Order of the norm Returns: A `xarray.DataArray` containing the norm of the matrix. !!! example To compute the norm of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans) along a given dimension: ```python from motion import Markers markers = Markers.from_random_data() markers.meca.norm(dim=\"axis\") ``` Note: If the array contains an `\"axis\"` dimension with a `\"ones\"` coordinate (e.g., the object was created using `motion.Markers`), this coordinate is ignored. \"\"\" return algebra . norm ( self . _obj , dim , ord )","title":"norm()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.normalize","text":"Normalize a signal against ref on a scale of scale . Parameters: Name Type Description Default ref Union[xarray.core.dataarray.DataArray, <built-in function array>, float, int] Reference value. Could have multiple dimensions. If not provided, takes the mean along the time_frame axis None scale Union[int, float] Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) 100 Returns: Type Description DataArray A xarray.DataArray containing the normalized signal Example To normalize any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs . from_random_data ( size = ( 1 , 100 )) . meca . abs () normalized = analogs . meca . normalize () normalized . plot () plt . show () By default, this function normalize against the signal's max. To specify any other value, use the ref parameter: normalized = analogs . meca . normalize ( ref = 1 ) Source code in motion/dataarray_accessor.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def normalize ( self , ref : Union [ xr . DataArray , np . array , float , int ] = None , scale : Union [ int , float ] = 100 , ) -> xr . DataArray : \"\"\" Normalize a signal against `ref` on a scale of `scale`. Arguments: ref: Reference value. Could have multiple dimensions. If not provided, takes the mean along the time_frame axis scale: Scale on which to express array (e.g. if 100, the signal is normalized from 0 to 100) Returns: A `xarray.DataArray` containing the normalized signal !!! example To normalize any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs.from_random_data(size=(1, 100)).meca.abs() normalized = analogs.meca.normalize() normalized.plot() plt.show() ``` ![normalize](../../images/api/normalize.svg) By default, this function normalize against the signal's max. To specify any other value, use the `ref` parameter: ```python normalized = analogs.meca.normalize(ref=1) ``` \"\"\" return algebra . normalize ( self . _obj , ref , scale )","title":"normalize()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.rms","text":"Return the root-mean-square of an array. Returns: Type Description DataArray A xarray.DataArray containing the root-mean-square of the matrix. Example To compute the root-mean-square of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . rms () Source code in motion/dataarray_accessor.py 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 def rms ( self ) -> xr . DataArray : \"\"\" Return the root-mean-square of an array. Returns: A `xarray.DataArray` containing the root-mean-square of the matrix. !!! example To compute the root-mean-square of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.rms() ``` \"\"\" return algebra . rms ( self . _obj )","title":"rms()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.rotate","text":"Rotates markers data from a rototrans matrix. Parameters: Name Type Description Default rt DataArray Rototrans to rotate about required Returns: Type Description DataArray A rotated xarray.DataArray Example To rotate a random markers set from random angles: Note rotate works only for markers (created with motion.Markers ). Source code in motion/dataarray_accessor.py 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 def rotate ( self , rt : xr . DataArray ) -> xr . DataArray : \"\"\" Rotates markers data from a rototrans matrix. Arguments: rt: Rototrans to rotate about Returns: A rotated `xarray.DataArray` !!! example To rotate a random markers set from random angles: ```python from motion import Angles, Rototrans, Markers n_frames = 100 n_markers = 10 angles = Angles.from_random_data(size=(3, 1, n_frames)) rt = Rototrans.from_euler_angles(angles, \"xyz\") markers = Markers.from_random_data(size=(3, n_markers, n_frames)) rotated_markers = markers.meca.rotate(rt) ``` Note: `rotate` works only for markers (created with `motion.Markers`). \"\"\" return markers . rotate_markers ( self . _obj , rt )","title":"rotate()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.sqrt","text":"Return the non-negative square-root of an array, element-wise. Parameters: Name Type Description Default args For other positional arguments, see the numpy docs () kwargs For other keyword-only arguments, see the numpy docs {} Returns: Type Description DataArray A xarray.DataArray containing the square root of the matrix. Example To compute the non-negative square-root of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . sqrt () Source code in motion/dataarray_accessor.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def sqrt ( self , * args , ** kwargs ) -> xr . DataArray : \"\"\" Return the non-negative square-root of an array, element-wise. Arguments: args: For other positional arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html) Returns: A `xarray.DataArray` containing the square root of the matrix. !!! example To compute the non-negative square-root of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.sqrt() ``` \"\"\" return algebra . sqrt ( self . _obj , * args , ** kwargs )","title":"sqrt()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.square","text":"Return the element-wise square of the input. Parameters: Name Type Description Default args For other positional arguments, see the numpy docs () kwargs For other keyword-only arguments, see the numpy docs {} Returns: Type Description DataArray A xarray.DataArray containing the matrix squared. Example To compute the element-wise square of any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . square () Source code in motion/dataarray_accessor.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def square ( self , * args , ** kwargs ) -> xr . DataArray : \"\"\" Return the element-wise square of the input. Arguments: args: For other positional arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) kwargs: For other keyword-only arguments, see the [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.square.html) Returns: A `xarray.DataArray` containing the matrix squared. !!! example To compute the element-wise square of any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.square() ``` \"\"\" return algebra . square ( self . _obj , * args , ** kwargs )","title":"square()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.time_normalize","text":"Time normalization used for temporal alignment of data. Parameters: Name Type Description Default time_vector Union[xarray.core.dataarray.DataArray, <built-in function array>] desired time vector (first to last time_frame with n_frames points by default) None n_frames int if time_vector is not specified, the length of the desired time vector 100 norm_time_frame bool Normalize the time_frame dimension from 0 to 100 if True False Returns: Type Description DataArray A time-normalized xarray.DataArray Example To time-normalize any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs . from_random_data ( size = ( 1 , 847 )) time_normalized = analogs . meca . time_normalize () print ( time_normalized . time_frame . size ) # 100 To normalize the corresponding time_frame dimension from 0 to 100%, specify norm_time_frame=True : time_normalized = analogs . meca . time_normalize ( norm_time_frame = True ) time_normalized . plot () plt . show () By default, time_normalize use a time vector with 100 frames from 0 to 100. However, you can specify the desired number of frames: time_normalized = analogs . meca . time_normalize ( n_frames = 500 ) print ( time_normalized . time_frame . size ) # 500 You can also specify the desired time_vector directly in the time_vector parameter: import numpy as np time_normalized = analogs . meca . time_normalize ( time_vector = np . linspace ( 0 , 200 , 300 )) Source code in motion/dataarray_accessor.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def time_normalize ( self , time_vector : Union [ xr . DataArray , np . array ] = None , n_frames : int = 100 , norm_time_frame : bool = False , ) -> xr . DataArray : \"\"\" Time normalization used for temporal alignment of data. Arguments: time_vector: desired time vector (first to last time_frame with n_frames points by default) n_frames: if time_vector is not specified, the length of the desired time vector norm_time_frame: Normalize the time_frame dimension from 0 to 100 if True Returns: A time-normalized `xarray.DataArray` !!! example To time-normalize any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python import matplotlib.pyplot as plt from motion import Analogs analogs = Analogs.from_random_data(size=(1, 847)) time_normalized = analogs.meca.time_normalize() print(time_normalized.time_frame.size) # 100 ``` To normalize the corresponding time_frame dimension from 0 to 100%, specify `norm_time_frame=True`: ```python time_normalized = analogs.meca.time_normalize(norm_time_frame=True) time_normalized.plot() plt.show() ``` ![time_normalize](../../images/api/time_normalize.svg) By default, `time_normalize` use a time vector with 100 frames from 0 to 100. However, you can specify the desired number of frames: ```python time_normalized = analogs.meca.time_normalize(n_frames=500) print(time_normalized.time_frame.size) # 500 ``` You can also specify the desired time_vector directly in the `time_vector` parameter: ```python import numpy as np time_normalized = analogs.meca.time_normalize(time_vector=np.linspace(0, 200, 300)) ``` \"\"\" return interp . time_normalize ( self . _obj , time_vector , n_frames , norm_time_frame = norm_time_frame )","title":"time_normalize()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.to_csv","text":"Write a csv file from a xarray.DataArray. Parameters: Name Type Description Default filename Union[str, pathlib.Path] File path required wide Optional[bool] True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. True Example To write a csv file from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . to_csv ( filename = \"temp.csv\" ) By default, to_csv will export the data in a \"wide\" format (1 column by channel). You can also export the data in a \"tidy\" format with wide=False : analogs . meca . to_csv ( filename = \"temp.csv\" , wide = False ) Source code in motion/dataarray_accessor.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def to_csv ( self , filename : Union [ str , Path ], wide : Optional [ bool ] = True ): \"\"\" Write a csv file from a xarray.DataArray. Arguments: filename: File path wide: True if you want a wide dataframe (one column for each channel). False if you want a tidy dataframe. !!! example To write a csv file from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.to_csv(filename=\"temp.csv\") ``` By default, `to_csv` will export the data in a \"wide\" format (1 column by channel). You can also export the data in a \"tidy\" format with `wide=False`: ```python analogs.meca.to_csv(filename=\"temp.csv\", wide=False) ``` \"\"\" write . write_csv ( self . _obj , filename , wide )","title":"to_csv()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.to_matlab","text":"Write a matlab file from a xarray.DataArray. Parameters: Name Type Description Default filename Union[str, pathlib.Path] File path required Example To write a matlab file from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . to_matlab ( filename = \"temp.mat\" ) Source code in motion/dataarray_accessor.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def to_matlab ( self , filename : Union [ str , Path ]): \"\"\" Write a matlab file from a xarray.DataArray. Arguments: filename: File path !!! example To write a matlab file from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.to_matlab(filename=\"temp.mat\") ``` \"\"\" write . write_matlab ( self . _obj , filename )","title":"to_matlab()"},{"location":"api/dataarray_accessor/#motion.dataarray_accessor.DataArrayAccessor.to_wide_dataframe","text":"Return a wide pandas.DataFrame (one column by channel). Returns: Type Description DataFrame A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: array.to_series() , or array.to_dataframe() . Example To return a dataframe from any xarray.DataArray (including Analogs, Angles, Markers or Rototrans): from motion import Analogs analogs = Analogs . from_random_data () analogs . meca . to_wide_dataframe () Source code in motion/dataarray_accessor.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def to_wide_dataframe ( self ) -> pd . DataFrame : \"\"\" Return a wide pandas.DataFrame (one column by channel). Returns: A wide pandas DataFrame (one column by channel). Works only for 2 and 3-dimensional arrays. If you want a tidy dataframe type: `array.to_series()`, or `array.to_dataframe()`. !!! example To return a dataframe from any `xarray.DataArray` (including Analogs, Angles, Markers or Rototrans): ```python from motion import Analogs analogs = Analogs.from_random_data() analogs.meca.to_wide_dataframe() ``` \"\"\" return write . to_wide_dataframe ( self . _obj )","title":"to_wide_dataframe()"},{"location":"api/markers/","text":"markers.py Markers __new__ ( cls , data = None , channels = None , time_frames = None , * args , ** kwargs ) special staticmethod Markers DataArray with axis , channel and time_frame dimensions used for skin marker positions. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None args Positional argument(s) to be passed to xarray.DataArray () kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To instantiate a Markers with 4 channels and 100 frames filled with some random data: import numpy as np from motion import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_axis , n_channels , n_frames )) markers = Markers ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] markers = Markers ( data , channels = names ) And an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) markers = Markers ( data , channels = names , time_frames = time_frames ) Note Calling Markers() generate an empty array. Source code in motion/markers.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , channels : Optional [ list ] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Markers DataArray with `axis`, `channel` and `time_frame` dimensions used for skin marker positions. Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To instantiate a `Markers` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from motion import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np.random.random(size=(n_axis, n_channels, n_frames)) markers = Markers(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] markers = Markers(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) markers = Markers(data, channels=names, time_frames=time_frames) ``` !!! note Calling `Markers()` generate an empty array. \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) else : coords [ \"axis\" ] = [ \"x\" , \"y\" , \"z\" , \"ones\" ] if data . shape [ 0 ] == 3 : data = np . insert ( data , obj = 3 , values = 1 , axis = 0 ) if channels : coords [ \"channel\" ] = channels if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"axis\" , \"channel\" , \"time_frame\" ), coords = coords , name = \"markers\" , * args , ** kwargs , ) from_c3d ( filename , usecols = None , prefix_delimiter = None , suffix_delimiter = None , attrs = None ) classmethod Markers DataArray from a c3d file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this c3d file , type: from motion import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Daphnee:ASISl\" , \"Daphnee:PSISr\" , \"Daphnee:PSISl\" ] markers = Markers . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"\"Daphnee:ASISl\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISl\" , \"PSISr\" , \"PSISl\" ] markers = Markers . from_c3d ( data_path , prefix_delimiter = \":\" ) Source code in motion/markers.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a c3d file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this c3d file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers_analogs.c3d), type: ```python from motion import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Daphnee:ASISl\", \"Daphnee:PSISr\", \"Daphnee:PSISl\"] markers = Markers.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"\"Daphnee:ASISl\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISl\", \"PSISr\", \"PSISl\"] markers = Markers.from_c3d(data_path, prefix_delimiter=\":\") ``` \"\"\" return read . read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs ) from_csv ( filename , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , last_column_to_remove = None , prefix_delimiter = None , suffix_delimiter = None , skiprows = None , pandas_kwargs = None , attrs = None ) classmethod Markers DataArray from a csv file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this csv file , type: from motion import Markers data_path = \"./tests/data/markers.csv\" markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"Daphnee:ASISr\" , \"Daphnee:ASISl\" , \"Daphnee:PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Daphnee:ASISr\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISr\" , \"ASISl\" , \"PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in motion/markers.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a csv file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this csv file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.csv), type: ```python from motion import Markers data_path = \"./tests/data/markers.csv\" markers = Markers.from_csv(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"Daphnee:ASISr\", \"Daphnee:ASISl\", \"Daphnee:PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Daphnee:ASISr\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISr\", \"ASISl\", \"PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , ) from_excel ( filename , sheet_name = 0 , usecols = None , header = None , first_row = 0 , first_column = None , time_column = None , last_column_to_remove = None , prefix_delimiter = None , suffix_delimiter = None , skiprows = None , pandas_kwargs = None , attrs = None ) classmethod Markers DataArray from an Excel file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this excel file , type: from motion import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"boite:gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"boite:gauche_ext\" and you specify suffix_delimiter=\":\" , you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in motion/markers.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from an Excel file. Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this excel file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.xlsx), type: ```python from motion import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers.from_excel(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"boite:gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"boite:gauche_ext\"` and you specify `suffix_delimiter=\":\"`, you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , sheet_name , ) from_random_data ( distribution = 'normal' , size = ( 3 , 10 , 100 ), * args , ** kwargs ) classmethod Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 10, 100) args Positional argument(s) to be passed to numpy.random. distribution () kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random markers xarray.DataArray sampled from a given distribution Example To instantiate a Markers with some random data sampled from a normal distribution: from motion import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis , n_channels , n_frames markers = Markers . from_random_data ( size = size ) You can choose any distribution available in numpy.random : markers = Markers . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in motion/markers.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random markers `xarray.DataArray` sampled from a given distribution !!! example To instantiate a `Markers` with some random data sampled from a normal distribution: ```python from motion import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis, n_channels, n_frames markers = Markers.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python markers = Markers.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Markers ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) from_trc ( filename , ** kwargs ) classmethod Markers DataArray from a trc file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required kwargs Keyword arguments to be passed to from_csv {} Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this trc file , type: from motion import Markers data_path = \"./tests/data/markers.trc\" markers = Markers . from_trc ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"STER\" , \"STERl\" ] markers = Markers . from_trc ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] markers = Markers . from_trc ( data_path , usecols = channels ) Source code in motion/markers.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 @classmethod def from_trc ( cls , filename : Union [ str , Path ], ** kwargs ) -> xr . DataArray : \"\"\" Markers DataArray from a trc file. Arguments: filename: Any valid string path kwargs: Keyword arguments to be passed to `from_csv` Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this trc file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.trc), type: ```python from motion import Markers data_path = \"./tests/data/markers.trc\" markers = Markers.from_trc(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"STER\", \"STERl\"] markers = Markers.from_trc(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] markers = Markers.from_trc(data_path, usecols=channels) ``` \"\"\" return read . read_trc ( cls , filename , ** kwargs )","title":"Markers"},{"location":"api/markers/#markerspy","text":"","title":"markers.py"},{"location":"api/markers/#motion.markers","text":"","title":"motion.markers"},{"location":"api/markers/#motion.markers.Markers","text":"","title":"Markers"},{"location":"api/markers/#motion.markers.Markers.__new__","text":"Markers DataArray with axis , channel and time_frame dimensions used for skin marker positions. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None channels Optional[list] Channel names None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None args Positional argument(s) to be passed to xarray.DataArray () kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To instantiate a Markers with 4 channels and 100 frames filled with some random data: import numpy as np from motion import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np . random . random ( size = ( n_axis , n_channels , n_frames )) markers = Markers ( data ) You can add the channel names: names = [ \"A\" , \"B\" , \"C\" , \"D\" ] markers = Markers ( data , channels = names ) And an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) markers = Markers ( data , channels = names , time_frames = time_frames ) Note Calling Markers() generate an empty array. Source code in motion/markers.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , channels : Optional [ list ] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Markers DataArray with `axis`, `channel` and `time_frame` dimensions used for skin marker positions. Arguments: data: Array to be passed to xarray.DataArray channels: Channel names time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To instantiate a `Markers` with 4 channels and 100 frames filled with some random data: ```python import numpy as np from motion import Markers n_axis = 3 n_channels = 4 n_frames = 100 data = np.random.random(size=(n_axis, n_channels, n_frames)) markers = Markers(data) ``` You can add the channel names: ```python names = [\"A\", \"B\", \"C\", \"D\"] markers = Markers(data, channels=names) ``` And an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) markers = Markers(data, channels=names, time_frames=time_frames) ``` !!! note Calling `Markers()` generate an empty array. \"\"\" coords = {} if data is None : data = np . ndarray (( 0 , 0 , 0 )) else : coords [ \"axis\" ] = [ \"x\" , \"y\" , \"z\" , \"ones\" ] if data . shape [ 0 ] == 3 : data = np . insert ( data , obj = 3 , values = 1 , axis = 0 ) if channels : coords [ \"channel\" ] = channels if time_frames is not None : coords [ \"time_frame\" ] = time_frames return xr . DataArray ( data = data , dims = ( \"axis\" , \"channel\" , \"time_frame\" ), coords = coords , name = \"markers\" , * args , ** kwargs , )","title":"__new__()"},{"location":"api/markers/#motion.markers.Markers.from_c3d","text":"Markers DataArray from a c3d file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None attrs Optional[dict] attrs to be passed to xr.DataArray None Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this c3d file , type: from motion import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers . from_c3d ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in: channels = [ \"Daphnee:ASISl\" , \"Daphnee:PSISr\" , \"Daphnee:PSISl\" ] markers = Markers . from_c3d ( data_path , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"\"Daphnee:ASISl\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISl\" , \"PSISr\" , \"PSISl\" ] markers = Markers . from_c3d ( data_path , prefix_delimiter = \":\" ) Source code in motion/markers.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 @classmethod def from_c3d ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a c3d file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) attrs: attrs to be passed to xr.DataArray Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this c3d file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers_analogs.c3d), type: ```python from motion import Markers data_path = \"./tests/data/markers_analogs.c3d\" markers = Markers.from_c3d(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in: ```python channels = [\"Daphnee:ASISl\", \"Daphnee:PSISr\", \"Daphnee:PSISl\"] markers = Markers.from_c3d(data_path, usecols=channels) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"\"Daphnee:ASISl\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISl\", \"PSISr\", \"PSISl\"] markers = Markers.from_c3d(data_path, prefix_delimiter=\":\") ``` \"\"\" return read . read_c3d ( cls , filename , usecols , prefix_delimiter , suffix_delimiter , attrs )","title":"from_c3d()"},{"location":"api/markers/#motion.markers.Markers.from_csv","text":"Markers DataArray from a csv file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_csv None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this csv file , type: from motion import Markers data_path = \"./tests/data/markers.csv\" markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"Daphnee:ASISr\" , \"Daphnee:ASISl\" , \"Daphnee:PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 5 , 6 , 7 ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"Daphnee:ASISr\" and you specify suffix_delimiter=\":\" , you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"ASISr\" , \"ASISl\" , \"PSISr\" ] markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_csv ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in motion/markers.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 @classmethod def from_csv ( cls , filename : Union [ str , Path ], usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from a csv file. Arguments: filename: Any valid string path usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_csv` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this csv file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.csv), type: ```python from motion import Markers data_path = \"./tests/data/markers.csv\" markers = Markers.from_csv(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"Daphnee:ASISr\", \"Daphnee:ASISl\", \"Daphnee:PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [5, 6, 7] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"Daphnee:ASISr\"` and you specify `suffix_delimiter=\":\"`, you will select \"Daphnee\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"ASISr\", \"ASISl\", \"PSISr\"] markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_csv( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"csv\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , )","title":"from_csv()"},{"location":"api/markers/#motion.markers.Markers.from_excel","text":"Markers DataArray from an Excel file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required sheet_name Union[str, int] Strings are used for sheet names. Integers are used in zero-indexed sheet positions 0 usecols Optional[List[Union[str, int]]] All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. None header Optional[int] Row of the header (0-indexed) None first_row int First row of the data (0-indexed) 0 first_column Optional[Union[str, int]] First column of the data (0-indexed) None time_column Optional[Union[str, int]] Column of the time column. If None, we associate the index None last_column_to_remove Optional[Union[str, int]] If for some reason the csv reads extra columns, how many should be ignored None prefix_delimiter Optional[str] Delimiter that split each column name by its prefix (we keep only the column name) None suffix_delimiter Optional[str] Delimiter that split each column name by its suffix (we keep only the column name) None skiprows Optional[List[int]] Line numbers to skip (0-indexed) None pandas_kwargs Optional[dict] Keyword arguments to be passed to pandas.read_excel None attrs Optional[dict] attrs to be passed to xr.DataArray . If attrs['rate'] is provided, compute the time_frame accordingly None Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this excel file , type: from motion import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"boite:gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Or by position: channels = [ 1 ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels ) Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify prefix_delimiter and suffix_delimiter for the suffix. For example, if the name is \"boite:gauche_ext\" and you specify suffix_delimiter=\":\" , you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": channels = [ \"gauche_ext\" ] markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 2 , usecols = channels , prefix_delimiter = \":\" , ) It is also possible to specify a column containing the time vector: markers = Markers . from_excel ( data_path , header = 2 , first_row = 5 , first_column = 1 , time_column = 0 ) Source code in motion/markers.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 @classmethod def from_excel ( cls , filename : Union [ str , Path ], sheet_name : Union [ str , int ] = 0 , usecols : Optional [ List [ Union [ str , int ]]] = None , header : Optional [ int ] = None , first_row : int = 0 , first_column : Optional [ Union [ str , int ]] = None , time_column : Optional [ Union [ str , int ]] = None , last_column_to_remove : Optional [ Union [ str , int ]] = None , prefix_delimiter : Optional [ str ] = None , suffix_delimiter : Optional [ str ] = None , skiprows : Optional [ List [ int ]] = None , pandas_kwargs : Optional [ dict ] = None , attrs : Optional [ dict ] = None , ) -> xr . DataArray : \"\"\" Markers DataArray from an Excel file. Arguments: filename: Any valid string path sheet_name: Strings are used for sheet names. Integers are used in zero-indexed sheet positions usecols: All elements must either be positional or strings that correspond to column names. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. header: Row of the header (0-indexed) first_row: First row of the data (0-indexed) first_column: First column of the data (0-indexed) time_column: Column of the time column. If None, we associate the index last_column_to_remove: If for some reason the csv reads extra columns, how many should be ignored prefix_delimiter: Delimiter that split each column name by its prefix (we keep only the column name) suffix_delimiter: Delimiter that split each column name by its suffix (we keep only the column name) skiprows: Line numbers to skip (0-indexed) pandas_kwargs: Keyword arguments to be passed to `pandas.read_excel` attrs: attrs to be passed to `xr.DataArray`. If attrs['rate'] is provided, compute the time_frame accordingly Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this excel file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.xlsx), type: ```python from motion import Markers data_path = \"./tests/data/markers.xlsx\" markers = Markers.from_excel(data_path, header=2, first_row=5, first_column=2) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"boite:gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Or by position: ```python channels = [1] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels ) ``` Sometimes the channel name is delimited by a suffix or prefix. To access the prefix, you can specify `prefix_delimiter` and `suffix_delimiter` for the suffix. For example, if the name is `\"boite:gauche_ext\"` and you specify `suffix_delimiter=\":\"`, you will select \"boite\". Similarly, if you specify `prefix_delimiter=\":\": ```python channels = [\"gauche_ext\"] markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=2, usecols=channels, prefix_delimiter=\":\", ) ``` It is also possible to specify a column containing the time vector: ```python markers = Markers.from_excel( data_path, header=2, first_row=5, first_column=1, time_column=0 ) ``` \"\"\" return read . read_csv_or_excel ( cls , \"excel\" , filename , usecols , header , first_row , first_column , time_column , last_column_to_remove , prefix_delimiter , suffix_delimiter , skiprows , pandas_kwargs , attrs , sheet_name , )","title":"from_excel()"},{"location":"api/markers/#motion.markers.Markers.from_random_data","text":"Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (3, 10, 100) args Positional argument(s) to be passed to numpy.random. distribution () kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random markers xarray.DataArray sampled from a given distribution Example To instantiate a Markers with some random data sampled from a normal distribution: from motion import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis , n_channels , n_frames markers = Markers . from_random_data ( size = size ) You can choose any distribution available in numpy.random : markers = Markers . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in motion/markers.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 3 , 10 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random markers `xarray.DataArray` sampled from a given distribution !!! example To instantiate a `Markers` with some random data sampled from a normal distribution: ```python from motion import Markers n_axis = 3 n_channels = 10 n_frames = 100 size = n_axis, n_channels, n_frames markers = Markers.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python markers = Markers.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Markers ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) )","title":"from_random_data()"},{"location":"api/markers/#motion.markers.Markers.from_trc","text":"Markers DataArray from a trc file. Parameters: Name Type Description Default filename Union[str, pathlib.Path] Any valid string path required kwargs Keyword arguments to be passed to from_csv {} Returns: Type Description DataArray Markers xarray.DataArray with the specified data and coordinates Example To read this trc file , type: from motion import Markers data_path = \"./tests/data/markers.trc\" markers = Markers . from_trc ( data_path ) If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: channels = [ \"STER\" , \"STERl\" ] markers = Markers . from_trc ( data_path , usecols = channels ) Or by position: channels = [ 3 , 4 ] markers = Markers . from_trc ( data_path , usecols = channels ) Source code in motion/markers.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 @classmethod def from_trc ( cls , filename : Union [ str , Path ], ** kwargs ) -> xr . DataArray : \"\"\" Markers DataArray from a trc file. Arguments: filename: Any valid string path kwargs: Keyword arguments to be passed to `from_csv` Returns: Markers `xarray.DataArray` with the specified data and coordinates !!! example To read [this trc file](https://github.com/romainmartinez/motion/blob/master/tests/data/markers.trc), type: ```python from motion import Markers data_path = \"./tests/data/markers.trc\" markers = Markers.from_trc(data_path) ``` If you know the channel names, you can retrieve only the ones you are interested in by specifying strings: ```python channels = [\"STER\", \"STERl\"] markers = Markers.from_trc(data_path, usecols=channels) ``` Or by position: ```python channels = [3, 4] markers = Markers.from_trc(data_path, usecols=channels) ``` \"\"\" return read . read_trc ( cls , filename , ** kwargs )","title":"from_trc()"},{"location":"api/rototrans/","text":"rototrans.py Rototrans __new__ ( cls , data = None , time_frames = None , * args , ** kwargs ) special staticmethod Rototrans DataArray with row , col and time_frame dimensions used for rototranslation matrix. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None args Positional argument(s) to be passed to xarray.DataArray () kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Rototrans xarray.DataArray with the specified data and coordinates Example To instantiate a Rototrans 4 by 4 and 100 frames filled with some random data: import numpy as np from motion import Rototrans n_row = 4 n_col = 4 n_frames = 100 data = np . random . random ( size = ( n_row , n_col , n_frames )) rt = Rototrans ( data ) You can an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) rt = Rototrans ( data , time_frames = time_frames ) Notes Calling Rototrans() generate an empty array. Source code in motion/rototrans.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Rototrans DataArray with `row`, `col` and `time_frame` dimensions used for rototranslation matrix. Arguments: data: Array to be passed to xarray.DataArray time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Rototrans `xarray.DataArray` with the specified data and coordinates !!! example To instantiate a `Rototrans` 4 by 4 and 100 frames filled with some random data: ```python import numpy as np from motion import Rototrans n_row = 4 n_col = 4 n_frames = 100 data = np.random.random(size=(n_row, n_col, n_frames)) rt = Rototrans(data) ``` You can an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) rt = Rototrans(data, time_frames=time_frames) ``` !!! notes Calling `Rototrans()` generate an empty array. \"\"\" coords = {} if data is None : data = np . eye ( 4 ) else : # if we provide data, we copy them to avoid making inplace changes data = data . copy () if data . shape [ 0 ] != 4 or data . shape [ 1 ] != 4 : raise IndexError ( f \"data must have first and second dimensions of length 4, you have: { data . shape } \" ) if data . ndim == 2 : data = data [ ... , np . newaxis ] if time_frames is not None : coords [ \"time_frame\" ] = time_frames # Make sure last line reads [0, 0, 0, 1] data [ 3 , : 3 , :] = 0 data [ 3 , 3 , :] = 1 return xr . DataArray ( data = data , dims = ( \"row\" , \"col\" , \"time_frame\" ), coords = coords , name = \"rototrans\" , * args , ** kwargs , ) from_averaged_rototrans ( rt ) classmethod Rototrans DataArray from an averaged Rototrans. Parameters: Name Type Description Default rt DataArray Rototrans to average required Returns: Type Description DataArray Averaged Rototrans xarray.DataArray Example To average a Rototrans computed from random angles: import numpy as np from motion import Angles , Rototrans angles = Angles ( np . random . rand ( 3 , 1 , 100 )) seq = \"xyz\" rt = Rototrans . from_euler_angles ( angles , seq ) rt_mean = Rototrans . from_averaged_rototrans ( rt ) Let's make sure the resulting angles are roughly equivalent to the averaged angles: angles_mean = Angles . from_rototrans ( rt_mean , seq ) . isel ( time_frame = 0 ) angles_mean_ref = Angles . from_rototrans ( rt , seq ) . mean ( dim = \"time_frame\" ) error = ( angles_mean - angles_mean_ref ) . meca . abs () . sum () print ( error ) Source code in motion/rototrans.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 @classmethod def from_averaged_rototrans ( cls , rt : xr . DataArray ) -> xr . DataArray : \"\"\" Rototrans DataArray from an averaged Rototrans. Arguments: rt: Rototrans to average Returns: Averaged Rototrans `xarray.DataArray` !!! example To average a `Rototrans` computed from random angles: ```python import numpy as np from motion import Angles, Rototrans angles = Angles(np.random.rand(3, 1, 100)) seq = \"xyz\" rt = Rototrans.from_euler_angles(angles, seq) rt_mean = Rototrans.from_averaged_rototrans(rt) ``` Let's make sure the resulting angles are roughly equivalent to the averaged angles: ```python angles_mean = Angles.from_rototrans(rt_mean, seq).isel(time_frame=0) angles_mean_ref = Angles.from_rototrans(rt, seq).mean(dim=\"time_frame\") error = (angles_mean - angles_mean_ref).meca.abs().sum() print(error) ``` \"\"\" return rototrans . rototrans_from_averaged_rototrans ( cls , rt ) from_euler_angles ( angles = None , angle_sequence = None , translations = None ) classmethod Rototrans DataArray from euler angles and specified angle sequence. Parameters: Name Type Description Default angles Optional[xarray.core.dataarray.DataArray] Euler angles of the rototranslation matrix None angle_sequence Optional[str] Euler sequence of angles. Valid values are all permutations of \"xyz\" None translations Optional[xarray.core.dataarray.DataArray] Translation part of the Rototrans matrix None Returns: Type Description DataArray Rototrans xarray.DataArray from the specified angles and angles sequence Example To get the rototranslation matrix from random euler angles with a given angle sequence type: from motion import Angles , Rototrans size = ( 3 , 1 , 100 ) angles = Angles . from_random_data ( size = size ) angles_sequence = \"xyz\" rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence ) A translation vector can also be specified: translation = Angles . from_random_data ( size = size ) rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence , translations = translation ) Source code in motion/rototrans.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 @classmethod def from_euler_angles ( cls , angles : Optional [ xr . DataArray ] = None , angle_sequence : Optional [ str ] = None , translations : Optional [ xr . DataArray ] = None , ) -> xr . DataArray : \"\"\" Rototrans DataArray from euler angles and specified angle sequence. Arguments: angles: Euler angles of the rototranslation matrix angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" translations: Translation part of the Rototrans matrix Returns: Rototrans `xarray.DataArray` from the specified angles and angles sequence !!! example To get the rototranslation matrix from random euler angles with a given angle sequence type: ```python from motion import Angles, Rototrans size = (3, 1, 100) angles = Angles.from_random_data(size=size) angles_sequence = \"xyz\" rt = Rototrans.from_euler_angles(angles=angles, angle_sequence=angles_sequence) ``` A translation vector can also be specified: ```python translation = Angles.from_random_data(size=size) rt = Rototrans.from_euler_angles( angles=angles, angle_sequence=angles_sequence, translations=translation ) ``` \"\"\" return rototrans . rototrans_from_euler_angles ( cls , angles , angle_sequence , translations ) from_markers ( origin , axis_1 , axis_2 , axes_name , axis_to_recalculate ) classmethod Rototrans DataArray from a specified set of markers. Parameters: Name Type Description Default origin DataArray A marker constructed with motion.Markers() corresponding to the origin in the global reference frame required axis_1 DataArray Two markers that describe the first axis. The first markers being the beginning of the vector and the second being the end. required axis_2 DataArray Two markers that describe the second axis. The first markers being the beginning of the vector and the second being the end. required axes_name str Any combination of x , y and z describing the first and second axes. required axis_to_recalculate str Which of the two axes to recalculate required Returns: Type Description DataArray Rototrans xarray.DataArray from the specified angles and angles sequence Example To create a system of axes from random markers: from motion import Markers , Rototrans markers = Markers . from_random_data () rt = Rototrans . from_markers ( origin = markers . isel ( channel = [ 0 ]), # first marker axis_1 = markers . isel ( channel = [ 0 , 1 ]), # vector from the first and second markers axis_2 = markers . isel ( channel = [ 0 , 2 ]), # vector from the first and third markers axes_name = \"xy\" , # axis_1 is x and axis_2 is y axis_to_recalculate = \"y\" , # we want to recalculate y ) Source code in motion/rototrans.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 @classmethod def from_markers ( cls , origin : xr . DataArray , axis_1 : xr . DataArray , axis_2 : xr . DataArray , axes_name : str , axis_to_recalculate : str , ) -> xr . DataArray : \"\"\" Rototrans DataArray from a specified set of markers. Arguments: origin: A marker constructed with `motion.Markers()` corresponding to the origin in the global reference frame axis_1: Two markers that describe the first axis. The first markers being the beginning of the vector and the second being the end. axis_2: Two markers that describe the second axis. The first markers being the beginning of the vector and the second being the end. axes_name: Any combination of `x`, `y` and `z` describing the first and second axes. axis_to_recalculate: Which of the two axes to recalculate Returns: Rototrans `xarray.DataArray` from the specified angles and angles sequence !!! example To create a system of axes from random markers: ```python from motion import Markers, Rototrans markers = Markers.from_random_data() rt = Rototrans.from_markers( origin=markers.isel(channel=[0]), # first marker axis_1=markers.isel(channel=[0, 1]), # vector from the first and second markers axis_2=markers.isel(channel=[0, 2]), # vector from the first and third markers axes_name=\"xy\", # axis_1 is x and axis_2 is y axis_to_recalculate=\"y\", # we want to recalculate y ) ``` \"\"\" return rototrans . rototrans_from_markers ( cls , origin , axis_1 , axis_2 , axes_name , axis_to_recalculate ) from_random_data ( distribution = 'normal' , size = ( 4 , 4 , 100 ), * args , ** kwargs ) classmethod Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (4, 4, 100) args Positional argument(s) to be passed to numpy.random. distribution () kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random rototrans xarray.DataArray sampled from a given distribution Example To instantiate a Rototrans with some random data sampled from a normal distribution: from motion import Rototrans n_frames = 100 size = 4 , 4 , n_frames rt = Rototrans . from_random_data ( size = size ) You can choose any distribution available in numpy.random : rt = Rototrans . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in motion/rototrans.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 4 , 4 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random rototrans `xarray.DataArray` sampled from a given distribution !!! example To instantiate a `Rototrans` with some random data sampled from a normal distribution: ```python from motion import Rototrans n_frames = 100 size = 4, 4, n_frames rt = Rototrans.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python rt = Rototrans.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Rototrans ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) ) from_transposed_rototrans ( rt ) classmethod Rototrans DataArray from a tranposed Rototrans. Parameters: Name Type Description Default rt DataArray Rototrans to transpose required Returns: Type Description DataArray Transposed Rototrans xarray.DataArray Example from motion import Rototrans rt = Rototrans . from_random_data () rt_t = Rototrans . from_transposed_rototrans ( rt ) Notes The inverse Rototrans is, by definition, equivalent to the tranposed Rototrans. Source code in motion/rototrans.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 @classmethod def from_transposed_rototrans ( cls , rt : xr . DataArray ) -> xr . DataArray : \"\"\" Rototrans DataArray from a tranposed Rototrans. Arguments: rt: Rototrans to transpose Returns: Transposed Rototrans `xarray.DataArray` !!! example ```python from motion import Rototrans rt = Rototrans.from_random_data() rt_t = Rototrans.from_transposed_rototrans(rt) ``` !!! notes The inverse Rototrans is, by definition, equivalent to the tranposed Rototrans. \"\"\" return rototrans . rototrans_from_transposed_rototrans ( cls , rt )","title":"Rototrans"},{"location":"api/rototrans/#rototranspy","text":"","title":"rototrans.py"},{"location":"api/rototrans/#motion.rototrans","text":"","title":"motion.rototrans"},{"location":"api/rototrans/#motion.rototrans.Rototrans","text":"","title":"Rototrans"},{"location":"api/rototrans/#motion.rototrans.Rototrans.__new__","text":"Rototrans DataArray with row , col and time_frame dimensions used for rototranslation matrix. Parameters: Name Type Description Default data Optional[Union[<built-in function array>, numpy.ndarray, xarray.core.dataarray.DataArray, list]] Array to be passed to xarray.DataArray None time_frames Optional[Union[<built-in function array>, list, pandas.core.series.Series]] Time vector in seconds associated with the data parameter None args Positional argument(s) to be passed to xarray.DataArray () kwargs Keyword argument(s) to be passed to xarray.DataArray {} Returns: Type Description DataArray Rototrans xarray.DataArray with the specified data and coordinates Example To instantiate a Rototrans 4 by 4 and 100 frames filled with some random data: import numpy as np from motion import Rototrans n_row = 4 n_col = 4 n_frames = 100 data = np . random . random ( size = ( n_row , n_col , n_frames )) rt = Rototrans ( data ) You can an associate time vector: rate = 100 # Hz time_frames = np . arange ( start = 0 , stop = n_frames / rate , step = 1 / rate ) rt = Rototrans ( data , time_frames = time_frames ) Notes Calling Rototrans() generate an empty array. Source code in motion/rototrans.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def __new__ ( cls , data : Optional [ Union [ np . array , np . ndarray , xr . DataArray , list ]] = None , time_frames : Optional [ Union [ np . array , list , pd . Series ]] = None , * args , ** kwargs , ) -> xr . DataArray : \"\"\" Rototrans DataArray with `row`, `col` and `time_frame` dimensions used for rototranslation matrix. Arguments: data: Array to be passed to xarray.DataArray time_frames: Time vector in seconds associated with the `data` parameter args: Positional argument(s) to be passed to xarray.DataArray kwargs: Keyword argument(s) to be passed to xarray.DataArray Returns: Rototrans `xarray.DataArray` with the specified data and coordinates !!! example To instantiate a `Rototrans` 4 by 4 and 100 frames filled with some random data: ```python import numpy as np from motion import Rototrans n_row = 4 n_col = 4 n_frames = 100 data = np.random.random(size=(n_row, n_col, n_frames)) rt = Rototrans(data) ``` You can an associate time vector: ```python rate = 100 # Hz time_frames = np.arange(start=0, stop=n_frames / rate, step=1 / rate) rt = Rototrans(data, time_frames=time_frames) ``` !!! notes Calling `Rototrans()` generate an empty array. \"\"\" coords = {} if data is None : data = np . eye ( 4 ) else : # if we provide data, we copy them to avoid making inplace changes data = data . copy () if data . shape [ 0 ] != 4 or data . shape [ 1 ] != 4 : raise IndexError ( f \"data must have first and second dimensions of length 4, you have: { data . shape } \" ) if data . ndim == 2 : data = data [ ... , np . newaxis ] if time_frames is not None : coords [ \"time_frame\" ] = time_frames # Make sure last line reads [0, 0, 0, 1] data [ 3 , : 3 , :] = 0 data [ 3 , 3 , :] = 1 return xr . DataArray ( data = data , dims = ( \"row\" , \"col\" , \"time_frame\" ), coords = coords , name = \"rototrans\" , * args , ** kwargs , )","title":"__new__()"},{"location":"api/rototrans/#motion.rototrans.Rototrans.from_averaged_rototrans","text":"Rototrans DataArray from an averaged Rototrans. Parameters: Name Type Description Default rt DataArray Rototrans to average required Returns: Type Description DataArray Averaged Rototrans xarray.DataArray Example To average a Rototrans computed from random angles: import numpy as np from motion import Angles , Rototrans angles = Angles ( np . random . rand ( 3 , 1 , 100 )) seq = \"xyz\" rt = Rototrans . from_euler_angles ( angles , seq ) rt_mean = Rototrans . from_averaged_rototrans ( rt ) Let's make sure the resulting angles are roughly equivalent to the averaged angles: angles_mean = Angles . from_rototrans ( rt_mean , seq ) . isel ( time_frame = 0 ) angles_mean_ref = Angles . from_rototrans ( rt , seq ) . mean ( dim = \"time_frame\" ) error = ( angles_mean - angles_mean_ref ) . meca . abs () . sum () print ( error ) Source code in motion/rototrans.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 @classmethod def from_averaged_rototrans ( cls , rt : xr . DataArray ) -> xr . DataArray : \"\"\" Rototrans DataArray from an averaged Rototrans. Arguments: rt: Rototrans to average Returns: Averaged Rototrans `xarray.DataArray` !!! example To average a `Rototrans` computed from random angles: ```python import numpy as np from motion import Angles, Rototrans angles = Angles(np.random.rand(3, 1, 100)) seq = \"xyz\" rt = Rototrans.from_euler_angles(angles, seq) rt_mean = Rototrans.from_averaged_rototrans(rt) ``` Let's make sure the resulting angles are roughly equivalent to the averaged angles: ```python angles_mean = Angles.from_rototrans(rt_mean, seq).isel(time_frame=0) angles_mean_ref = Angles.from_rototrans(rt, seq).mean(dim=\"time_frame\") error = (angles_mean - angles_mean_ref).meca.abs().sum() print(error) ``` \"\"\" return rototrans . rototrans_from_averaged_rototrans ( cls , rt )","title":"from_averaged_rototrans()"},{"location":"api/rototrans/#motion.rototrans.Rototrans.from_euler_angles","text":"Rototrans DataArray from euler angles and specified angle sequence. Parameters: Name Type Description Default angles Optional[xarray.core.dataarray.DataArray] Euler angles of the rototranslation matrix None angle_sequence Optional[str] Euler sequence of angles. Valid values are all permutations of \"xyz\" None translations Optional[xarray.core.dataarray.DataArray] Translation part of the Rototrans matrix None Returns: Type Description DataArray Rototrans xarray.DataArray from the specified angles and angles sequence Example To get the rototranslation matrix from random euler angles with a given angle sequence type: from motion import Angles , Rototrans size = ( 3 , 1 , 100 ) angles = Angles . from_random_data ( size = size ) angles_sequence = \"xyz\" rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence ) A translation vector can also be specified: translation = Angles . from_random_data ( size = size ) rt = Rototrans . from_euler_angles ( angles = angles , angle_sequence = angles_sequence , translations = translation ) Source code in motion/rototrans.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 @classmethod def from_euler_angles ( cls , angles : Optional [ xr . DataArray ] = None , angle_sequence : Optional [ str ] = None , translations : Optional [ xr . DataArray ] = None , ) -> xr . DataArray : \"\"\" Rototrans DataArray from euler angles and specified angle sequence. Arguments: angles: Euler angles of the rototranslation matrix angle_sequence: Euler sequence of angles. Valid values are all permutations of \"xyz\" translations: Translation part of the Rototrans matrix Returns: Rototrans `xarray.DataArray` from the specified angles and angles sequence !!! example To get the rototranslation matrix from random euler angles with a given angle sequence type: ```python from motion import Angles, Rototrans size = (3, 1, 100) angles = Angles.from_random_data(size=size) angles_sequence = \"xyz\" rt = Rototrans.from_euler_angles(angles=angles, angle_sequence=angles_sequence) ``` A translation vector can also be specified: ```python translation = Angles.from_random_data(size=size) rt = Rototrans.from_euler_angles( angles=angles, angle_sequence=angles_sequence, translations=translation ) ``` \"\"\" return rototrans . rototrans_from_euler_angles ( cls , angles , angle_sequence , translations )","title":"from_euler_angles()"},{"location":"api/rototrans/#motion.rototrans.Rototrans.from_markers","text":"Rototrans DataArray from a specified set of markers. Parameters: Name Type Description Default origin DataArray A marker constructed with motion.Markers() corresponding to the origin in the global reference frame required axis_1 DataArray Two markers that describe the first axis. The first markers being the beginning of the vector and the second being the end. required axis_2 DataArray Two markers that describe the second axis. The first markers being the beginning of the vector and the second being the end. required axes_name str Any combination of x , y and z describing the first and second axes. required axis_to_recalculate str Which of the two axes to recalculate required Returns: Type Description DataArray Rototrans xarray.DataArray from the specified angles and angles sequence Example To create a system of axes from random markers: from motion import Markers , Rototrans markers = Markers . from_random_data () rt = Rototrans . from_markers ( origin = markers . isel ( channel = [ 0 ]), # first marker axis_1 = markers . isel ( channel = [ 0 , 1 ]), # vector from the first and second markers axis_2 = markers . isel ( channel = [ 0 , 2 ]), # vector from the first and third markers axes_name = \"xy\" , # axis_1 is x and axis_2 is y axis_to_recalculate = \"y\" , # we want to recalculate y ) Source code in motion/rototrans.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 @classmethod def from_markers ( cls , origin : xr . DataArray , axis_1 : xr . DataArray , axis_2 : xr . DataArray , axes_name : str , axis_to_recalculate : str , ) -> xr . DataArray : \"\"\" Rototrans DataArray from a specified set of markers. Arguments: origin: A marker constructed with `motion.Markers()` corresponding to the origin in the global reference frame axis_1: Two markers that describe the first axis. The first markers being the beginning of the vector and the second being the end. axis_2: Two markers that describe the second axis. The first markers being the beginning of the vector and the second being the end. axes_name: Any combination of `x`, `y` and `z` describing the first and second axes. axis_to_recalculate: Which of the two axes to recalculate Returns: Rototrans `xarray.DataArray` from the specified angles and angles sequence !!! example To create a system of axes from random markers: ```python from motion import Markers, Rototrans markers = Markers.from_random_data() rt = Rototrans.from_markers( origin=markers.isel(channel=[0]), # first marker axis_1=markers.isel(channel=[0, 1]), # vector from the first and second markers axis_2=markers.isel(channel=[0, 2]), # vector from the first and third markers axes_name=\"xy\", # axis_1 is x and axis_2 is y axis_to_recalculate=\"y\", # we want to recalculate y ) ``` \"\"\" return rototrans . rototrans_from_markers ( cls , origin , axis_1 , axis_2 , axes_name , axis_to_recalculate )","title":"from_markers()"},{"location":"api/rototrans/#motion.rototrans.Rototrans.from_random_data","text":"Create random data from a specified distribution (normal by default) using random walk. Parameters: Name Type Description Default distribution str Distribution available in numpy.random 'normal' size tuple Shape of the desired array (4, 4, 100) args Positional argument(s) to be passed to numpy.random. distribution () kwargs Keyword argument(s) to be passed to numpy.random. distribution {} Returns: Type Description DataArray Random rototrans xarray.DataArray sampled from a given distribution Example To instantiate a Rototrans with some random data sampled from a normal distribution: from motion import Rototrans n_frames = 100 size = 4 , 4 , n_frames rt = Rototrans . from_random_data ( size = size ) You can choose any distribution available in numpy.random : rt = Rototrans . from_random_data ( distribution = \"uniform\" , size = size , low = 1 , high = 10 ) Source code in motion/rototrans.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @classmethod def from_random_data ( cls , distribution : str = \"normal\" , size : tuple = ( 4 , 4 , 100 ), * args , ** kwargs ) -> xr . DataArray : \"\"\" Create random data from a specified distribution (normal by default) using random walk. Arguments: distribution: Distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions) size: Shape of the desired array args: Positional argument(s) to be passed to numpy.random.`distribution` kwargs: Keyword argument(s) to be passed to numpy.random.`distribution` Returns: Random rototrans `xarray.DataArray` sampled from a given distribution !!! example To instantiate a `Rototrans` with some random data sampled from a normal distribution: ```python from motion import Rototrans n_frames = 100 size = 4, 4, n_frames rt = Rototrans.from_random_data(size=size) ``` You can choose any distribution available in [numpy.random](https://docs.scipy.org/doc/numpy-1.14.0/reference/routines.random.html#distributions): ```python rt = Rototrans.from_random_data(distribution=\"uniform\", size=size, low=1, high=10) ``` \"\"\" return Rototrans ( getattr ( np . random , distribution )( size = size , * args , ** kwargs ) . cumsum ( - 1 ) )","title":"from_random_data()"},{"location":"api/rototrans/#motion.rototrans.Rototrans.from_transposed_rototrans","text":"Rototrans DataArray from a tranposed Rototrans. Parameters: Name Type Description Default rt DataArray Rototrans to transpose required Returns: Type Description DataArray Transposed Rototrans xarray.DataArray Example from motion import Rototrans rt = Rototrans . from_random_data () rt_t = Rototrans . from_transposed_rototrans ( rt ) Notes The inverse Rototrans is, by definition, equivalent to the tranposed Rototrans. Source code in motion/rototrans.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 @classmethod def from_transposed_rototrans ( cls , rt : xr . DataArray ) -> xr . DataArray : \"\"\" Rototrans DataArray from a tranposed Rototrans. Arguments: rt: Rototrans to transpose Returns: Transposed Rototrans `xarray.DataArray` !!! example ```python from motion import Rototrans rt = Rototrans.from_random_data() rt_t = Rototrans.from_transposed_rototrans(rt) ``` !!! notes The inverse Rototrans is, by definition, equivalent to the tranposed Rototrans. \"\"\" return rototrans . rototrans_from_transposed_rototrans ( cls , rt )","title":"from_transposed_rototrans()"}]}